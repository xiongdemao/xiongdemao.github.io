<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>加油，小伙儿</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-02-19T13:32:13.221Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>熊的猫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tack笔记</title>
    <link href="http://yoursite.com/2017/11/13/%E9%9A%8F%E7%AC%94/tack%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/11/13/随笔/tack笔记/</id>
    <published>2017-11-13T14:34:22.000Z</published>
    <updated>2021-02-19T13:32:13.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-运动目标跟踪简介"><a href="#1-运动目标跟踪简介" class="headerlink" title="1.运动目标跟踪简介"></a>1.运动目标跟踪简介</h2><pre><code>运动目标跟踪在军事制导，视觉导航，机器人，智能交通，公共安全等领域有着广泛的应用。例如，在车辆违章抓拍系统中，车辆的跟踪就是必不可少的。在入侵检测中，人、动物、车辆等大型运动目标的检测与跟踪也是整个系统运行的关键所在。所以，在计算机视觉领域目标跟踪是一个很重要的分支。</code></pre><p><strong>运动目标检测是运动目标跟踪的前提</strong>；运动目标检测，依据目标与摄像机之间的关系可以分为静态背景下的运动检测与动态背景下的运动检测。</p><h4 id="一，静态背景下的运动检测：整个监控过程中只有目标在运动；主要包括以下几种方法。"><a href="#一，静态背景下的运动检测：整个监控过程中只有目标在运动；主要包括以下几种方法。" class="headerlink" title="一，静态背景下的运动检测：整个监控过程中只有目标在运动；主要包括以下几种方法。"></a>一，静态背景下的运动检测：整个监控过程中只有目标在运动；主要包括以下几种方法。</h4><pre><code>1，背景差分法；整个监控过程中，需要不停地维护一个“纯背景”。对于任意一帧监控画面而言，将其与纯背景进行差分，从而得到出现在当前画面中的运动目标。该方法对光照变化、天气、背景变化比较敏感。而且，需要不停进行地依靠学习来维护一个纯背景画面。此外，背景的维护和更新，阴影去除等对运动目标的检测至关重要。2，帧间差分法；通过相邻帧之间的差值计算，来获得运动目标的位置、形状等信息的方法。该方法对光照的适应能力很强，但由于运动目标像素上的相似性，从而不能完整地检测出运动目标。需要提醒的是，有研究人员将相邻帧间的差分进行改进，得到三帧差分方法。即，利用相邻三帧之间的差值计算，来进行运动目标的检测。该方法经很多研究人员和工程师的实际测试，证明了其在特定环境中优良的性能。3，光流法；在空间中，运动可以用运动场描述；而在一个图像平面上，物体的运动往往是通过图像序列中图像灰度分布的不同来体现, 从而使空间中的运动场转移到图像上就表示为光流场。光流场反映了图像上每一点灰度的变化趋势。它可看成是带有灰度的像素点在图像平面上运动而产生的瞬时速度场,也是一种对真实运动场的近似估计。在比较理想的情况下，它能够检测独立运动的对象而不需要预先知道场景的任何信息, 可以很精确地计算出运动物体的速度，并且可用于动态场景的情况。但是大多数光流方法的计算相当复杂, 对硬件要求比较高, 不适于实时处理, 而且对噪声比较敏感,抗噪性差。</code></pre><h4 id="二，动态背景下的运动检测：监控过程中，目标和背景都在发生运动或变化；在运动目标检测的应用环境中，动态背景相比而言更加复杂。根据相机的运动形式，可以分为以下两种："><a href="#二，动态背景下的运动检测：监控过程中，目标和背景都在发生运动或变化；在运动目标检测的应用环境中，动态背景相比而言更加复杂。根据相机的运动形式，可以分为以下两种：" class="headerlink" title="二，动态背景下的运动检测：监控过程中，目标和背景都在发生运动或变化；在运动目标检测的应用环境中，动态背景相比而言更加复杂。根据相机的运动形式，可以分为以下两种："></a>二，动态背景下的运动检测：监控过程中，目标和背景都在发生运动或变化；在运动目标检测的应用环境中，动态背景相比而言更加复杂。根据相机的运动形式，可以分为以下两种：</h4><p>1，相机支架固定；但相机可以随着云台的运动而发生旋转，倾斜等运动。另外，相机也可以根据远程计算机指令来控制镜头调焦，从而产生远景和近景缩放运动。</p><p>2，相机置于移动设备之上（例如，车载相机）；</p><p>对于以上两种相机运动形式的任意一种而言，在进行运动目标检测之前，都需要根据一定的方法进行全局运动估计与补偿。通常，可以利用块匹配法、特征点匹配法等进行运动量的估计。当然，也可以利用光流法建立光流场模型，利用光流方程求解图像像素点的运动速度。</p><p>运动目标跟踪就是在一个连续视频序列中，在每一帧监控画面中找到感兴趣的运动目标（例如，车辆，行人，动物等）。跟踪可以大致分为以下几个步骤：</p><p>（1）目标的有效描述；目标的跟踪过程跟目标检测一样，需要对其进行有效的描述，即，需要提取目标的特征，从而能够表达该目标；一般来说，我们可以通过图像的边缘、轮廓、形状、纹理、区域、直方图、矩特征、变换系数等来进行目标的特征描述；</p><p>（2）相似性度量计算；常用的方法有：欧式距离、马氏距离、棋盘距离、加权距离、相似系数、相关系数等；</p><p>（3）目标区域搜索匹配；如果对场景中出现的所有目标都进行特征提取、相似性计算，那么，系统运行所耗费的计算量是很大的。所以，我们通常采用一定的方式对运动目标可能出现的区域进行估计，从而减少冗余，加快目标跟踪的速度；常见的预测算法有：Kalman滤波、粒子滤波、均值漂移等；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-运动目标跟踪简介&quot;&gt;&lt;a href=&quot;#1-运动目标跟踪简介&quot; class=&quot;headerlink&quot; title=&quot;1.运动目标跟踪简介&quot;&gt;&lt;/a&gt;1.运动目标跟踪简介&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;运动目标跟踪在军事制导，视觉导航，机器人，智能交通，公共安全
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《3D Point Cloud Registration for Localization using a Deep Neural Network Auto-Encoder》读书笔记</title>
    <link href="http://yoursite.com/2017/11/13/%E9%9A%8F%E7%AC%94/%E3%80%8A3D%20Point%20Cloud%20Registration%20for%20Localization%20using%20a%20Deep%20Neural%20Network%20Auto-Encoder%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/11/13/随笔/《3D Point Cloud Registration for Localization using a Deep Neural Network Auto-Encoder》读书笔记/</id>
    <published>2017-11-13T14:34:22.000Z</published>
    <updated>2021-02-19T13:32:13.224Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.researchgate.net/publication/316455393_3D_Point_Cloud_Registration_for_Localization_Using_a_Deep_Neural_Network_Auto-Encoder" target="_blank" rel="external">3D Point Cloud Registration for Localization using a Deep Neural Network Auto-Encoder</a></p><p>题目：基于深度神经网络自编码的3D激光点云匹配定位方法</p><blockquote><p>介绍：<br>本文将介绍一种3D点云定位方法，该方法需要一个全局的3D点云地图，以及几次连续扫描得到局部的点云子集，而无需考虑先验信息。</p><p>局部的点云子集又称为超点集。超点集是连续几次扫描得到的、外围具有重合区域的点云，并初步过滤了低质量的、不重要的区域。它们表示环境的几何结构信息。</p><p>通常的方法是人工设计关键点描述子的进行粗略匹配，本文利用超点集代替了关键点，这样可以充分利用点云的几何结构关系，进行更准确仿射变换。并借鉴了机器视觉的研究趋势，将自编码深度神经网络应用于局部3D点云。本方法经过许多具有挑战性的点云数据检验，相比以往的方法，在有噪音、缺少数据的情况下，更加鲁棒。</p></blockquote><p>##摘要</p><p> 　　我们提供了一种在大规模点云和近距离扫描点云之间的匹配的算法，提供了一个完全独立于两个点云坐标系统初始位置信息的定位解决方案。该算法表示为“LORAX”，它选择用我们称之为“超点集”的局部点云子集和”低维描述符”描述每个点的几何结构。然后使用这些描述符来推断潜在的匹配区域以进行有效的粗略匹配处理，然后进行微调阶段。通过覆盖重叠的点云来选择超点集合，然后过滤出低质量或不明显的区域。“描述符”是使用最先进的无监督机器学习来计算的，利用基于深度神经网络的自编码技术。<br> 　　<br>　　针对普遍的使用手动设计的关键点描述符来进行粗点云匹配，这个新颖的框架提供了一个强有力的替代方法。利用超点集而不是关键点集，可以更好地利用可用的几何数据来找到正确的转换。在编码局部三维几何结构时使用深度神经网络自编码器代替传统的“描述符”继续在其他计算机视觉应用中看到的趋势，并且确实取得优异的结果。该算法在具有挑战性的点云匹配数据集上进行了测试，与之前的方法比较其优点体现在对密度变化，噪声和缺失数据的鲁棒性。 </p><p>##１．引言</p><p>###1.1概况<br> 　　点云与图像类似，含有描述我们周围的世界的对象的语义信息。 与图像数据不同的是，图像数据在一个固定的网格场景保存了二维目标，点云是一组的在统一的坐标系中无组织的三维点，它捕捉的是3D空间信息。点云数据分析方法已经在过去的几十年里的到了发展[^footnote]，并且这个领域正在不断取得显著性突破的一个重要原因是经济实惠高质量的3D扫描技术的进步[^footnote]，机器学习突破和新的有趣的应用程序。</p><p>　　点云匹配的定义是找到在两个独立的点云坐标系之间的转换公式。它是“即时定位与地图构建”（SLAM）[^footnote] [^footnote]，场景的三维重建[^footnote]等的关键。它已成为基于视觉的自主驾驶的的核心问题[^footnote]。点云匹配取得了很大的进展，但仍然有重大的进展挑战，如大规模点云的匹配，具有低场景重叠且没有先前的位置信息。<br>　　<br> 　　今天的户外定位严重依赖于GPS技术，在地面增强系统的辅助下，提高准确性 。卫星定位需要接收来自多个卫星的信号，准确度受到卫星数量，天气和物理障碍物阻塞或改变信号路径的影响。这项技术在在一些卫星地面基础设施不完善的地区是不准确的[^footnote]。<br> 　　<br>　　在本文中，我们重点介绍一种定位技术，它依靠匹配一个全局点云和一个在同一个场景内不同时间扫描得到的局部点云技术。匹配在云的初始坐标系中与邻近信息无关。我们定义了两种类型的点云：一个“全局点云”，由一个大型户外场景扫描得到的点云，它的坐标是现实世界的地理坐标系统；另外一个是“ 局部点云”，由一个小得多的点云组成，它处在在全局点云场景内的未知位置和未知方向。在局部点云和全局点云之间的转换公式是使用一个机器学习的几何分析进行计算而得到的。这种技术作为一种高质量的定位方法在户外环境是完全与GPS的独立的。『 参见图1』 </p><p><img src="https://www.researchgate.net/profile/Gil_Elbaz/publication/316455393/figure/fig1/AS:486979151372288@1493116285586/Figure-1-Registration-between-a-close-proximity-point-cloud-colored-and-a-large-scale.ppm" alt="这里写图片描述"><br>          <em>图1 绿色为超点集，灰色为全局的3D点云地图</em>　　</p><p>###1.2相关工作</p><p> 　　匹配算法分为粗匹配和精细匹配。粗略的匹配算法对点云的位置没有先前的临近假设，只是一个粗略的对齐，这意味着他的一个损失函数比较宽松。精细的匹配算法假定输入点云大致对齐; 因此它们利用点之间的初始接近度来调整点云坐标系之间的对齐。当连续获取两个场景之间大量重叠时，或者作为粗略匹配过程的后续，可以使用精细匹配 。</p><p>　　虽然已经有大量的点云粗匹配方法[^footnote]，但粗匹配仍然是一个开放的挑战，有很大的改进空间。在快速点特征直方图[^footnote][^footnote]（FPFH）算法中，一个针对点云内的每个点在多个尺度上计算基于直方图的描述符。多尺度计算中的显著持续直方图被标记为关键点，然后将其匹配以找到点云之间的配准。其他描述符也用于定位和描述关键点。参见[^footnote]进行调查。一些例子是3D-SIFT [^footnote]，NARF [^footnote]和SHOT [11]。许多复杂的手工编码特征被提出，其目标是旋转和平移不变，对噪声具有鲁棒性。</p><p>　　在二维计算机视觉领域，由于深度学习领域的突破性研究 [^footnote]，类似的手动编码特征的发展时期已经戛然而止。使用深度学习方法，从数据中计算出更先进的特征（具有超越人性化设计的复杂性），推进了二维计算机视觉领域的主要领域，如检测，分类，分割，定位和配准 [^footnote]。这些方法几乎专注于二维数据。非结构化的，连续的和大的点云数据集产生了这样的极端的问题，这个问题是2维数据不能直接的适应3维空间。为了在我们的方法中利用三维数据，点云被密集采样，并且每个局部表面的2.5维数据被捕获和组合。深度学习的先进工具被应用到这些数据中，以无监督机器学习的形式来实现高质量降维 [^footnote]，作为粗略点云匹配的关键阶段 。<br>　　<br>　　针对机载LIDAR点云的粗略配准，开发了一种基于线性平面匹配的不同方法[^footnote]。 依靠线性结构的存在，这种方法仅限于特定的数据集类。<br>　　<br>　　点云之间精细配准的问题已经被深入研究，目前在线应用如SLAM存在高质量的解决方案[3,4]。 解决方案围绕迭代最近点（ICP）[^footnote]算法及其改进[^footnote]。 一个值得注意的基于傅里叶域[^footnote]扩展高斯图像相关性的精细配准方法被提出来作为ICP的一个替代方案，尽管最后一个阶段再次依靠ICP迭代来进行微调。 良好的匹配并不是本研究的重点，尽管为了实现端到端匹配，标准的ICP算法在其最终阶段被使用。<br>　　<br>　　上述所有匹配方法都是针对输入点云对进行设计的，这些输入点云对数量级相差不大，数量较少（低于100万）。</p><p>##1.3.贡献<br>　　这项工作提出并测试了两种原创的方法，首次提出基于点云的匹配方法。<br>　　<br>　　1.使用超级点（由随机球体覆盖集选择）作为匹配的基本单位，而不是常用的关键点或局部线性结构。 这利用了更广泛的几何结构，并更好地利用可用数据来发现正确的转换。 此外，它将算法的其余部分的复杂性转化为与点云场景中覆盖的表面积相关，而不是场景中的点数。 它非常简单，快速，并且具有可扩展性。<br>　　<br>　　2.使用深度神经网络自动编码器编码局部3D几何结构。 该方法在图像分析应用程序中提供了最先进的编码。 通过对数据进行调整并在开发的算法流水线中应用这种方法，可以从数据中创建出功能优于人工设计的局部几何特征。<br>　　<br>　　我们在这里展示，结合这些想法在多个具有挑战性的数据集上产生达到期望的的匹配结果。该方法是通用的，它可以处理任何数据，而不管传感器或场景的类型如何。<br>　　<br>　　虽然大多数配准算法处理相似的点云，但我们采用点云的独特问题设置，它们的尺寸明显不同，我们设计的算法对大规模扫描数据有效。 虽然算法需要初始阶段，但在线阶段可以高效地并行执行，使其适用于实时应用程序。</p><p>#2.基于“LORAX”的点云匹配算法</p><p>　　我们专注于两类点云的匹配：描绘大型户外区域的全局点云，以及从全局点云场景内捕获的小型局部点云。全局点云可以包含多达1亿个3D点，而局部点云可以小2-3个数量级。<br>　　<br>　　在本节中，我们提出使用基于深自动编码器减少的覆盖集（LORAX）的匹配算法来进行定位。</p><p>##2.1.算法概貌<br>这个算法包含以下几步：<br>　　1．使用“Random Sphere Cover Set algorithm”算法将点云分为超点集。<br>　　2.为每一个超点集选择一个归一化的局部坐标系。<br>　　3.将超点集数据投影到二维深度图上。<br>　　4.对于超点集进行显著性检测和渗透（ﬁltration）。<br>　　5.利用深度遗传网络自编码器来降维。<br>　　6.寻找相关描述符之间的候选匹配。<br>　　7.利用本地化搜索来进行粗匹配。<br>　　8.微调迭代最近点。<br>接下来，算法的每一步将进行详尽的解释和分析。</p><p>##2.2.Random Sphere Cover Set (RSCS）“随机球体覆盖集”　　<br>　　首先超点集（SP）将用作匹配过程的基本单位被定义。 每个超点集是描述局部曲面的点的一个子集。重叠是允许的（即一个点可以包含在几个中超点）。 为了获得云中几乎所有点（〜95％）的覆盖率，我们建议采用下面的迭代过程：（1）随机选择一个不属于任何SP的点“P”; （2）将一个新的SP定义为位于以“P”为中心的固定半径为“Rsphere”的球体内的一组点。<br>　　<img src="https://www.researchgate.net/profile/Gil_Elbaz/publication/316455393/figure/fig2/AS:486979151372290@1493116285843/Figure-2-Coverage-of-points-vs-RSCS-iterations.ppm" alt="这里写图片描述"><br>      Figure 2: Coverage of points vs. RSCS iterations</p><p>　　这个简单的过程，我们称之为RSCS，具有有趣的属性，可以估计半径“Rsphere”参数。在随机球体填充中，非重叠的球体显示出填充大约64％的封闭3D区域[^footnote]。 假设“Vlocal”是包含局部点云的球体的体积，并且是在算法的最后阶段使用的匹配数量。 为了确保最少m个SP对匹配，我们选择半径“Rsphere”，这样就有可能在体积”Vlocal“内随机打包”2m“个球体。</p><p><img src="http://chart.googleapis.com/chart?cht=tx&chl=R_%7Bsphere%7D%5Capprox%20(%5Cfrac%7B3%7D%7B4*pi%7D*%5Cfrac%7B0.64%7D%7B2*m%7D*V_%7Blocal%7D)%5E%7B%5Cfrac%7B1%7D%7B3%7D%7D" style="border:none;">              (1)</p><p>　　在补充材料中分析了给定局部和全局点云内在参数的RSCS算法创建的SP数量。结果表明，该方法覆盖了点云呈指数衰减的点。 图2显示了作为RSCS迭代函数的覆盖点的百分比。 RSCS算法在全局点云上应用一次，在局部点云上多次应用，以便在后期的鲁棒性。 如图7（a）和（b）所示，从RSCS的多个应用程序在本地点云上找到的<img src="http://chart.googleapis.com/chart?cht=tx&chl=N%5E%7Blocal%7D_%7BSP%7D" style="border:none;"> SP在算法的下一个阶段被组合成一个代表本地点云的单个集合。</p><p>##2.3.为每一个超点集选择一个归一化的局部坐标系<br>　　一个SP的局部坐标系定义如下：原点被设置为SP的质心，然后在SP内点的估计协方差矩阵上使用奇异值分解（SVD）来设置SP的坐标系 。<br>　　假设每个SP描述场景表面在这个阶段被利用。曲面的特征值是具有两个大小相近的大特征向量和一个较小的特征向量。这意味着这些点主要分散在两个维度上，而第三维的变化则显着较低。 z轴被设置为第三特征向量。 为了定义x轴，计算SP的不连续径向切片的平均高度并插入到极坐标直方图中。 然后将x轴设置为与最大仓（bin）对应的方向。 这个局部坐标系统创建不变的SP的位置和方向，同时保留其几何特性。</p><p>##2.4.深度图投影<br>　　将每个SP代入本地坐标系后，可以直接进行比较。 然而，结果将是完全不可靠的，因为它们已经受到点密度变化和随机噪声的影响。 降低维度对于减轻这些影响至关重要。 为此，连续点位置数据被转换成离散图像格式（大小为[dim1，dim1]）。将SP缩放到图像dim1的尺寸（我们使用dim1 = 64），之后将每个点的z轴高度投影到每个对应像素的深度图上。 最后，将图像裁剪为[dim2，dim2]（我们使用dim2 = 32），以去除深度图中SP的圆形边缘。 参见图3（a）和（b）</p><p><img src="https://www.researchgate.net/profile/Gil_Elbaz/publication/316455393/viewer/AS:486979138789376@1493116282891/background/4.png" alt="这里写链接内容"><br>(a) Example SP     (b) The depth map     (c) The reconstruction<br>Figure 3: Super-point depth map projection  </p><p>　　为了减少噪音和变化的密度的影响，最大的过滤器和平均过滤器被应用于图像。SP信息的修改可以通过从深度图重构SP来可视化。 如图3（c）所示，重构可靠地保持与原始SP点云相同的几何形状和质量，同时在未知稀疏区域上创建完整覆盖。</p><p>##2.5.显著性检测和过滤</p><p>　　为了获得最快和最好的质量的匹配，应该减少通过这条管线的不相关SP的数量。不相关的SP被三个标准过滤：密度，几何特性和显着性水平。<br>　　<strong>密度测试</strong>：密度是以绝对值和其他SP值来衡量的。这意味着包含少于<img src="http://chart.googleapis.com/chart?cht=tx&chl=N_%7Bd%7D" style="border:none;">点的SP被滤除。另外，与其最接近的相邻SP（在SP重心之间测量的欧几里德距离）相比，具有相对较少点的SP也被滤除。<br>　　<strong>几何质量测试</strong>：测量各个局部坐标系内各个SP的高度。过滤掉在表面的低高度SP信号。<br>　　<strong>显着性测试</strong>：来自全局点云的SP深度图被重新整形成长度为<img src="http://chart.googleapis.com/chart?cht=tx&chl=d%5E%7B2%7D_%7Bim2%7D" style="border:none;">的列“深度矢量”。对于该组深度矢量执行主成分分析（PCA）。仅使用前三个特征向量精确重构的SP（SP来自于局部和全局点云）已经在数据集中发现了几何特征，因此被滤除。这降低了位于不同点云区域的类似SP的匹配机会 。</p><p>##2.6.通过自动编码器来降维<br>　　该算法的一个关键阶段是比较全局和局部点云内部的SP几何。 即使具有相同的语义含义，高维物体的比较也容易产生较大的噪音和方差。为了比较SP几何的语义，必须在保留最大几何信息的同时减小深度图像的尺寸。本文研究了两种单独的降维方法。 第一个基于PCA，第二个基于深度自动编码器（DAE）。　　</p><p>###2.6.1线性降维<br>　　PCA方法通过将其投影到较低维的线性超平面上来降低数据的维数。 根据全局点云SP的深度向量（类似于显着性检测，但是这里k&gt; 3）来计算基本向量的基数。 对应于特征向量的特征值定义重建每个SP所需的叠加。 保持SP的几何信息的紧凑表示特征被表示为主分量分析超点特征（PCAF）。 需要注意的是，PCA创建了数据的线性投影，这导致高数据损失和相对较大的简化形式。 这种方法是DAE方法的可比基准。　　</p><p>###2.6.2深度自动编码器降维</p><p>　　结果表明，DAE神经网络[16]产生了最先进的图像压缩。 在这里，我们使用这种技术来获得在深度图中捕获的2.5D超点几何体的紧凑表示。<br>　　DAE神经网络架构由编码器和解码器阶段组成。 编码器阶段从输入层开始，然后连接到隐藏层，逐渐减小直到达到所需的紧凑尺寸。 解码器阶段从数据的紧凑表示开始; 每个后继隐含层的维数较高，直到输出层维数达到输入维数为止。损失函数定义为输入层和输出层之间的像素误差，优化网络实现用图像的最佳紧凑表示。<br>　　为了设计适合我们应用的DAE，我们进行了大量的实证测试和优化。 我们得出结论，一个具有4个完全连接隐藏层的网络，使用每个层之间的S形非线性激活函数和输入层上的压差（DO），会返回满意的结果。 为了进一步减少网络中的参数数量，第四和第一隐藏层以及第三和第二层以相同权重彼此镜像，同时保留单独学习的偏差值。 这种权重共享意味着反向传播学习算法被约束为编码和解码过程优化相同的权重[^footnote]。 缩小的紧凑尺寸由编码器输出尺寸定义。 该架构使用以下维度：1032（input），[1032,128]（L1），[128,10]（L2），[10,128]（L3），（128,1032）（L4），1032（output）。 参见图4。<br>　　<img src="http://img.blog.csdn.net/20171109204736502?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>Figure 4: Deep Auto-encoder architecture</p><p>　　利用数据驱动和综合深度图的组合来初始训练深度神经网络。使用100,000个超点集深度图来训练所提出的DAE。 训练阶段是无监督的，即不需要手动注释数据，网络以随机权重初始化。 这个培训过程是有效的，网络可以通过周期性地更新，从扫描的本地云中获取附加的点云数据来改善。 流程训练过程可能很长，但编码部分可以在线并且快速地激活。<br>　　这种紧凑的低维表示可以被看作是捕获整个SP的几何信息的特征。 它代表一个固定的低维向量的SP，与SP中的点数不相关。 与在每个点上竞争的局部描述符相比，这是在复杂度的降低方面的实质性改进。 基于SP自动编码器的特征（SAF）可以用于许多任务，例如检测或分类3D对象，而在这里我们优化它的匹配。<br>　　　<img src="http://img.blog.csdn.net/20171109204803901?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>Figure 5: Visualization of deep auto-encoder input, reduction and reconstruction</p><p>　　图5示出了输入到DAE中的深度图的例子，并且被简化为10维SAF（为了更好的可视化而被放大的5×2矩阵），然后通过解码器被重构成原始尺寸。 深度图的高度被转换为颜色：蓝色对应于零高度，深红色对应于最大高度。 重建与输入不相同，但它确实捕获了SP的一般几何形状。 这对噪声的鲁棒性和对我们的应用而言至关重要的小的改变是最佳的，同时捕获重要的SP几何特性。<br>　　为了进一步显示DAE的有效性，分析从数据内学习到的特征，并将其与从PCA方法计算的特征向量进行比较。为此，将SAF向量中的每个维度的独立激活输入到解码器中以可视化 DAE学到了什么。参见图6。<br>　　PCA的特征向量和DAE的独立解码器激活是紧凑表示“构建块”的两种创建的方法。 图6（a）显示了每个特征向量的增长的复杂性，它是根据特征值排序的。 这与图6（b）的非结构化DAE激活图像形成对比。 PCA方法可以近似为只有线性函数的单隐层神经网络[^footnote]。 这意味着为了表示复杂的几何图形，需要复杂的特征向量。 由于DAE中数值的多层叠加，复杂的几何体使用相对简单的“构建块”来表示。　　</p><p><img src="http://img.blog.csdn.net/20171109203628375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(a) PCA eigenvectors</p><p><img src="http://img.blog.csdn.net/20171109203728076?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(b) DAE independent decoder activations<br>Figure 6: Compact Representation Vectors</p><p>##2.7.选择理想的匹配</p><p>　　在用SAF向量描述每个SP之后，我们选择一组类似描述的SP对作为匹配的候选。 通过测量SAF特征之间的欧几里得距离，局部点云中的每个SP与来自全局点云（我们将K设置为3）的K个最近邻居配对。 当与i + 1最邻近点相关的距离显着大于与i最近邻点相关的距离时，我们滤出候选值i + 1到K.请注意，<img src="http://chart.googleapis.com/chart?cht=tx&chl=P_%7Bcandidates%20%7D" style="border:none;">的数量是O（<img src="http://chart.googleapis.com/chart?cht=tx&chl=N%5E%7Blocal%7D%20_%7BSP%7D" style="border:none;">）的顺序。 为了得到所选择的候选点云集的数量，考虑一个全局点云数量为1000万点，局部点云数为50万的问题。 对于这个集合，我们从本地点云中获得大约200个SP，这意味着选择了大约550个候选者。 参见图7（c）。</p><p><img src="http://img.blog.csdn.net/20171111192506338?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(a) Global point cloud with RSCS (b) Local point cloud<br>with RSCS<br><img src="http://img.blog.csdn.net/20171111192603271?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(c) Matching candidate connections</p><p>Figure 7: RSCS and matching candidates (each point is col-<br>ored according to the last RSCS iteration to cover it)</p><p>##2.8.基于本地化搜索的粗匹配<br> 　　为了找到点云之间的6DoF（6自由度）变换，至少需要3个匹配（为了鲁棒性，我们使用了m = 6）。处理至少<img src="http://chart.googleapis.com/chart?cht=tx&chl=P%5E%7Bcandidates%7D%20_%7Bm%7D%0A" style="border:none;">的搜索空间大小是不切实际的（对于上面的例子超过<img src="http://chart.googleapis.com/chart?cht=tx&chl=10%5E%7B13%7D" style="border:none;">）。因此，我们考虑每个迭代只有m个候选对，所有全局云点可以包含在一个体积不超过<img src="http://chart.googleapis.com/chart?cht=tx&chl=V_%7Blocal%7D" style="border:none;">的球体中。这将转换选项的搜索空间减少了8到9个数量级（将上例中的选项减少到约40,000）。我们使用RANSAC [^footnote]程序，迭代地选择6个候选对，计算变换，并通过测量本地点云中的变换点与其全局点云中的最近邻点之间的平均（物理）距离来检查一致性。 （为了节省运行时间，我们只转换局部点云的稀释版本。）我们测试了10,000个随机选择（约1/4的搜索空间）。我们不是只选择最好的评分变换作为粗略配准步骤的结果，而是记录5个最佳变换（T1，…，T5），其中局部点云不重叠。然后将精细调整步骤（在下一节中介绍）应用于每个调整步骤，最后得到最佳评分细节的调整步骤将被选中。</p><p>##2.9.微调最近迭代点<br>　　简单迭代最近点（ICP）精细调整被执行，由T1，…，T5转换中的每一个进行初始化。选择具有最低ICP损失的配准，定义LORAX输出变换。这个步骤源于我们认识到“最接近的”粗配准结果并不总是与正确的配准结果相关，因为优化函数中存在许多局部最小值。最好的匹配会根据经验显示对应于约75％的案例中最好的粗略匹配，约18％的案例是次优匹配，约4％是第三好的匹配。 这个阶段可以被任何微调方法取代。</p><p>##2.10.效率讨论<br>　　我们目前的实施并未针对实时性能进行优化。然而，考虑到全局点云通过航空LIDAR或立体重建提前捕获，该算法确实有潜力被纳入现场设备并执行实时定位。我们设计了神经网络训练过程和全局点云到降维阶段的计算。来自全局点云的紧凑描述符可以与全局点云的降采样版本一起保存到在线设备中。一旦本地点云从全局场景内的未知位置在线捕获，SP分区，归一化，显着性检测和DAE降维阶段可以独立地为每个SP并行执行。然后，基于KD树[^footnote]，基于RANSAC的局部候选搜索[^footnote]和ICP [^footnote]的KNN候选选择也可以并行地（使用多个CPU和/或GPU）并行地完成。 RSCS方法和SAF描述符的代码可在以下网址获得：<a href="https%EF%BC%9A//github.com/gilbaz/LORAX">https：//github.com/gilbaz/LORAX</a></p><p>#3.实验及其结果<br>　　在整个实验中显示了RSCS SP创建优于FPFH持久性关键点检测的优点，以及SAF与FPFH描述符相比的描述性质量。 每个登记阶段都使用“点云配准算法的挑战性数据集”[^footnote]进行了广泛的测试，将近距离点云与两个不同季节拍摄的同一场景的全局大型点云进行匹配。此外， 为了更好地理解不同类型噪声对配准的影响，采用大尺度航空点云进行对比实验。</p><p>##3.1.挑战性的数据集配准测试<br>　　所使用的数据集包含许多户外场景的点云，由地面LIDAR扫描仪捕捉，多个季节。 通过将每个场景中捕获的点云激光扫描拼接在一起，创建出真实的全局点云。 这个点云数据是测试LORAX算法的理想选择。 我们通过将局部点云记录到同一场景的全局点云中进行测试，并在不同季节拍摄。 这种设置确实充满挑战。 场景中包含一些刚性静止的物体，如凉亭结构，灯柱和长凳，还有人，灌木和树枝等不一致的物体。 这个挑战由于扫描角度和遮挡而丢失信息而提高。<br>　　参见图1为LORAX结果的一个例子。 颜色表示局部点云（匹配之后）中每个点与全局点云中最近邻点之间的相对距离，其中绿色更接近，红色更远。<br>　　我们测试和比较RSCS超点集与关键点的匹配表现，还有FPFH描述符与PCAF的匹配表现，以及FPFH描述符与SAF的匹配表现。结果总结在表1中。<br><img src="http://img.blog.csdn.net/20171111201208718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>　　为了比较基于关键点的方法，我们遵循[9] 。 “RSCS + FPFH”方法计算与RSCS超点集中心点对应的FPFH描述符。报告的每个结果是12个局部点云的平均性能，来自“Gazebo”数据集的9个和来自“Wood”数据集的3个。对于每个记录结果，我们测量[^footnote]中使用和定义的相对平移误差（RTE）和相对旋转误差（RRE）。当RTE低于预定义的阈值（我们使用1米）时，匹配结果被定义为二进制“成功”。对于每个测试，我们报告二进制成功率和成功测试的平均RTE和RRE分数。所有方法使用相同的微调程序，因此实现相似的RTE，但是它们具有不同的结果RRE和二进制成功率，表示质量以及粗略匹配的鲁棒性。</p><p>　　表1显示，使用RSCS组合的点云细分和DAE来创建SAF会产生最稳健和最高质量的匹配结果。从RSCS获得的鲁棒性在KP + FPFH与RSCS + FPFH的比较中是明显的。 RSCS + FPFH到RSCS + PCAF和RSCS + SAF的比较显示了使用基于机器学习的功能优于手动设计的功能的优点，以及SAF优于PCAF的优点。</p><p>##3.2.噪声，遮挡和密度敏感度测试</p><p>　　为了进一步测试LORAX的质量和局限性，我们使用了一些由[^footnote]提供的城市户外场景点云。这些点云大约150万个点，描绘了250平方米的大面积。参见图8的例子。图8：描绘与周围的房屋和道路的小山的空中扫描点云。<br>　　<img src="http://img.blog.csdn.net/20171111201938808?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>Figure 8: Aerial scanned point cloud depicting hill with sur-<br>rounding houses and roads. An example from [30] dataset</p><p>　　为了能够控制噪声，密度和遮挡的不同参数，我们进行半合成实验，从大的原始点云中裁剪半径为15-50米的小点云.将LORAX和KP + FPFH配准算法在局部点云的改动版本上进行测试，并将其与原始全局点云进行匹配。<br>　　噪声修改包括：（1）随机移动10％，20％，50％ （2）随机抽取10％，20％，50％的点，测试对云密度的敏感性;（3）模拟去除局部随机球内的10％， 20％，50％的遮挡。 参见图9。<br><img src="http://img.blog.csdn.net/20171111202755641?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>(a) Original cropped local point cloud<br>(b) Same cloud with simulated noise and occlusions<br>Figure 9: Simulating noise, density change, and occlusions</p><p>　　对3个全景场景中的50个随机剪切点云进行了测试，分析了下采样（密度变化）（DS），随机重定位噪声（RN）和遮挡（OC）对各自的影响。图10总结了结果。为了澄清，在给定噪声指定的情况下，图上的每个点代表50个配准测试的平均二进制成功率。在这个实验中，二进制成功率由2.5米的RTE阈值定义（由于全局点云的大尺度）。<br>　　<br>　　<img src="http://img.blog.csdn.net/20171111204639218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>Figure 10: Noise, Occlusion, and Density Sensitivity Tests</p><p>　　由于深度图投影阶段，这些结果显示对点密度具有高度的鲁棒性。随机噪声对我们的算法影响不大，因为SAF表示法只捕捉主要的几何特征。堵塞是最难处理的缺陷。该算法在较低的水平上克服了遮挡，但是受到很大的阻碍。总的来说，我们看到LORAX对大量的随机噪声，密度变化和遮挡不太​​敏感，而且其鲁棒性只在极端水平下才会恶化。 KP + FPFH算法（虚线）由于在全局点云的许多部分缺乏“关键点”诱导场景特征而在干净的局部点云上进行测试时返回了较低的二进制成功率。这些结果增加了对这项研究方向的信心。</p><p>#4.总结<br>　　本文提出了一种创新的点云配准算法LORAX。该算法以室外定位为目标，处理两个匹配点云之间的点数差异存在多个挑战，并涉及大量的点数。提出了两种原始方法：1）使用超点集（由随机点云的点集合组成）作为匹配的基本单位，而不是关键点; 2）使用深度神经网络自编码器编码局部3D几何结构。我们已经表明，这些想法的组合在具有挑战性的数据集上产生有希望的匹配结果。该方法是通用的，它可以处理任何数据，而不管传感器或场景的类型如何。而且，虽然它包含了一个有效的训练阶段，但在线阶段可以高效并行执行，使其适用于实时应用。</p><p>　　在未来的工作中;我们打算将这种方法适用于具有小场景重叠的类似大小的点云。另一个有趣的方向是设计这种算法的多尺度超级版本。最后，使用具有高度和颜色信息输入的卷积自动编码器可以产生出色的超点功能，可用于各种点云分析任务。</p><p>#感谢<br>　　这项研究得到了以色列工业和贸易部的Technion和Magnet Omek联盟的部分支持。 作者要感谢Elbit Systems Ltd为这项研究提供数据。</p><p>#摘要<br> 1.<a href="https://www.researchgate.net/publication/236675142_Registration_of_3D_Point_Clouds_and_Meshes_A_Survey_from_Rigid_to_Nonrigid" target="_blank" rel="external">Registration of 3D Point Clouds and Meshes: A Survey from Rigid to Nonrigid.</a>《3D点云与网格匹配：一个由刚性到非刚性的调查》</p><blockquote><p>摘要<br>3D表面匹配变换多个3D数据集到同一坐标系中以便对准这些集合中的重叠部分。最近的调查覆盖的是刚性或非刚性匹配，但很少有团队能够从不同方面讨论全过程。我们的研究有两个目的：（i）对两种类型的匹配进行了全面调查，专注于三维点云和网格，（ii）从数据拟合的角度更好地了解匹配。匹配是与数据拟合密切相关的，它包括三个核心：模式选择，相关性和约束性，优化。研究这些组分：（i）提供了一个比较不同新奇技术的比较基础，（ⅱ）揭示了刚性和非刚性在representations问题匹配的相似性 ;（iii）显示非刚性匹配过度拟合产生的原因，同时增加我们对内在技术的兴趣。我们进一步总结匹配的一些实际问题，其中包括初始化和评估，并讨论一些我们自己的意见，见解和可预见的发展趋势研究 </p></blockquote><p>2.<a href="https://www.nature.com/nphoton/journal/v4/n7/abs/nphoton.2010.148.html" target="_blank" rel="external">Brent Schwarz. Mapping the world in 3d. Nat. Photonics,4(7):429–430, 2010.[3] Hugh D</a>《激光雷达：用3D来映射世界》</p><blockquote><p>摘要<br>具有64个半导体激光器的旋转传感器头的高分辨率激光雷达系统可以以前所未有的细节高效生成3D环境地图。</p></blockquote><p>3.<a href="http://ieeexplore.ieee.org/document/1638022/" target="_blank" rel="external">Hugh Durrant-Whyte and Tim Bailey. Simultaneous localization and mapping: part i. IEEE robotics&amp; automation magazine, 13(2):99–110, 2006.</a>《定位同时建图：部分一》</p><blockquote><p>摘要<br>本文介绍了同时定位和建图（SLAM）问题和解决SLAM问题的基本方法，并总结了该方法的关键实现和演示。 虽然仍然有许多实际问题需要克服，特别是在更复杂的户外环境中，一般的SLAM方法现在已经成为机器人的一个很好的理解和建立的部分。 本教程的另一部分概述了解决SLAM中剩余的一些问题的最近的工作，包括计算，功能表示和数据关联。</p></blockquote><p>4 <a href="http://xueshu.baidu.com/s?wd=paperuri:%288d7f210f73ebaf20d4e03873a1dbe06d%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http://link.springer.com/chapter/10.1007/978-3-319-10605-2_54&amp;ie=utf-8&amp;sc_us=9457780068583818158" target="_blank" rel="external">Jakob Engel, Thomas Schöps, and Daniel Cremers.Lsd-slam: Large-scale direct monocular slam. In European Conference on Computer Vision, pages 834–849. Springer, 2014</a>《Lsd-slam：大规模直接单目slam》</p><blockquote><p>摘要<br>我们提出了一种直接（无特征）的单眼SLAM算法，与当前直接方法的最新技术相比，它允许构建大规模，一致的环境地图。 除了基于直接图像对齐的高度精确的姿态估计之外，3D环境被实时重建为具有关联半密集深度图的关键帧的姿态图。 这些是通过对大量像素小基线立体比较进行滤波而获得的。 明确的尺度漂移感知公式允许该方法在具有挑战性的序列上操作，包括场景尺度的大的变化。 主要的推动力是两个关键的新颖之处：（1）一种新颖的直接跟踪方法，在sim（3）上运行，从而明确地检测尺度漂移，（2）优雅的概率解决方案，包括噪声深度值的影响跟踪。 由此产生的直接单目SLAM系统在CPU上实时运行。</p></blockquote><p>5 <a href="http://www.sciencedirect.com/science/article/pii/S0924271610000894" target="_blank" rel="external">Norbert Haala and Martin Kada. An update on automatic 3d building reconstruction. ISPRS Journal of Photogrammetry and Remote Sensing, 65(6):570–580, 2010</a>《三维建筑物自动重建的最新进展 》</p><blockquote><p>摘要<br>近二十年前，开发3D城市模型的工具就开始了。 从一开始，全自动重建系统就设想满足高效数据采集的需要。 然而，对城市自动建模的研究仍然是一个非常活跃的领域。 本文将回顾一些当前的方法，以全面阐述重建方法的现状和各自的原则。 最初，自动城市建模只针对多面体建筑物，主要反映了各自的屋顶形状和建筑物的脚印。 为此目的，使用空中图像或激光扫描。 除了这些发展之外，本文还将回顾目前从地面数据收集中生成更加详细的立面几何的方法。</p></blockquote><p>6 <a href="http://ieeexplore.ieee.org/document/5940562/" target="_blank" rel="external">Jesse Levinson, Jake Askeland, Jan Becker, Jennifer Dolson, David Held, Soeren Kammel, J Zico Kolter,Dirk Langer, Oliver Pink, Vaughan Pratt, et al. Towards fully autonomous driving: Systems and algorithms. In Intelligent Vehicles Symposium (IV), 2011 IEEE, pages 163–168. IEEE, 2011.</a>《走向全自主驾驶：系统与算法 》</p><blockquote><p>摘要<br>为了在交通不可预知的城市中实现车辆的自主运行，几个实时系统必须互操作，包括环境感知，本地化，规划和控制。此外，具有适当传感器，计算硬件，网络和软件基础设施的强大车辆平台是至关重要的。我们以前发表了“2007年DARPA城市挑战赛”中斯坦福大学Junior的概述。这场比赛是一场封闭式的比赛，虽然历史悠久，在这个领域取得了很大的进展，但并不能完全代表现实世界中存在的情况。在本文中，我们总结了我们最近的研究，旨在在更现实的情况下实现安全和强大的自主操作。首先，三个无监督算法自动校准我们的64光束旋转激光雷达，精度优于繁琐的手工测量。然后，我们生成环境的高分辨率地图，随后用于以厘米为单位的在线定位。现在，改进的感知和识别算法使Junior能够将障碍物追踪和分类为骑自行车者，行人和车辆;红绿灯也被检测到。一个新的计划系统使用这个输入数据来生成每秒数千个候选轨迹，动态地选择最佳路径。改进的控制器不断选择油门，刹车和转向驱动，从而最大限度地提高舒适性并最大限度地减少轨迹误差。所有这些算法都可以在阳光或雨中以及白天或黑夜中工作。通过这些系统的共同运作，Junior已经在各种现实条件下成功记录了数百英里的自主操作。</p></blockquote><p>7.<a href="http://xueshu.baidu.com/s?wd=paperuri:%285efb3bee0d5669b9cccf514725980b8f%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http://trid.trb.org/view/894431&amp;ie=utf-8&amp;sc_us=6302811145085811136" target="_blank" rel="external">US DoD. Global positioning system standard positioning service performance standard. Assistant secretary of defense for command, control, communications, and intelligence, 2001 </a>《全球定位系统标准定位服务性能标准 》</p><blockquote><p>摘要<br>美国全球定位系统（GPS）标准定位服务（SPS）由天文定位，导航和定时（PNT）信号组成，为全球和平的民用，商业和科学用途免费提供直接用户费用。 此SPS性能标准（SPS PS）根据广播信号参数和GPS星座设计来规定SPS性能的等级。 美国政府致力于达到并超越本SPS规定的最低服务水平，这一承诺已经编入美国法律（10U.S.C.2281（b））。</p></blockquote><p>8.<a href="https://www.researchgate.net/publication/280040097_A_Benchmark_Survey_of_Rigid_3D_Point_Cloud_Registration_Algorithms" target="_blank" rel="external">Ben Bellekens, Vincent Spruyt, Rafael Berkvens,Rudi Penne, and Maarten Weyn. A benchmark survey of rigid 3d point cloud registration algorithms</a>《刚性三维点云配准算法的基准研究 》</p><blockquote><p>摘要<br>先进的用户界面传感器能够使用特定的光学技术（如飞行时间，结构化光线或立体视觉）三维观察环境。由于现代传感器能够融合环境的深度和颜色信息的成功，出现了不同领域的新焦点。本调查研究了不同的最先进的配准算法，它们能够确定两个相应的三维点云之间的运动。本次调查从数学的角度出发，通过解释两种确定性的方法，即主成分分析（PCA）和奇异值分解（SVD），以及迭代最近点（ICP）及其变体等迭代方法。我们将不同算法的性能与基于真实世界数据集的精度和鲁棒性进行比较。这次调查的主要贡献包括基于现实世界数据集的性能基准，该数据集包括Microsoft Kinect相机的3D点云，以及不同匹配方法的数学概述，这些概念通常用于同时定位并绘制和3D扫描。我们的基准测试结果表明，ICP点对表面法是最精确的算法。除了精度，鲁棒性的结果，我们可以得出结论：在SVD方法之后应用ICP点对点方法的组合给出最小误差。</p></blockquote><p>9 . <a href="http://ieeexplore.ieee.org/document/5152473/?arnumber=5152473&amp;tag=1" target="_blank" rel="external">Radu Bogdan Rusu, Nico Blodow, and Michael Beetz.Fast point feature histograms (fpfh) for 3d registration.In Robotics and Automation, 2009. ICRA’09. IEEE International Conference on, pages 3212–3217. IEEE,2009</a>《快速点特征直方图（fpfh）三维配准 》</p><blockquote><p>摘要<br>在我们最近的工作<a href="http://ieeexplore.ieee.org/document/4795593/" target="_blank" rel="external">[1] </a><a href="http://ieeexplore.ieee.org/document/4650967/" target="_blank" rel="external">[2]</a>中，我们提出了点特征直方图（PFH）作为鲁棒的多维特征，描述三维点云数据集点p周围的局部几何。在本文中，我们修改了它们的数学表达式，并针对重叠点云视图的3D配准问题对其稳健性和复杂性进行了严格的分析。更具体地说，我们提出几个优化，通过缓存先前计算的值或修改其理论公式来大幅减少计算时间。后者导致了一种新型的局部特征，称为快速点特征直方图（FPFH），其保留了PFH的大部分区分能力。此外，我们提出了一个在线计算实时应用的FPFH特征的算法。为了验证我们的结果，我们证明了它们的3D注册效率，并提出了一个新的基于样本共识的方法，将两个数据集带入本地非线性优化器的收敛区域：SAC-IA（SAmple Consensus Initial Alignment）。</p></blockquote><p>10 .  <a href="https://www.researchgate.net/publication/221066028_Aligning_Point_Cloud_Views_using_Persistent_Feature_Histograms" target="_blank" rel="external">Radu Bogdan Rusu, Nico Blodow, Zoltan Csaba Marton, and Michael Beetz. Aligning point cloud views using persistent feature histograms. In 2008 IEEE/RSJ  International Conference on Intelligent Robots and Systems, pages 3384–3391. IEEE, 2008 </a><br>《使用持久特征直方图调整点云视图 》</p><blockquote><p>摘要<br>在本文中，我们研究了将点云数据视图对齐成一个一致的全局模型的持久点特征直方图的使用情况。 给定噪声点云的集合，我们的算法估计了一组强大的16D特征，它们描述了每个点在本地的几何形状。 通过分析不同尺度上的特征的持续性，我们提取了一个最佳的表征给定点云的最优集合。 所产生的持久性特征被用于初始对准算法中以估计近似登记输入数据集的刚性变换。 该算法通过将数据集转换为其收敛盆地为迭代配准算法（如ICP（迭代最近点））提供了良好的起点。 我们表明，我们的方法是不变的构成和采样密度，并能应付来自室内和室外激光扫描的嘈杂数据。</p></blockquote><p>11 .<a href="https://link.springer.com/chapter/10.1007/978-3-642-15558-1_26" target="_blank" rel="external">Federico Tombari, Samuele Salti, and Luigi Di Stefano.Unique signatures of histograms for local surface description. In European conference on computer vision, pages 356–369. Springer, 2010 </a>《局部曲面描述的直方图唯一签名 》</p><blockquote><p>摘要<br>本文涉及局部三维描述符的表面匹配。 首先，我们将现有的方法分为两类：签名和直方图。 然后，通过讨论和实验，指出了局部参照系唯一性和可重复性的关键问题。 基于这些观察，我们制定了一个新的表面表示的综合提案，其中包括一个新的独特和可重复的本地参考框架，以及一个新的三维描述符。 后者位于签名和直方图之间的交集处，以便在描述性和鲁棒性之间取得更好的平衡。 对公开可用数据集的实验以及使用Spacetime Stereo获得的范围扫描提供了对我们提议的全面验证。</p></blockquote><p>12 .  <a href="http://xueshu.baidu.com/s?wd=paperuri:%28d27927f10820b09c2b7fbb1d5fb7944c%29&amp;filter=sc_long_sign&amp;sc_ks_para=q=A%203-dimensional%20sift%20descriptor%20and%20its%20application%20to%20action%20recognition&amp;tn=SE_baiduxueshu_c1gjeupa&amp;ie=utf-8&amp;sc_us=5087117483461663566" target="_blank" rel="external">Paul Scovanner, Saad Ali, and Mubarak Shah. A 3-dimensional sift descriptor and its application to action recognition. In Proceedings of the 15th ACM international conference on Multimedia, pages 357–360. ACM, 2007. </a>《一种三维SIFT描述子及其在动作识别中的应用》</p><blockquote><p>摘要<br>在本文中，我们引入一个3维SIFT用于视频或3D图像（如MRI数据）的描述符。 我们还展示了这种新的描述符如何能够更好地表现视频数据在动作识别应用中的3D特性。 本文将展示3D SIFT如何以优雅和高效的方式超越以前使用的描述方法。 我们用一包词的方式来表示视频，并提出一种方法来发现时空词之间的关系，以便更好地描述视频数据。</p></blockquote><p>13 .  <a href="https://www.researchgate.net/publication/260320178_NARF_3D_Range_Image_Features_for_Object_Recognition" target="_blank" rel="external">Bastian Steder, Radu Bogdan Rusu, Kurt Konolige,and Wolfram Burgard. Narf: 3d range image features for object recognition. In Workshop on Deﬁning and Solving Realistic Perception Problems in Personal Robotics at the IEEE/RSJ Int. Conf. on Intelligent Robots and Systems (IROS), volume 44, 2010</a>《物体识别的三维距离图像特征》</p><blockquote><p>摘要<br>我们提出了一个新的方法：对于兴趣点检测和特征描述符计算三维范围数据，我们把它称为NARF（正常对齐径向特征）。 该方法明确地使用了对象边界信息，并试图提取表面稳定但附近有实质性变化的区域的特征。</p></blockquote><p>14 . <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks" target="_blank" rel="external">Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classiﬁcation with deep convolutional neural networks. In Advances in neural information processing systems, pages 1097–1105, 2012</a>《基于深度卷积神经网络的图像分类》<a href="http://blog.csdn.net/motianchi/article/details/50851074" target="_blank" rel="external">『中文翻译』</a></p><blockquote><p>摘要<br>我们训练了一个大型深度卷积神经网络来将ImageNet LSVRC-2010数据集中的120万张高清图片分到1000个不同的类别中。在测试数据中，我们将Top-1错误（分配的第一个类错误）和Top-5错误（分配的前五个类全错）分别降到了37.5%和17.0%，这比之前的技术水平要好得多。这个神经网络拥有6千万的参数和65万个神经元，共有五个卷积层，其中一些卷积层后面跟着最大池化层，还有利用softmax函数进行1000类分类的最后三个全连接层。为了让训练速度更快，我们使用不饱和【？non-saturating】神经元，并利用高效的GPU实现卷积操作。为了减少全连接层的过拟合，我们采用了一种最近研发出来的正则化方法——“DROPOUT”，它被证明十分有效。我们也在比赛中加入了这一模型的一个变体，第二名的26.2%相比，我们通过将TOP-5错误降到了15.3%而获胜。</p></blockquote><p>15.<a href="https://www.nature.com/nature/journal/v521/n7553/full/nature14539.html" target="_blank" rel="external">Yann LeCun, Yoshua Bengio, and Geoffrey Hinton.Deep learning. Nature, 521(7553):436–444, 2015</a>《深度学习》</p><blockquote><p>摘要<br>深度学习允许由多个处理层组成的计算模型来学习具有多个抽象级别的数据表示。 这些方法极大地改进了语音识别，视觉对象识别，对象检测和诸如药物发现和基因组学等许多其他领域的最新技术。 深度学习通过使用反向传播算法来发现大型数据集中复杂的结构，以指示机器应如何改变其内部参数，以用于根据前一层的表示计算每层中的表示。 深卷积网络在处理图像，视频，语音和音频方面取得了突破性进展，而经常性网络则对文本和语音等连续数据指明了方向。</p></blockquote><p>16.<a href="http://www.cs.toronto.edu/~hinton/science.pdf" target="_blank" rel="external">Geoffrey E Hinton and Ruslan R Salakhutdinov. Reducing the dimensionality of data with neural networks. Science, 313(5786):504–507, 2006.</a>《用神经网络降低数据的维数》<a href="https://segmentfault.com/a/1190000007665145" target="_blank" rel="external">中文介绍</a></p><blockquote><p>摘要<br>通过训练具有小中心层的多层神经网络来重建高维输入向量，可将高维数据转换为低维码。 梯度下降可用于微调这种“自动编码器”网络中的权重，但只有在初始权重接近良好的解决方案时，才能正常工作。 我们描述了一个初始化权重的有效方法，允许深度自动编码器网络学习低于主要组件分析的低维代码作为降低数据维度的工具。</p></blockquote><p>17 .  <a href="https://www.researchgate.net/publication/303531275_Registration_of_Airborne_LiDAR_Point_Clouds_by_Matching_the_Linear_Plane_Features_of_Building_Roof_Facets" target="_blank" rel="external">Hangbin Wu and Hongchao Fan. Registration of airborne lidar point clouds by matching the linear plane features of building roof facets. Remote Sensing,8(6):447, 2016.</a>《基于线性平面有限元匹配的机载激光雷达点云配准》</p><blockquote><p>摘要<br>通过寻找和匹配相应的线性面特征，提出了一种新的机载LiDAR点云配准方法。线性平面特征是城市地区的一种常见特征，便于从点云中获取特征参数。利用这些线性特征参数，采用三维刚体协调变换模型，对不同轨迹的点云进行配准。该方法由三个步骤组成。在第一步中，应用OpenStreetMap辅助方法来选择简单结构的屋顶对作为匹配的相应屋顶面。在第二步中，计算所选屋顶小面的法向矢量并将其输入到一个超定的观测系统中，以估计配准参数。在第三步中，使用这些参数进行匹配。选择一个具有两个轨迹点云的案例数据集来验证所提出的方法。为了评估匹配后点云的准确性，手动选择了40个检查点;评估结果表明，一般精度为0.96米，约为点云分辨率的1.6倍。此外，选择两个重叠区域来测量两个轨迹之间的表面差异。根据分析结果，平均表面距离约为0.045-0.129米。</p></blockquote><p>[18] <a href="http://ieeexplore.ieee.org/document/121791/?arnumber=121791&amp;tag=1" target="_blank" rel="external">Paul J Besl and Neil D McKay. Method for registration of 3-d shapes. In Robotics-DL tentative, pages 586–606. International Society for Optics and Photonics, 1992.</a>《三维形状的配准方法 》</p><blockquote><p>摘要<br>作者描述了一种通用的，与表示无关的方法，用于准确计算包括自由曲线和曲面在内的三维形状的高效配准。该方法处理完整的六个自由度，并基于迭代最近点（ICP）算法，该算法仅需要一个过程来找到几何实体上到给定点的最近点。 ICP算法总是单调地收敛到均方距离度量的最近局部最小值，并且在最初的几次迭代期间收敛速度是快速的。因此，对于具有一定“形状复杂度”的特定类别的对象，给定适当的初始旋转和平移集合，可以通过测试每个初始配准来在全部六个自由度上全局最小化均方距离度量。这种方法的一个重要应用是在形状检查之前将来自未固定的刚性物体的感测数据与理想的几何模型进行配准。实验结果显示了配准算法在点集，曲线和曲面上的能力</p></blockquote><p>[19] <a href="http://ieeexplore.ieee.org/abstract/document/924423/" target="_blank" rel="external">Szymon Rusinkiewicz and Marc Levoy. Efﬁcient variants of the icp algorithm. In 3-D Digital Imaging and Modeling, 2001. Proceedings. Third International Conference on, pages 145–152. IEEE, 2001.</a>《ICP算法的有效变种 》</p><blockquote><p>摘要<br>当相对姿态的初始估计已知时，ICP（迭代最近点）算法被广泛用于三维模型的几何对准。 已经提出了ICP的许多变体，从点的选择和匹配到最小化策略影响算法的所有阶段。 我们列举和分类许多这些变体，并评估它们对达到正确对齐的速度的影响。 为了改善具有小特征的近平面网格（如刻写曲面）的收敛性，引入了一个基于法向空间均匀采样的新的变体。 最后，我们提出了针对高速优化的ICP变体的组合。 我们演示一个能够在几十毫秒内对齐两个距离图像的实现，假设一个好的初始猜测。 这种能力可用于实时三维模型采集和基于模型的跟踪。</p></blockquote><p>[20] <a href="http://xueshu.baidu.com/s?wd=paperuri:%28474b882d8a591cde1db98d7ff1f766b3%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1640899&amp;ie=utf-8&amp;sc_us=16791238355415665744" target="_blank" rel="external">Ameesh Makadia, Alexander Patterson, and Kostas Daniilidis.Fully automatic registration of 3d point clouds. In 2006 IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR’06), volume 1, pages 1297–1304. IEEE, 2006.</a>《三维点云的全自动配准》</p><blockquote><p>摘要<br>我们提出了一种三维点云匹配的新技术，这种技术做了很少的假设：我们避免任何手动粗略对齐或使用地标，位移可以任意大，两点集合可以有很少的重叠。 粗对准是通过估计来自两个扩展高斯图像的3D旋转来实现的，即使当引起它们的数据集具有部分重叠时也是如此。该技术基于傅立叶域中两个EGI的相关性，并利用球面和旋转谐波变换。对于具有低重叠的配对而言，不能进行关键的验证步骤，可以通过对齐由EGI生成的星座图像来获得旋转对准。 旋转对齐的组通过使用体积函数的傅里叶变换的相关性来匹配。 在最后一步中，通过只用很少的迭代运行迭代最接近的点来获得精确的对齐。</p></blockquote><p>[21] <a href="https://www.researchgate.net/publication/230991730_The_Density_of_Random_Close_Packing_of_Spheres" target="_blank" rel="external">GD Scott and DM Kilgour. The density of random close packing of spheres. Journal of Physics D: Applied Physics, 2(6):863, 1969.</a>《球体随机密堆积的密度》</p><blockquote><p>摘要<br>随机包装硬球的模型表现出简单液体性质的一些特征，例如， 包装密度和径向分布。 球体的最大填充密度的值可以由模型确定，如果注意确保边界表面的随机堆积和如果对边界处的体积误差进行校正的话。 随机松散密度和随机密集填充密度的实验报告是用有机玻璃，尼龙和钢球在空气中的八分之一，还有浸在油中的钢球。 已经用多达80 000个钢球并借助机械振动器进行了一系列随机密堆积密度的测量。 计算机对结果的分析允许一步，双参数外推到无限量。 如此获得的随机密堆积密度的数字是06366±00005，这表示精度比先前的结果提高了一个数量级。</p></blockquote><p> [22] <a href="http://xueshu.baidu.com/s?wd=paperuri:%28479376c9d4a3d372841ed9b2acbb0f8e%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=FFC68D55B6C24229FF3D33D0891ED180?doi=10.1.1.476.479&amp;rep=rep1&amp;type=pdf&amp;ie=utf-8&amp;sc_us=8907340944497699214" target="_blank" rel="external">Yann LeCun et al. Generalization and network design strategies. Connectionism in perspective, pages 143–155, 1989.</a>《通用化与网络设计策略 》</p><blockquote><p>摘要<br>连接系统的一个有趣的特性是他们从例子中学习的能力。尽管该领域最近的工作集中于减少学习时间，但是学习机的最重要的特征是它的泛化性能。人们通常认为，除非对任务有一些了解，否则就不能实现对现实世界问题的良好泛化性能。反向传播网络通过对网络的体系结构和权重施加约束来提供指定这种知识的方式。一般来说，这样的参数可以看作是参数空间的特定变换。建立一个图像识别的约束网络似乎是一个可行的任务。我们描述了一个小的手写数字识别问题，表明即使问题是线性可分的，单层网络也表现出较差的广义性能。在层次结构中使用移位不变特征检测器时，多层约束网络在此任务上表现得非常好。这些结果证实了最小化网络中的自由参数数量的观点增强了概括性。</p></blockquote><p>[23] <a href="https://www.researchgate.net/publication/222464584_Optimal_Unsupervised_Learning_in_a_Single-Layer_Linear_Feedforward_Neural_Network" target="_blank" rel="external">Terence D Sanger. Optimal unsupervised learning in a single-layer linear feedforward neural network. Neural networks, 2(6):459–473, 1989.</a>《在单层线性前馈神经网络最优的无监督学习 》</p><blockquote><p>摘要<br>讨论了单层线性前向神经网络中无监督学习的一种新方法。提出了一种基于保留输出单元中最大信息的最优性原则。介绍了一种基于Hebbian学习规则的无监督学习算法，实现了理想的最优性。该算法找到了输入相关矩阵的特征向量，证明了其以概率1收敛。描述了仅使用局部“突触”修改规则训练神经网络的实现。结果表明，该算法与统计学（因子分析和主成分分析）和神经网络（自监督反向传播，或“编码器”问题）中的算法密切相关。因此，它提供了对经典统计技术方面的某些神经网络行为的解释。提出了使用线性网络来解决图像编码和纹理分割问题的例子。此外，它表明，该算法可以用来找到“视觉接受领域”在性质上类似于在灵长类视网膜和视觉皮层中发现的。</p></blockquote><p>[24] <a href="https://dl.acm.org/citation.cfm?id=358692" target="_blank" rel="external">Martin A Fischler and Robert C Bolles.Random sample consensus: a paradigm for model ﬁtting with applications to image analysis and automated cartography. Communications of the ACM, 24(6):381–395,1981.</a>《随机样本一致性：模型与应用程序进行图像分析和自动绘图的范例》</p><blockquote><p>摘要<br>介绍了一个新的范例，即随机样本一致性（RANSAC），用于拟合实验数据模型。 RANSAC能够解释/平滑包含大量重大错误的数据，因此非常适合自动图像分析应用，其中解释基于易错特征检测器提供的数据。 本文的一个主要部分描述了RANSAC在位置确定问题（LDP）中的应用：给定描绘具有已知位置的一组地标的图像，确定获得图像的空间点。 为了响应RANSAC的要求，需要获得解决方案所需的最小标记数量的新结果，并给出算法以计算封闭形式的这些最小标志性解决方案。这些结果为在困难的观察和分析条件下能够解决LDP的自动化系统提供了基础。 还介绍了实现细节和计算示例。</p></blockquote><p>[25] <a href="http://xueshu.baidu.com/s?wd=paperuri:%282db80d9a80bd71417232d7c26c888f97%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http://dl.acm.org/citation.cfm?id=1409079&amp;ie=utf-8&amp;sc_us=1406914190655001141" target="_blank" rel="external">Kun Zhou, Qiming Hou, Rui Wang, and Baining Guo.Real-time kd-tree construction on graphics hardware.ACM Transactions on Graphics (TOG), 27(5):126,2008.</a>《基于图形硬件的实时KD树构造 》</p><blockquote><p>摘要<br>我们提出了一个在GPU上构建kd-tree的算法。该算法通过在kd树构造的各个阶段利用GPU的流式架构来实现实时性能。与以前的并行kd-tree算法不同，我们的方法完全以BFS（广度优先搜索）顺序构建树节点。我们还针对上级树的大型节点制定了一个特殊策略，以进一步利用GPU的细粒度并行性。对于这些节点，我们并行化所有几何基元的计算，而不是每个层次上的节点。最后，为了保持kd树质量，我们引入了新的方案来快速评估节点分裂成本。</p><p>据我们所知，我们是GPU上的第一个实时kd-tree算法。我们的算法构建的kd树与离线CPU算法构建的kd树质量相当。就速度而言，我们的算法明显快于优化的单核CPU算法，并且与多核CPU算法相比具有竞争性。我们的算法提供了处理GPU上动态场景的一般方法。我们证明了我们的算法在涉及动态场景的应用中的潜力，包括GPU射线追踪，交互式光子映射和点云建模。</p></blockquote><p>[26] <a href="http://xueshu.baidu.com/s?wd=paperuri:%283ce333febdb3c15020256f7c740c1c7b%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http://ieeexplore.ieee.org/document/6462927/&amp;ie=utf-8&amp;sc_us=3781435091169552354" target="_blank" rel="external">Donghwa Lee, Hyongjin Kim, and Hyun Myung.Gpu-based real-time rgb-d 3d slam. In Ubiquitous Robots and Ambient Intelligence (URAI), 2012 9th International Conference on, pages 46–48. IEEE, 2012.</a>《基于GPU的实时深度3D SLAM》</p><blockquote><p>摘要<br>本文提出了一种基于GPU（图形处理单元）的实时RGB-D（红 - 绿 - 蓝）深度的三维SLAM（同时定位和映射）系统。 RGB-D数据包含二维图像和每像素深度信息。 首先，通过具有图像特征的3D-RANSAC（三维随机采样共识）算法获得6自由度视觉测距。 而投影ICP（迭代最近点）算法给出了具有深度信息的精确的测距估计结果。 为了加速提取特征和ICP计算，执行基于GPU的并行计算。 在检测到闭环后，基于图的SLAM算法优化了传感器的轨迹和三维图。</p></blockquote><p>[27] <a href="https://www.researchgate.net/publication/221410064_GPU-Accelerated_Nearest_Neighbor_Search_for_3D_Registration" target="_blank" rel="external">Deyuan Qiu, Stefan May, and Andreas Nüchter.Gpu-accelerated nearest neighbor search for 3d registration.In International Conference on Computer Vision Systems, pages 194–203. Springer, 2009.</a>《GPU加速最近邻三维搜索 》</p><blockquote><p>摘要<br>最近邻搜索（NnS）被许多计算机视觉算法所采用。 计算复杂度很大，对实时性能构成挑战。 基本的问题是快速处理大量的数据，这通常是通过高度复杂的搜索方法和并行处理来解决的。 我们展示了像迭代最近点算法（ICP）那样的基于NNS的视觉算法可以实现实时能力，同时保持紧凑的尺寸和适中的能量消耗，因为它在机器人和许多其他领域中是需要的。 该方法利用图形处理单元（GPGPU）上的通用计算概念，并与CPU上的并行处理进行比较。 我们将这种方法应用于三维扫描注册问题，与顺序CPU实现相比，加速因子为88。</p></blockquote><p>[28] <a href="http://xueshu.baidu.com/s?wd=paperuri:%28d1cecbd6c9b21c9caf0355aebfa848db%29&amp;filter=sc_long_sign&amp;sc_ks_para=q=Challenging%20data%20sets%20for%20point%20cloud%20registration%20algorithms&amp;tn=SE_baiduxueshu_c1gjeupa&amp;ie=utf-8&amp;sc_us=6333769492514580415" target="_blank" rel="external">François Pomerleau, Ming Liu, Francis Colas, and Roland Siegwart. Challenging data sets for point cloud registration algorithms. The International Journal of Robotics Research, 31(14):1705–1711, 2012.</a>《用于点云配准算法的具有挑战性的数据集 》</p><blockquote><p>摘要<br>最近文献中匹配方案的数量已经开始出现。例如，迭代的最近点可以被认为是许多基于激光的定位和测绘系统的骨干。虽然它们被广泛使用，但在公平的基础上比较匹配解决方案是一个常见的挑战。主要限制是克服当前数据集中缺乏准确的基本事实，这些数据集通常涵盖仅在一个小范围的组织级别的环境。在计算机视觉领域，斯坦福三维扫描库通过提供高质量的扫描对象和精确定位，推动了点云配准算法和对象建模领域。我们的目标是为机器人和计算机视觉社区提供类似的高质量工作材料，但是以风景而不是物体。我们提出在现代机器人容易遇到的覆盖环境多样性的地点采集八个点云序列，从公寓内部到林地区域。数据集的核心由三维激光点云组成，每个姿态都提供支持数据（重力，磁北和GPS）。为了确保扫描仪的全球定位精度在毫米范围内，不受环境条件的影响，我们做了特别的努力。这将允许在映射具有挑战性的环境（例如在现实世界中发现的环境）时改进匹配算法的开发</p></blockquote><p>[29] <a href="http://ieeexplore.ieee.org/document/7789576/" target="_blank" rel="external">Yanxin Ma, Yulan Guo, Jian Zhao, Min Lu, Jun Zhang, and Jianwei Wan. Fast and accurate registration of structured point clouds with small overlaps.</a>《小重叠结构点云的快速准确配准 》</p><blockquote><p>摘要<br>为了进行大旋转，小重叠的结构化点云的配准，本文提出了一种基于密集点的方向角和投影信息的算法。 该算法充分利用了结构化环境的几何信息。 它由两部分组成：旋转估计和翻译估计。 对于旋转估计，为点云定义方向角，然后通过比较角度分布之间的差异来获得旋转矩阵。 对于平移估计，将点云投影到三个正交平面上，然后对投影图像执行相关运算以计算平移矢量。 已经对几个数据集进行了实验。 实验结果表明，该算法在精度和效率两方面都优于现有技术。</p></blockquote><p>[30] Elbit Systems Ltd. </p><blockquote><p>Elbit系统有限公司 是一家总部位于以色列的国际防务电子公司</p></blockquote><p>[^footnote].<br>  [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.researchgate.net/publication/316455393_3D_Point_Cloud_Registration_for_Localization_Using_a_Deep_Neural_Network_Auto
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>c++笔记：（5）:C++ 重载运算符和重载函数</title>
    <link href="http://yoursite.com/2017/11/13/c++%E7%AC%94%E8%AE%B0/c++%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%885%EF%BC%89C++%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/11/13/c++笔记/c++笔记：（5）C++ 重载运算符和重载函数/</id>
    <published>2017-11-13T13:11:58.000Z</published>
    <updated>2021-02-19T13:32:12.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-重载运算符和重载函数"><a href="#C-重载运算符和重载函数" class="headerlink" title="C++ 重载运算符和重载函数"></a>C++ 重载运算符和重载函数</h2><p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p><p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p><p>当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。</p><h2 id="C-中的函数重载"><a href="#C-中的函数重载" class="headerlink" title="C++ 中的函数重载"></a>C++ 中的函数重载</h2><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。</p><p>下面的实例中，同名函数 print() 被用于输出不同的数据类型：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class printData </div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      void print(int i) &#123;</div><div class="line">        cout &lt;&lt; &quot;Printing int: &quot; &lt;&lt; i &lt;&lt; endl;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">      void print(double  f) &#123;</div><div class="line">        cout &lt;&lt; &quot;Printing float: &quot; &lt;&lt; f &lt;&lt; endl;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">      void print(char* c) &#123;</div><div class="line">        cout &lt;&lt; &quot;Printing character: &quot; &lt;&lt; c &lt;&lt; endl;</div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">   printData pd;</div><div class="line"> </div><div class="line">   // Call print to print integer</div><div class="line">   pd.print(5);</div><div class="line">   // Call print to print float</div><div class="line">   pd.print(500.263);</div><div class="line">   // Call print to print character</div><div class="line">   pd.print(&quot;Hello C++&quot;);</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Printing int: 5</div><div class="line">Printing float: 500.263</div><div class="line">Printing character: Hello C++</div></pre></td></tr></table></figure></p><h2 id="C-中的运算符重载"><a href="#C-中的运算符重载" class="headerlink" title="C++ 中的运算符重载"></a>C++ 中的运算符重载</h2><p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Box operator+(const Box&amp;);</div></pre></td></tr></table></figure></p><p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为<strong>普通的非成员函数</strong>或者被定义为<strong>类成员函数</strong>。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Box operator+(const Box&amp;, const Box&amp;);</div></pre></td></tr></table></figure></p><p>下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line"> </div><div class="line">      double getVolume(void)</div><div class="line">      &#123;</div><div class="line">         return length * breadth * height;</div><div class="line">      &#125;</div><div class="line">      void setLength( double len )</div><div class="line">      &#123;</div><div class="line">          length = len;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">      void setBreadth( double bre )</div><div class="line">      &#123;</div><div class="line">          breadth = bre;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">      void setHeight( double hei )</div><div class="line">      &#123;</div><div class="line">          height = hei;</div><div class="line">      &#125;</div><div class="line">      // 重载 + 运算符，用于把两个 Box 对象相加</div><div class="line">      Box operator+(const Box&amp; b)</div><div class="line">      &#123;</div><div class="line">         Box box;</div><div class="line">         box.length = this-&gt;length + b.length;</div><div class="line">         box.breadth = this-&gt;breadth + b.breadth;</div><div class="line">         box.height = this-&gt;height + b.height;</div><div class="line">         return box;</div><div class="line">      &#125;</div><div class="line">   private:</div><div class="line">      double length;      // 长度</div><div class="line">      double breadth;     // 宽度</div><div class="line">      double height;      // 高度</div><div class="line">&#125;;</div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Box Box1;                // 声明 Box1，类型为 Box</div><div class="line">   Box Box2;                // 声明 Box2，类型为 Box</div><div class="line">   Box Box3;                // 声明 Box3，类型为 Box</div><div class="line">   double volume = 0.0;     // 把体积存储在该变量中</div><div class="line"> </div><div class="line">   // Box1 详述</div><div class="line">   Box1.setLength(6.0); </div><div class="line">   Box1.setBreadth(7.0); </div><div class="line">   Box1.setHeight(5.0);</div><div class="line"> </div><div class="line">   // Box2 详述</div><div class="line">   Box2.setLength(12.0); </div><div class="line">   Box2.setBreadth(13.0); </div><div class="line">   Box2.setHeight(10.0);</div><div class="line"> </div><div class="line">   // Box1 的体积</div><div class="line">   volume = Box1.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Volume of Box1 : &quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line"> </div><div class="line">   // Box2 的体积</div><div class="line">   volume = Box2.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Volume of Box2 : &quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line"> </div><div class="line">   // 把两个对象相加，得到 Box3</div><div class="line">   Box3 = Box1 + Box2;</div><div class="line"> </div><div class="line">   // Box3 的体积</div><div class="line">   volume = Box3.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Volume of Box3 : &quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Volume of Box1 : 210</div><div class="line">Volume of Box2 : 1560</div><div class="line">Volume of Box3 : 5400</div></pre></td></tr></table></figure></p><h2 id="可重载运算符-不可重载运算符"><a href="#可重载运算符-不可重载运算符" class="headerlink" title="可重载运算符/不可重载运算符"></a>可重载运算符/不可重载运算符</h2><p>下面是可重载的运算符列表：<br>|双目算术运算符     |+ (加)，-(减)，<em>(乘)，/(除)，% (取模)|<br>|—|—|<br>|关系运算符     |==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)|<br>|逻辑运算符     |||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)|<br>|单目运算符     |+ (正)，-(负)，</em>(指针)，&amp;(取地址)|<br>|自增自减运算符     |++(自增)，–(自减)|<br>|位运算符 |    | (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)|<br>|赋值运算符|     =, +=, -=, <em>=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=|<br>|空间申请与释放     |new, delete, new[ ] , delete[]|<br>|其他运算符 |    ()(函数调用)，-&gt;(成员访问)，-&gt;</em>(成员指针访问)，,(逗号)，[](下标)|</p><p>下面是不可重载的运算符列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.：成员访问运算符</div><div class="line">.*, -&gt;*：成员指针访问运算符</div><div class="line">::：域运算符</div><div class="line">sizeof：长度运算符</div><div class="line">?:：条件运算符</div><div class="line">#： 预处理符号</div></pre></td></tr></table></figure></p><h2 id="运算符重载实例"><a href="#运算符重载实例" class="headerlink" title="运算符重载实例"></a>运算符重载实例</h2><p>下面提供了各种运算符重载的实例，帮助您更好地理解重载的概念。<br>序号    运算符和实例</p><blockquote><p>1    一元运算符重载<br>2    二元运算符重载<br>3    关系运算符重载<br>4    输入/输出运算符重载<br>5    ++ 和 – 运算符重载<br>6    赋值运算符重载<br>7    函数调用运算符 () 重载<br>8    下标运算符 [] 重载<br>9    类成员访问运算符 -&gt; 重载</p></blockquote><h3 id="1-C-一元运算符重载"><a href="#1-C-一元运算符重载" class="headerlink" title="1.C++ 一元运算符重载"></a>1.C++ 一元运算符重载</h3><p>一元运算符只对一个操作数进行操作，下面是一元运算符的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">递增运算符（ ++ ）和递减运算符（ -- ）</div><div class="line">一元减运算符，即负号（ - ）</div><div class="line">逻辑非运算符（ ! ）</div></pre></td></tr></table></figure></p><p>一元运算符通常出现在它们所操作的对象的左边，比如 <code>!obj</code>、<code>-obj</code> 和<code>++obj</code>，但有时它们也可以作为后缀，比如 <code>obj++</code> 或<code>obj--</code>。</p><p>下面的实例演示了如何重载一元减运算符（ - ）。<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Distance</div><div class="line">&#123;</div><div class="line">   private:</div><div class="line">      int feet;             // 0 到无穷</div><div class="line">      int inches;           // 0 到 12</div><div class="line">   public:</div><div class="line">      // 所需的构造函数</div><div class="line">      Distance()&#123;</div><div class="line">         feet = 0;</div><div class="line">         inches = 0;</div><div class="line">      &#125;</div><div class="line">      Distance(int f, int i)&#123;</div><div class="line">         feet = f;</div><div class="line">         inches = i;</div><div class="line">      &#125;</div><div class="line">      // 显示距离的方法</div><div class="line">      void displayDistance()</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt; &quot;F: &quot; &lt;&lt; feet &lt;&lt; &quot; I:&quot; &lt;&lt; inches &lt;&lt;endl;</div><div class="line">      &#125;</div><div class="line">      // 重载负运算符（ - ）</div><div class="line">      Distance operator- ()  </div><div class="line">      &#123;</div><div class="line">         feet = -feet;</div><div class="line">         inches = -inches;</div><div class="line">         return Distance(feet, inches);</div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   Distance D1(11, 10), D2(-5, 11);</div><div class="line"> </div><div class="line">   -D1;                     // 取相反数</div><div class="line">   D1.displayDistance();    // 距离 D1</div><div class="line"> </div><div class="line">   -D2;                     // 取相反数</div><div class="line">   D2.displayDistance();    // 距离 D2</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">F: -11 I:-10</div><div class="line">F: 5 I:-11</div></pre></td></tr></table></figure></p><h3 id="2-C-二元运算符重载"><a href="#2-C-二元运算符重载" class="headerlink" title="2.C++ 二元运算符重载"></a>2.C++ 二元运算符重载</h3><p>二元运算符需要两个参数，下面是二元运算符的实例。我们平常使用的加运算符（ + ）、减运算符（ - ）、乘运算符（ * ）和除运算符（ / ）都属于二元运算符。就像加(+)运算符。</p><p>下面的实例演示了如何重载加运算符（ + ）。类似地，您也可以尝试重载减运算符（ - ）和除运算符（ / ）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   double length;      // 长度</div><div class="line">   double breadth;     // 宽度</div><div class="line">   double height;      // 高度</div><div class="line">public:</div><div class="line"> </div><div class="line">   double getVolume(void)</div><div class="line">   &#123;</div><div class="line">      return length * breadth * height;</div><div class="line">   &#125;</div><div class="line">   void setLength( double len )</div><div class="line">   &#123;</div><div class="line">       length = len;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   void setBreadth( double bre )</div><div class="line">   &#123;</div><div class="line">       breadth = bre;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   void setHeight( double hei )</div><div class="line">   &#123;</div><div class="line">       height = hei;</div><div class="line">   &#125;</div><div class="line">   // 重载 + 运算符，用于把两个 Box 对象相加</div><div class="line">   Box operator+(const Box&amp; b)</div><div class="line">   &#123;</div><div class="line">      Box box;</div><div class="line">      box.length = this-&gt;length + b.length;</div><div class="line">      box.breadth = this-&gt;breadth + b.breadth;</div><div class="line">      box.height = this-&gt;height + b.height;</div><div class="line">      return box;</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Box Box1;                // 声明 Box1，类型为 Box</div><div class="line">   Box Box2;                // 声明 Box2，类型为 Box</div><div class="line">   Box Box3;                // 声明 Box3，类型为 Box</div><div class="line">   double volume = 0.0;     // 把体积存储在该变量中</div><div class="line"> </div><div class="line">   // Box1 详述</div><div class="line">   Box1.setLength(6.0); </div><div class="line">   Box1.setBreadth(7.0); </div><div class="line">   Box1.setHeight(5.0);</div><div class="line"> </div><div class="line">   // Box2 详述</div><div class="line">   Box2.setLength(12.0); </div><div class="line">   Box2.setBreadth(13.0); </div><div class="line">   Box2.setHeight(10.0);</div><div class="line"> </div><div class="line">   // Box1 的体积</div><div class="line">   volume = Box1.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Volume of Box1 : &quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line"> </div><div class="line">   // Box2 的体积</div><div class="line">   volume = Box2.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Volume of Box2 : &quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line"> </div><div class="line">   // 把两个对象相加，得到 Box3</div><div class="line">   Box3 = Box1 + Box2;</div><div class="line"> </div><div class="line">   // Box3 的体积</div><div class="line">   volume = Box3.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Volume of Box3 : &quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Volume of Box1 : 210</div><div class="line">Volume of Box2 : 1560</div><div class="line">Volume of Box3 : 5400</div></pre></td></tr></table></figure></p><h3 id="3-C-关系运算符重载"><a href="#3-C-关系运算符重载" class="headerlink" title="3.C++ 关系运算符重载"></a>3.C++ 关系运算符重载</h3><p>C++ 语言支持各种关系运算符<code>（ &lt; 、 &gt; 、 &lt;= 、 &gt;= 、 == 等等）</code>，它们可用于比较 C++ 内置的数据类型。</p><p>您可以重载任何一个关系运算符，重载后的关系运算符可用于比较类的对象。</p><p>下面的实例演示了如何重载 &lt; 运算符，类似地，您也可以尝试重载其他的关系运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Distance</div><div class="line">&#123;</div><div class="line">   private:</div><div class="line">      int feet;             // 0 到无穷</div><div class="line">      int inches;           // 0 到 12</div><div class="line">   public:</div><div class="line">      // 所需的构造函数</div><div class="line">      Distance()&#123;</div><div class="line">         feet = 0;</div><div class="line">         inches = 0;</div><div class="line">      &#125;</div><div class="line">      Distance(int f, int i)&#123;</div><div class="line">         feet = f;</div><div class="line">         inches = i;</div><div class="line">      &#125;</div><div class="line">      // 显示距离的方法</div><div class="line">      void displayDistance()</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt; &quot;F: &quot; &lt;&lt; feet &lt;&lt; &quot; I:&quot; &lt;&lt; inches &lt;&lt;endl;</div><div class="line">      &#125;</div><div class="line">      // 重载负运算符（ - ）</div><div class="line">      Distance operator- ()  </div><div class="line">      &#123;</div><div class="line">         feet = -feet;</div><div class="line">         inches = -inches;</div><div class="line">         return Distance(feet, inches);</div><div class="line">      &#125;</div><div class="line">      // 重载小于运算符（ &lt; ）</div><div class="line">      bool operator &lt;(const Distance&amp; d)</div><div class="line">      &#123;</div><div class="line">         if(feet &lt; d.feet)</div><div class="line">         &#123;</div><div class="line">            return true;</div><div class="line">         &#125;</div><div class="line">         if(feet == d.feet &amp;&amp; inches &lt; d.inches)</div><div class="line">         &#123;</div><div class="line">            return true;</div><div class="line">         &#125;</div><div class="line">         return false;</div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   Distance D1(11, 10), D2(5, 11);</div><div class="line"> </div><div class="line">   if( D1 &lt; D2 )</div><div class="line">   &#123;</div><div class="line">      cout &lt;&lt; &quot;D1 is less than D2 &quot; &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line">   else</div><div class="line">   &#123;</div><div class="line">      cout &lt;&lt; &quot;D2 is less than D1 &quot; &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D2 is less than D1</div></pre></td></tr></table></figure></p><h3 id="4-C-输入-输出运算符重载"><a href="#4-C-输入-输出运算符重载" class="headerlink" title="4.C++ 输入/输出运算符重载"></a>4.C++ 输入/输出运算符重载</h3><p>C++ 能够使用流提取运算符 <code>&gt;&gt;</code> 和流插入运算符 <code>&lt;&lt;</code> 来输入和输出内置的数据类型。您可以重载流提取运算符和流插入运算符来操作对象等用户自定义的数据类型。</p><p>在这里，有一点很重要，我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。</p><p>下面的实例演示了如何重载提取运算符 <code>&gt;&gt;</code> 和插入运算符 <code>&lt;&lt;</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Distance</div><div class="line">&#123;</div><div class="line">   private:</div><div class="line">      int feet;             // 0 到无穷</div><div class="line">      int inches;           // 0 到 12</div><div class="line">   public:</div><div class="line">      // 所需的构造函数</div><div class="line">      Distance()&#123;</div><div class="line">         feet = 0;</div><div class="line">         inches = 0;</div><div class="line">      &#125;</div><div class="line">      Distance(int f, int i)&#123;</div><div class="line">         feet = f;</div><div class="line">         inches = i;</div><div class="line">      &#125;</div><div class="line">      friend ostream &amp;operator&lt;&lt;( ostream &amp;output, </div><div class="line">                                       const Distance &amp;D )</div><div class="line">      &#123; </div><div class="line">         output &lt;&lt; &quot;F : &quot; &lt;&lt; D.feet &lt;&lt; &quot; I : &quot; &lt;&lt; D.inches;</div><div class="line">         return output;            </div><div class="line">      &#125;</div><div class="line"></div><div class="line">      friend istream &amp;operator&gt;&gt;( istream  &amp;input, Distance &amp;D )</div><div class="line">      &#123; </div><div class="line">         input &gt;&gt; D.feet &gt;&gt; D.inches;</div><div class="line">         return input;            </div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   Distance D1(11, 10), D2(5, 11), D3;</div><div class="line"></div><div class="line">   cout &lt;&lt; &quot;Enter the value of object : &quot; &lt;&lt; endl;</div><div class="line">   cin &gt;&gt; D3;</div><div class="line">   cout &lt;&lt; &quot;First Distance : &quot; &lt;&lt; D1 &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;Second Distance :&quot; &lt;&lt; D2 &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;Third Distance :&quot; &lt;&lt; D3 &lt;&lt; endl;</div><div class="line"></div><div class="line"></div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$./a.out</div><div class="line">Enter the value of object :</div><div class="line">70</div><div class="line">10</div><div class="line">First Distance : F : 11 I : 10</div><div class="line">Second Distance :F : 5 I : 11</div><div class="line">Third Distance :F : 70 I : 10</div></pre></td></tr></table></figure></p><h3 id="5-C-和-–-运算符重载"><a href="#5-C-和-–-运算符重载" class="headerlink" title="5.C++ ++ 和 – 运算符重载"></a>5.C++ ++ 和 – 运算符重载</h3><p>递增运算符（ ++ ）和递减运算符（ – ）是 C++ 语言中两个重要的一元运算符。</p><p>下面的实例演示了如何重载递增运算符（ ++ ），包括前缀和后缀两种用法。类似地，您也可以尝试重载递减运算符（ - - ）。<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Time</div><div class="line">&#123;</div><div class="line">   private:</div><div class="line">      int hours;             // 0 到 23</div><div class="line">      int minutes;           // 0 到 59</div><div class="line">   public:</div><div class="line">      // 所需的构造函数</div><div class="line">      Time()&#123;</div><div class="line">         hours = 0;</div><div class="line">         minutes = 0;</div><div class="line">      &#125;</div><div class="line">      Time(int h, int m)&#123;</div><div class="line">         hours = h;</div><div class="line">         minutes = m;</div><div class="line">      &#125;</div><div class="line">      // 显示时间的方法</div><div class="line">      void displayTime()</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt; &quot;H: &quot; &lt;&lt; hours &lt;&lt; &quot; M:&quot; &lt;&lt; minutes &lt;&lt;endl;</div><div class="line">      &#125;</div><div class="line">      // 重载前缀递增运算符（ ++ ）</div><div class="line">      Time operator++ ()  </div><div class="line">      &#123;</div><div class="line">         ++minutes;          // 对象加 1</div><div class="line">         if(minutes &gt;= 60)  </div><div class="line">         &#123;</div><div class="line">            ++hours;</div><div class="line">            minutes -= 60;</div><div class="line">         &#125;</div><div class="line">         return Time(hours, minutes);</div><div class="line">      &#125;</div><div class="line">      // 重载后缀递增运算符（ ++ ）</div><div class="line">      Time operator++( int )         </div><div class="line">      &#123;</div><div class="line">         // 保存原始值</div><div class="line">         Time T(hours, minutes);</div><div class="line">         // 对象加 1</div><div class="line">         ++minutes;                    </div><div class="line">         if(minutes &gt;= 60)</div><div class="line">         &#123;</div><div class="line">            ++hours;</div><div class="line">            minutes -= 60;</div><div class="line">         &#125;</div><div class="line">         // 返回旧的原始值</div><div class="line">         return T; </div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   Time T1(11, 59), T2(10,40);</div><div class="line"> </div><div class="line">   ++T1;                    // T1 加 1</div><div class="line">   T1.displayTime();        // 显示 T1</div><div class="line">   ++T1;                    // T1 再加 1</div><div class="line">   T1.displayTime();        // 显示 T1</div><div class="line"> </div><div class="line">   T2++;                    // T2 加 1</div><div class="line">   T2.displayTime();        // 显示 T2</div><div class="line">   T2++;                    // T2 再加 1</div><div class="line">   T2.displayTime();        // 显示 T2</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">H: 12 M:0</div><div class="line">H: 12 M:1</div><div class="line">H: 10 M:41</div><div class="line">H: 10 M:42</div></pre></td></tr></table></figure></p><h3 id="6-C-赋值运算符重载"><a href="#6-C-赋值运算符重载" class="headerlink" title="6.C++ 赋值运算符重载"></a>6.C++ 赋值运算符重载</h3><p>就像其他运算符一样，您可以重载赋值运算符（ = ），用于创建一个对象，比如拷贝构造函数。</p><p>下面的实例演示了如何重载赋值运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Distance</div><div class="line">&#123;</div><div class="line">   private:</div><div class="line">      int feet;             // 0 到无穷</div><div class="line">      int inches;           // 0 到 12</div><div class="line">   public:</div><div class="line">      // 所需的构造函数</div><div class="line">      Distance()&#123;</div><div class="line">         feet = 0;</div><div class="line">         inches = 0;</div><div class="line">      &#125;</div><div class="line">      Distance(int f, int i)&#123;</div><div class="line">         feet = f;</div><div class="line">         inches = i;</div><div class="line">      &#125;</div><div class="line">      void operator=(const Distance &amp;D )</div><div class="line">      &#123; </div><div class="line">         feet = D.feet;</div><div class="line">         inches = D.inches;</div><div class="line">      &#125;</div><div class="line">      // 显示距离的方法</div><div class="line">      void displayDistance()</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt; &quot;F: &quot; &lt;&lt; feet &lt;&lt;  &quot; I:&quot; &lt;&lt;  inches &lt;&lt; endl;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   Distance D1(11, 10), D2(5, 11);</div><div class="line"></div><div class="line">   cout &lt;&lt; &quot;First Distance : &quot;; </div><div class="line">   D1.displayDistance();</div><div class="line">   cout &lt;&lt; &quot;Second Distance :&quot;; </div><div class="line">   D2.displayDistance();</div><div class="line"></div><div class="line">   // 使用赋值运算符</div><div class="line">   D1 = D2;</div><div class="line">   cout &lt;&lt; &quot;First Distance :&quot;; </div><div class="line">   D1.displayDistance();</div><div class="line"></div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">First Distance : F: 11 I:10</div><div class="line">Second Distance :F: 5 I:11</div><div class="line">First Distance :F: 5 I:11</div></pre></td></tr></table></figure></p><h3 id="7-C-函数调用运算符-重载"><a href="#7-C-函数调用运算符-重载" class="headerlink" title="7.C++ 函数调用运算符 () 重载"></a>7.C++ 函数调用运算符 () 重载</h3><p>函数调用运算符 () 可以被重载用于类的对象。当重载 () 时，您不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数。</p><p>下面的实例演示了如何重载函数调用运算符 ()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Distance</div><div class="line">&#123;</div><div class="line">   private:</div><div class="line">      int feet;             // 0 到无穷</div><div class="line">      int inches;           // 0 到 12</div><div class="line">   public:</div><div class="line">      // 所需的构造函数</div><div class="line">      Distance()&#123;</div><div class="line">         feet = 0;</div><div class="line">         inches = 0;</div><div class="line">      &#125;</div><div class="line">      Distance(int f, int i)&#123;</div><div class="line">         feet = f;</div><div class="line">         inches = i;</div><div class="line">      &#125;</div><div class="line">      // 重载函数调用运算符</div><div class="line">      Distance operator()(int a, int b, int c)</div><div class="line">      &#123;</div><div class="line">         Distance D;</div><div class="line">         // 进行随机计算</div><div class="line">         D.feet = a + c + 10;</div><div class="line">         D.inches = b + c + 100 ;</div><div class="line">         return D;</div><div class="line">      &#125;</div><div class="line">      // 显示距离的方法</div><div class="line">      void displayDistance()</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt; &quot;F: &quot; &lt;&lt; feet &lt;&lt;  &quot; I:&quot; &lt;&lt;  inches &lt;&lt; endl;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   Distance D1(11, 10), D2;</div><div class="line"></div><div class="line">   cout &lt;&lt; &quot;First Distance : &quot;; </div><div class="line">   D1.displayDistance();</div><div class="line"></div><div class="line">   D2 = D1(10, 10, 10); // invoke operator()</div><div class="line">   cout &lt;&lt; &quot;Second Distance :&quot;; </div><div class="line">   D2.displayDistance();</div><div class="line"></div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">First Distance : F: 11 I:10</div><div class="line">Second Distance :F: 30 I:120</div></pre></td></tr></table></figure></p><h3 id="8-C-下标运算符-重载"><a href="#8-C-下标运算符-重载" class="headerlink" title="8.C++ 下标运算符 [] 重载"></a>8.C++ 下标运算符 [] 重载</h3><p>下标操作符 [] 通常用于访问数组元素。重载该运算符用于增强操作 C++ 数组的功能。</p><p>下面的实例演示了如何重载下标运算符 []。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">const int SIZE = 10;</div><div class="line"></div><div class="line">class safearay</div><div class="line">&#123;</div><div class="line">   private:</div><div class="line">      int arr[SIZE];</div><div class="line">   public:</div><div class="line">      safearay() </div><div class="line">      &#123;</div><div class="line">         register int i;</div><div class="line">         for(i = 0; i &lt; SIZE; i++)</div><div class="line">         &#123;</div><div class="line">           arr[i] = i;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      int&amp; operator[](int i)</div><div class="line">      &#123;</div><div class="line">          if( i &gt; SIZE )</div><div class="line">          &#123;</div><div class="line">              cout &lt;&lt; &quot;索引超过最大值&quot; &lt;&lt;endl; </div><div class="line">              // 返回第一个元素</div><div class="line">              return arr[0];</div><div class="line">          &#125;</div><div class="line">          return arr[i];</div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   safearay A;</div><div class="line"></div><div class="line">   cout &lt;&lt; &quot;A[2] 的值为 : &quot; &lt;&lt; A[2] &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;A[5] 的值为 : &quot; &lt;&lt; A[5]&lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;A[12] 的值为 : &quot; &lt;&lt; A[12]&lt;&lt;endl;</div><div class="line"></div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ g++ -o test test.cpp</div><div class="line">$ ./test </div><div class="line">A[2] 的值为 : 2</div><div class="line">A[5] 的值为 : 5</div><div class="line">A[12] 的值为 : 索引超过最大值</div><div class="line">0</div></pre></td></tr></table></figure></p><h3 id="9-C-类成员访问运算符-gt-重载"><a href="#9-C-类成员访问运算符-gt-重载" class="headerlink" title="9.C++ 类成员访问运算符 -&gt; 重载"></a>9.C++ 类成员访问运算符 -&gt; 重载</h3><p>类成员访问运算符（ -&gt; ）可以被重载，但它较为麻烦。它被定义用于为一个类赋予”指针”行为。运算符 -&gt; 必须是一个成员函数。如果使用了 -&gt; 运算符，返回类型必须是指针或者是类的对象。</p><p>运算符 -&gt; 通常与指针引用运算符 * 结合使用，用于实现”智能指针”的功能。这些指针是行为与正常指针相似的对象，唯一不同的是，当您通过指针访问对象时，它们会执行其他的任务。比如，当指针销毁时，或者当指针指向另一个对象时，会自动删除对象。</p><p>间接引用运算符 -&gt; 可被定义为一个一元后缀运算符。也就是说，给出一个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Ptr&#123;</div><div class="line">   //...</div><div class="line">   X * operator-&gt;();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">类 Ptr 的对象可用于访问类 X 的成员，使用方式与指针的用法十分相似。例如：</div><div class="line"></div><div class="line">void f(Ptr p )</div><div class="line">&#123;</div><div class="line">   p-&gt;m = 10 ; // (p.operator-&gt;())-&gt;m = 10</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>语句<code>p-&gt;m</code>被解释为 <code>(p.operator-&gt;())-&gt;m</code>。同样地，下面的实例演示了如何重载类成员访问运算符 <code>-&gt;</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">// 假设一个实际的类</div><div class="line">class Obj &#123;</div><div class="line">   static int i, j;</div><div class="line">public:</div><div class="line">   void f() const &#123; cout &lt;&lt; i++ &lt;&lt; endl; &#125;</div><div class="line">   void g() const &#123; cout &lt;&lt; j++ &lt;&lt; endl; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 静态成员定义</div><div class="line">int Obj::i = 10;</div><div class="line">int Obj::j = 12;</div><div class="line"></div><div class="line">// 为上面的类实现一个容器</div><div class="line">class ObjContainer &#123;</div><div class="line">   vector&lt;Obj*&gt; a;</div><div class="line">public:</div><div class="line">   void add(Obj* obj)</div><div class="line">   &#123; </div><div class="line">      a.push_back(obj);  // 调用向量的标准方法</div><div class="line">   &#125;</div><div class="line">   friend class SmartPointer;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 实现智能指针，用于访问类 Obj 的成员</div><div class="line">class SmartPointer &#123;</div><div class="line">   ObjContainer oc;</div><div class="line">   int index;</div><div class="line">public:</div><div class="line">   SmartPointer(ObjContainer&amp; objc)</div><div class="line">   &#123; </div><div class="line">       oc = objc;</div><div class="line">       index = 0;</div><div class="line">   &#125;</div><div class="line">   // 返回值表示列表结束</div><div class="line">   bool operator++() // 前缀版本</div><div class="line">   &#123; </div><div class="line">     if(index &gt;= oc.a.size()) return false;</div><div class="line">     if(oc.a[++index] == 0) return false;</div><div class="line">     return true;</div><div class="line">   &#125;</div><div class="line">   bool operator++(int) // 后缀版本</div><div class="line">   &#123; </div><div class="line">      return operator++();</div><div class="line">   &#125;</div><div class="line">   // 重载运算符 -&gt;</div><div class="line">   Obj* operator-&gt;() const </div><div class="line">   &#123;</div><div class="line">     if(!oc.a[index])</div><div class="line">     &#123;</div><div class="line">        cout &lt;&lt; &quot;Zero value&quot;;</div><div class="line">        return (Obj*)0;</div><div class="line">     &#125;</div><div class="line">     return oc.a[index];</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">   const int sz = 10;</div><div class="line">   Obj o[sz];</div><div class="line">   ObjContainer oc;</div><div class="line">   for(int i = 0; i &lt; sz; i++)</div><div class="line">   &#123;</div><div class="line">       oc.add(&amp;o[i]);</div><div class="line">   &#125;</div><div class="line">   SmartPointer sp(oc); // 创建一个迭代器</div><div class="line">   do &#123;</div><div class="line">      sp-&gt;f(); // 智能指针调用</div><div class="line">      sp-&gt;g();</div><div class="line">   &#125; while(sp++);</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">12</div><div class="line">11</div><div class="line">13</div><div class="line">12</div><div class="line">14</div><div class="line">13</div><div class="line">15</div><div class="line">14</div><div class="line">16</div><div class="line">15</div><div class="line">17</div><div class="line">16</div><div class="line">18</div><div class="line">17</div><div class="line">19</div><div class="line">18</div><div class="line">20</div><div class="line">19</div><div class="line">21</div></pre></td></tr></table></figure></p><p>转自：<a href="http://www.runoob.com/cplusplus/cpp-overloading.html" target="_blank" rel="external">C++ 重载运算符和重载函数</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;C-重载运算符和重载函数&quot;&gt;&lt;a href=&quot;#C-重载运算符和重载函数&quot; class=&quot;headerlink&quot; title=&quot;C++ 重载运算符和重载函数&quot;&gt;&lt;/a&gt;C++ 重载运算符和重载函数&lt;/h2&gt;&lt;p&gt;C++ 允许在同一作用域中的某个函数和运算符指定多个
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++笔记：（4）:C++ 继承</title>
    <link href="http://yoursite.com/2017/11/13/c++%E7%AC%94%E8%AE%B0/c++%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%884%EF%BC%89C++%20%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2017/11/13/c++笔记/c++笔记：（4）C++ 继承/</id>
    <published>2017-11-13T13:10:58.000Z</published>
    <updated>2021-02-19T13:32:12.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-继承"><a href="#C-继承" class="headerlink" title="C++ 继承"></a>C++ 继承</h2><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。</p><p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。</p><p>继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。</p><h2 id="基类-amp-派生类"><a href="#基类-amp-派生类" class="headerlink" title="基类 &amp; 派生类"></a>基类 &amp; 派生类</h2><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class derived-class: access-specifier base-class</div></pre></td></tr></table></figure></p><p>其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p><p>假设有一个基类 Shape，Rectangle 是它的派生类，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 基类</div><div class="line">class Shape </div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      void setWidth(int w)</div><div class="line">      &#123;</div><div class="line">         width = w;</div><div class="line">      &#125;</div><div class="line">      void setHeight(int h)</div><div class="line">      &#123;</div><div class="line">         height = h;</div><div class="line">      &#125;</div><div class="line">   protected:</div><div class="line">      int width;</div><div class="line">      int height;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 派生类</div><div class="line">class Rectangle: public Shape</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      int getArea()</div><div class="line">      &#123; </div><div class="line">         return (width * height); </div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">   Rectangle Rect;</div><div class="line"> </div><div class="line">   Rect.setWidth(5);</div><div class="line">   Rect.setHeight(7);</div><div class="line"> </div><div class="line">   // 输出对象的面积</div><div class="line">   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Total area: 35</div></pre></td></tr></table></figure></p><h2 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h2><p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p><p>我们可以根据访问权限总结出不同的访问类型，如下所示：<br>|访问    |public|    protected|    private|<br>|- - -|- - -|- - -|<br>|同一个类|    yes    |yes|    yes|<br>|派生类    |yes    |yes    |no|<br>|外部的类|    yes|    no|    no|</p><p>一个派生类继承了所有的基类方法，但下列情况除外：</p><ul><li>基类的构造函数、析构函数和拷贝构造函数。</li><li>基类的重载运算符。</li><li>基类的友元函数。</li></ul><h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><p>当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p><p>我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则：</p><blockquote><p>   <strong>公有继承（public）</strong>：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</p><p>   <strong>私有继承（private）</strong>：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。</p></blockquote><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p><p>C++ 类可以从多个类继承成员，语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…</div><div class="line">&#123;</div><div class="line">&lt;派生类类体&gt;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 基类 Shape</div><div class="line">class Shape </div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      void setWidth(int w)</div><div class="line">      &#123;</div><div class="line">         width = w;</div><div class="line">      &#125;</div><div class="line">      void setHeight(int h)</div><div class="line">      &#123;</div><div class="line">         height = h;</div><div class="line">      &#125;</div><div class="line">   protected:</div><div class="line">      int width;</div><div class="line">      int height;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 基类 PaintCost</div><div class="line">class PaintCost </div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      int getCost(int area)</div><div class="line">      &#123;</div><div class="line">         return area * 70;</div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 派生类</div><div class="line">class Rectangle: public Shape, public PaintCost</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      int getArea()</div><div class="line">      &#123; </div><div class="line">         return (width * height); </div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">   Rectangle Rect;</div><div class="line">   int area;</div><div class="line"> </div><div class="line">   Rect.setWidth(5);</div><div class="line">   Rect.setHeight(7);</div><div class="line"> </div><div class="line">   area = Rect.getArea();</div><div class="line">   </div><div class="line">   // 输出对象的面积</div><div class="line">   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;</div><div class="line"> </div><div class="line">   // 输出总花费</div><div class="line">   cout &lt;&lt; &quot;Total paint cost: $&quot; &lt;&lt; Rect.getCost(area) &lt;&lt; endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Total area: 35</div><div class="line">Total paint cost: $2450</div></pre></td></tr></table></figure></p><p>转自：<a href="http://www.runoob.com/cplusplus/cpp-inheritance.html" target="_blank" rel="external">c++继承|菜鸟教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;C-继承&quot;&gt;&lt;a href=&quot;#C-继承&quot; class=&quot;headerlink&quot; title=&quot;C++ 继承&quot;&gt;&lt;/a&gt;C++ 继承&lt;/h2&gt;&lt;p&gt;面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++笔记：（3）:C++ 类 &amp; 对象</title>
    <link href="http://yoursite.com/2017/11/13/c++%E7%AC%94%E8%AE%B0/c++%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%883%EF%BC%89C++%20%E7%B1%BB%20&amp;%20%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2017/11/13/c++笔记/c++笔记：（3）C++ 类 &amp; 对象/</id>
    <published>2017-11-13T13:08:58.000Z</published>
    <updated>2021-02-19T13:32:12.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-C-类-amp-对象"><a href="#1-C-类-amp-对象" class="headerlink" title="1.C++ 类 &amp; 对象"></a>1.C++ 类 &amp; 对象</h1><p>C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。</p><p>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。</p><h2 id="C-类定义"><a href="#C-类定义" class="headerlink" title="C++ 类定义"></a>C++ 类定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      double length;   // 盒子的长度</div><div class="line">      double breadth;  // 盒子的宽度</div><div class="line">      double height;   // 盒子的高度</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="定义-C-对象"><a href="#定义-C-对象" class="headerlink" title="定义 C++ 对象"></a>定义 C++ 对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Box Box1;          // 声明 Box1，类型为 Box</div><div class="line">Box Box2;          // 声明 Box2，类型为 Box</div></pre></td></tr></table></figure><h2 id="访问数据成员"><a href="#访问数据成员" class="headerlink" title="访问数据成员"></a>访问数据成员</h2><p>类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。为了更好地理解这些概念，让我们尝试一下下面的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">     public :</div><div class="line">       double length;    //长度</div><div class="line">       double breadth;  //宽度</div><div class="line">       double height;     //高度</div><div class="line">  </div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  Box Box1;     //声明 Box1 ,类型为 Box</div><div class="line">  Box Box2;     //声明 Box2 ,类型为 Box </div><div class="line">  double volume = 0.0;//用于存储体积</div><div class="line">  </div><div class="line">  // Box1 赋值</div><div class="line">  Box1.height = 5.0;</div><div class="line">  Box1.length = 6.0;</div><div class="line">  Box1.breadth = 7.0;</div><div class="line">  </div><div class="line">  //Box2 赋值</div><div class="line">  Box2.height = 10.0;</div><div class="line">  Box2.length = 12.0;</div><div class="line">  Box2.breadth = 13.0;</div><div class="line">  </div><div class="line">  //Box1 的体积</div><div class="line">  volume = Box1.height * Box1.length * Box1.breadth;</div><div class="line">  cout &lt;&lt;  &quot;Box1 的体积：&quot; &lt;&lt; volume &lt;&lt; endl ;</div><div class="line">  </div><div class="line">  //Box2 的体积</div><div class="line">  volume = Box2.height * Box2.length * Box2.breadth;</div><div class="line">  cout &lt;&lt; &quot;Box2 的体积：&quot; &lt;&lt; volume &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">Box1 的体积：<span class="number">210</span></div><div class="line">Box2 的体积：<span class="number">1560</span></div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure></p><h2 id="1-1C-类成员函数"><a href="#1-1C-类成员函数" class="headerlink" title="1.1C++ 类成员函数"></a>1.1C++ 类成员函数</h2><p><code>类的成员函数</code>是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。</p><p>让我们看看之前定义的类 Box，现在我们要使用成员函数来访问类的成员，而不是直接访问这些类的成员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      double length;         // 长度</div><div class="line">      double breadth;        // 宽度</div><div class="line">      double height;         // 高度</div><div class="line">      double getVolume(void);// 返回体积</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>成员函数可以定义在类定义内部，或者单独使用范围解析运算符<code>::</code> 来定义。在类定义中定义的成员函数把函数声明为内联的，即便没有使用 <code>inline</code> 标识符。所以您可以按照如下方式定义 <code>Volume()</code>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      double length;      // 长度</div><div class="line">      double breadth;     // 宽度</div><div class="line">      double height;      // 高度</div><div class="line">   </div><div class="line">      double getVolume(void)</div><div class="line">      &#123;</div><div class="line">         return length * breadth * height;</div><div class="line">      &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>您也可以在类的外部使用范围解析运算符<code>::</code> 定义该函数，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">double Box::getVolume(void)</div><div class="line">&#123;</div><div class="line">    return length * breadth * height;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，需要强调一点，在 <code>::</code> 运算符之前必须使用类名。调用成员函数是在对象上使用点运算符（.），这样它就能操作与该对象相关的数据，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Box myBox;          <span class="comment">// 创建一个对象</span></div><div class="line"></div><div class="line">myBox.getVolume();  <span class="comment">// 调用该对象的成员函数</span></div></pre></td></tr></table></figure></p><p>让我们使用上面提到的概念来设置和获取类中不同的成员的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      double length;         // 长度</div><div class="line">      double breadth;        // 宽度</div><div class="line">      double height;         // 高度</div><div class="line"></div><div class="line">      // 成员函数声明</div><div class="line">      double getVolume(void);</div><div class="line">      void setLength( double len );</div><div class="line">      void setBreadth( double bre );</div><div class="line">      void setHeight( double hei );</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 成员函数定义</div><div class="line">double Box::getVolume(void)</div><div class="line">&#123;</div><div class="line">    return length * breadth * height;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Box::setLength( double len )</div><div class="line">&#123;</div><div class="line">    length = len;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Box::setBreadth( double bre )</div><div class="line">&#123;</div><div class="line">    breadth = bre;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Box::setHeight( double hei )</div><div class="line">&#123;</div><div class="line">    height = hei;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Box Box1;                // 声明 Box1，类型为 Box</div><div class="line">   Box Box2;                // 声明 Box2，类型为 Box</div><div class="line">   double volume = 0.0;     // 用于存储体积</div><div class="line"> </div><div class="line">   // box 1 详述</div><div class="line">   Box1.setLength(6.0); </div><div class="line">   Box1.setBreadth(7.0); </div><div class="line">   Box1.setHeight(5.0);</div><div class="line"></div><div class="line">   // box 2 详述</div><div class="line">   Box2.setLength(12.0); </div><div class="line">   Box2.setBreadth(13.0); </div><div class="line">   Box2.setHeight(10.0);</div><div class="line"></div><div class="line">   // box 1 的体积</div><div class="line">   volume = Box1.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Box1 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line"></div><div class="line">   // box 2 的体积</div><div class="line">   volume = Box2.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Box2 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Box1 的体积： 210</div><div class="line">Box2 的体积： 1560</div></pre></td></tr></table></figure></p><h2 id="1-2C-类访问修饰符"><a href="#1-2C-类访问修饰符" class="headerlink" title="1.2C++ 类访问修饰符"></a>1.2C++ 类访问修饰符</h2><p><strong>数据封装</strong>是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。关键字 public、private、protected 称为<strong>访问修饰符</strong>。</p><p>一个类可以有多个 public、protected 或 private 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。<strong>成员和类的默认访问修饰符是 private。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Base &#123;</div><div class="line"> </div><div class="line">   public:</div><div class="line"> </div><div class="line">  // 公有成员</div><div class="line"> </div><div class="line">   protected:</div><div class="line"> </div><div class="line">  // 受保护成员</div><div class="line"> </div><div class="line">   private:</div><div class="line"> </div><div class="line">  // 私有成员</div><div class="line"> </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h3 id="公有（public）成员"><a href="#公有（public）成员" class="headerlink" title="公有（public）成员"></a>公有（public）成员</h3><p>公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Line</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      double length;</div><div class="line">      void setLength( double len );</div><div class="line">      double getLength( void );</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 成员函数定义</div><div class="line">double Line::getLength(void)</div><div class="line">&#123;</div><div class="line">    return length ;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void Line::setLength( double len )</div><div class="line">&#123;</div><div class="line">    length = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Line line;</div><div class="line"> </div><div class="line">   // 设置长度</div><div class="line">   line.setLength(6.0); </div><div class="line">   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;</div><div class="line"> </div><div class="line">   // 不使用成员函数设置长度</div><div class="line">   line.length = 10.0; // OK: 因为 length 是公有的</div><div class="line">   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.length &lt;&lt;endl;</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Length of line : 6</div><div class="line">Length of line : 10</div></pre></td></tr></table></figure></p><h3 id="私有（private）成员"><a href="#私有（private）成员" class="headerlink" title="私有（private）成员"></a>私有（private）成员</h3><p>私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。</p><p><strong>默认情况下，类的所有成员都是私有的。</strong>例如在下面的类中，width 是一个私有成员，这意味着，如果您没有使用任何访问修饰符，类的成员将被假定为私有成员：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   double width;    //默认情况下，类的所有成员都是私有的。</div><div class="line">   public:</div><div class="line">      double length;</div><div class="line">      void setWidth( double wid );</div><div class="line">      double getWidth( void );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>实际操作中，我们一般会在私有区域定义数据，在公有区域定义相关的函数，以便在类的外部也可以调用这些函数，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      double length;</div><div class="line">      void setWidth( double wid );</div><div class="line">      double getWidth( void );</div><div class="line"> </div><div class="line">   private:</div><div class="line">      double width;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 成员函数定义</div><div class="line">double Box::getWidth(void)</div><div class="line">&#123;</div><div class="line">    return width ;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void Box::setWidth( double wid )</div><div class="line">&#123;</div><div class="line">    width = wid;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Box box;</div><div class="line"> </div><div class="line">   // 不使用成员函数设置长度</div><div class="line">   box.length = 10.0; // OK: 因为 length 是公有的</div><div class="line">   cout &lt;&lt; &quot;Length of box : &quot; &lt;&lt; box.length &lt;&lt;endl;</div><div class="line"> </div><div class="line">   // 不使用成员函数设置宽度</div><div class="line">   // box.width = 10.0; // Error: 因为 width 是私有的</div><div class="line">   box.setWidth(10.0);  // 使用成员函数设置宽度</div><div class="line">   cout &lt;&lt; &quot;Width of box : &quot; &lt;&lt; box.getWidth() &lt;&lt;endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Length of box : 10</div><div class="line">Width of box : 10</div></pre></td></tr></table></figure></p><h3 id="保护（protected）成员"><a href="#保护（protected）成员" class="headerlink" title="保护（protected）成员"></a>保护（protected）成员</h3><p>保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。</p><p>在下一个章节中，您将学习到派生类和继承的知识。现在您可以看到下面的实例中，我们从父类 Box 派生了一个子类 smallBox。</p><p>下面的实例与前面的实例类似，在这里 width 成员可被派生类 smallBox 的任何成员函数访问。<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   protected:</div><div class="line">      double width;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">class SmallBox:Box // SmallBox 是派生类</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      void setSmallWidth( double wid );</div><div class="line">      double getSmallWidth( void );</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 子类的成员函数</div><div class="line">double SmallBox::getSmallWidth(void)</div><div class="line">&#123;</div><div class="line">    return width ;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void SmallBox::setSmallWidth( double wid )</div><div class="line">&#123;</div><div class="line">    width = wid;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   SmallBox box;</div><div class="line"> </div><div class="line">   // 使用成员函数设置宽度</div><div class="line">   box.setSmallWidth(5.0);</div><div class="line">   cout &lt;&lt; &quot;Width of box : &quot;&lt;&lt; box.getSmallWidth() &lt;&lt; endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Width of box : 5</div></pre></td></tr></table></figure></p><h3 id="继承中的特点"><a href="#继承中的特点" class="headerlink" title="继承中的特点"></a>继承中的特点</h3><p>有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。</p><blockquote><p>   1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</p><p>   2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</p><p>   3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</p></blockquote><p>但无论哪种继承方式，上面两点都没有改变：</p><blockquote><p>   1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；</p><p>  2.protected 成员可以被派生类访问。</p></blockquote><h3 id="public-继承"><a href="#public-继承" class="headerlink" title="public 继承"></a>public 继承</h3><p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;assert.h&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class A&#123;</div><div class="line">public:</div><div class="line">  int a;</div><div class="line">  A()&#123;</div><div class="line">    a1 = 1;</div><div class="line">    a2 = 2;</div><div class="line">    a3 = 3;</div><div class="line">    a = 4;</div><div class="line">  &#125;</div><div class="line">  void fun()&#123;</div><div class="line">    cout &lt;&lt; a &lt;&lt; endl;    //正确</div><div class="line">    cout &lt;&lt; a1 &lt;&lt; endl;   //正确</div><div class="line">    cout &lt;&lt; a2 &lt;&lt; endl;   //正确</div><div class="line">    cout &lt;&lt; a3 &lt;&lt; endl;   //正确</div><div class="line">  &#125;</div><div class="line">public:</div><div class="line">  int a1;</div><div class="line">protected:</div><div class="line">  int a2;</div><div class="line">private:</div><div class="line">  int a3;</div><div class="line">&#125;;</div><div class="line">class B : public A&#123;</div><div class="line">public:</div><div class="line">  int a;</div><div class="line">  B(int i)&#123;</div><div class="line">    A();</div><div class="line">    a = i;</div><div class="line">  &#125;</div><div class="line">  void fun()&#123;</div><div class="line">    cout &lt;&lt; a &lt;&lt; endl;       //正确，public成员</div><div class="line">    cout &lt;&lt; a1 &lt;&lt; endl;       //正确，基类的public成员，在派生类中仍是public成员。</div><div class="line">    cout &lt;&lt; a2 &lt;&lt; endl;       //正确，基类的protected成员，在派生类中仍是protected可以被派生类访问。</div><div class="line">    cout &lt;&lt; a3 &lt;&lt; endl;       //错误，基类的private成员不能被派生类访问。</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">int main()&#123;</div><div class="line">  B b(10);</div><div class="line">  cout &lt;&lt; b.a &lt;&lt; endl;</div><div class="line">  cout &lt;&lt; b.a1 &lt;&lt; endl;   //正确</div><div class="line">  cout &lt;&lt; b.a2 &lt;&lt; endl;   //错误，类外不能访问protected成员</div><div class="line">  cout &lt;&lt; b.a3 &lt;&lt; endl;   //错误，类外不能访问private成员</div><div class="line">  system(&quot;pause&quot;);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="protected-继承"><a href="#protected-继承" class="headerlink" title="protected 继承"></a>protected 继承</h3><p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;assert.h&gt;</div><div class="line">using namespace std;</div><div class="line">class A&#123;</div><div class="line">public:</div><div class="line">  int a;</div><div class="line">  A()&#123;</div><div class="line">    a1 = 1;</div><div class="line">    a2 = 2;</div><div class="line">    a3 = 3;</div><div class="line">    a = 4;</div><div class="line">  &#125;</div><div class="line">  void fun()&#123;</div><div class="line">    cout &lt;&lt; a &lt;&lt; endl;    //正确</div><div class="line">    cout &lt;&lt; a1 &lt;&lt; endl;   //正确</div><div class="line">    cout &lt;&lt; a2 &lt;&lt; endl;   //正确</div><div class="line">    cout &lt;&lt; a3 &lt;&lt; endl;   //正确</div><div class="line">  &#125;</div><div class="line">public:</div><div class="line">  int a1;</div><div class="line">protected:</div><div class="line">  int a2;</div><div class="line">private:</div><div class="line">  int a3;</div><div class="line">&#125;;</div><div class="line">class B : protected A&#123;</div><div class="line">public:</div><div class="line">  int a;</div><div class="line">  B(int i)&#123;</div><div class="line">    A();</div><div class="line">    a = i;</div><div class="line">  &#125;</div><div class="line">  void fun()&#123;</div><div class="line">    cout &lt;&lt; a &lt;&lt; endl;       //正确，public成员。</div><div class="line">    cout &lt;&lt; a1 &lt;&lt; endl;       //正确，基类的public成员，在派生类中变成了protected，可以被派生类访问。</div><div class="line">    cout &lt;&lt; a2 &lt;&lt; endl;       //正确，基类的protected成员，在派生类中还是protected，可以被派生类访问。</div><div class="line">    cout &lt;&lt; a3 &lt;&lt; endl;       //错误，基类的private成员不能被派生类访问。</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">int main()&#123;</div><div class="line">  B b(10);</div><div class="line">  cout &lt;&lt; b.a &lt;&lt; endl;       //正确。public成员</div><div class="line">  cout &lt;&lt; b.a1 &lt;&lt; endl;      //错误，protected成员不能在类外访问。</div><div class="line">  cout &lt;&lt; b.a2 &lt;&lt; endl;      //错误，protected成员不能在类外访问。</div><div class="line">  cout &lt;&lt; b.a3 &lt;&lt; endl;      //错误，private成员不能在类外访问。</div><div class="line">  system(&quot;pause&quot;);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="private-继承"><a href="#private-继承" class="headerlink" title="private 继承"></a>private 继承</h3><p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;assert.h&gt;</div><div class="line">using namespace std;</div><div class="line">class A&#123;</div><div class="line">public:</div><div class="line">  int a;</div><div class="line">  A()&#123;</div><div class="line">    a1 = 1;</div><div class="line">    a2 = 2;</div><div class="line">    a3 = 3;</div><div class="line">    a = 4;</div><div class="line">  &#125;</div><div class="line">  void fun()&#123;</div><div class="line">    cout &lt;&lt; a &lt;&lt; endl;    //正确</div><div class="line">    cout &lt;&lt; a1 &lt;&lt; endl;   //正确</div><div class="line">    cout &lt;&lt; a2 &lt;&lt; endl;   //正确</div><div class="line">    cout &lt;&lt; a3 &lt;&lt; endl;   //正确</div><div class="line">  &#125;</div><div class="line">public:</div><div class="line">  int a1;</div><div class="line">protected:</div><div class="line">  int a2;</div><div class="line">private:</div><div class="line">  int a3;</div><div class="line">&#125;;</div><div class="line">class B : private A&#123;</div><div class="line">public:</div><div class="line">  int a;</div><div class="line">  B(int i)&#123;</div><div class="line">    A();</div><div class="line">    a = i;</div><div class="line">  &#125;</div><div class="line">  void fun()&#123;</div><div class="line">    cout &lt;&lt; a &lt;&lt; endl;       //正确，public成员。</div><div class="line">    cout &lt;&lt; a1 &lt;&lt; endl;       //正确，基类public成员,在派生类中变成了private,可以被派生类访问。</div><div class="line">    cout &lt;&lt; a2 &lt;&lt; endl;       //正确，基类的protected成员，在派生类中变成了private,可以被派生类访问。</div><div class="line">    cout &lt;&lt; a3 &lt;&lt; endl;       //错误，基类的private成员不能被派生类访问。</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">int main()&#123;</div><div class="line">  B b(10);</div><div class="line">  cout &lt;&lt; b.a &lt;&lt; endl;       //正确。public成员</div><div class="line">  cout &lt;&lt; b.a1 &lt;&lt; endl;      //错误，private成员不能在类外访问。</div><div class="line">  cout &lt;&lt; b.a2 &lt;&lt; endl;      //错误, private成员不能在类外访问。</div><div class="line">  cout &lt;&lt; b.a3 &lt;&lt; endl;      //错误，private成员不能在类外访问。</div><div class="line">  system(&quot;pause&quot;);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="1-3C-类构造函数-amp-析构函数"><a href="#1-3C-类构造函数-amp-析构函数" class="headerlink" title="1.3C++ 类构造函数 &amp; 析构函数"></a>1.3C++ 类构造函数 &amp; 析构函数</h2><h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><p><strong>类的构造函数</strong>是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p><p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p><p>下面的实例有助于更好地理解构造函数的概念：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Line</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      void setLength( double len );</div><div class="line">      double getLength( void );</div><div class="line">      Line();  // 这是构造函数</div><div class="line"> </div><div class="line">   private:</div><div class="line">      double length;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 成员函数定义，包括构造函数</div><div class="line">Line::Line(void)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void Line::setLength( double len )</div><div class="line">&#123;</div><div class="line">    length = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">double Line::getLength( void )</div><div class="line">&#123;</div><div class="line">    return length;</div><div class="line">&#125;</div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Line line;</div><div class="line"> </div><div class="line">   // 设置长度</div><div class="line">   line.setLength(6.0); </div><div class="line">   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object is being created</div><div class="line">Length of line : 6</div></pre></td></tr></table></figure></p><h3 id="带参数的构造函数"><a href="#带参数的构造函数" class="headerlink" title="带参数的构造函数"></a>带参数的构造函数</h3><p>默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值，如下面的例子所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Line</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      void setLength( double len );</div><div class="line">      double getLength( void );</div><div class="line">      Line(double len);  // 这是构造函数</div><div class="line"> </div><div class="line">   private:</div><div class="line">      double length;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 成员函数定义，包括构造函数</div><div class="line">Line::Line( double len)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl;</div><div class="line">    length = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void Line::setLength( double len )</div><div class="line">&#123;</div><div class="line">    length = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">double Line::getLength( void )</div><div class="line">&#123;</div><div class="line">    return length;</div><div class="line">&#125;</div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Line line(10.0);</div><div class="line"> </div><div class="line">   // 获取默认设置的长度</div><div class="line">   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;</div><div class="line">   // 再次设置长度</div><div class="line">   line.setLength(6.0); </div><div class="line">   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object is being created, length = 10</div><div class="line">Length of line : 10</div><div class="line">Length of line : 6</div></pre></td></tr></table></figure></p><h3 id="使用初始化列表来初始化字段"><a href="#使用初始化列表来初始化字段" class="headerlink" title="使用初始化列表来初始化字段"></a>使用初始化列表来初始化字段</h3><p>使用初始化列表来初始化字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Line::Line( double len): length(len)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的语法等同于如下语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Line::Line( double len)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl;</div><div class="line">    length = len;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">C::C( double a, double b, double c): X(a), Y(b), Z(c)</div><div class="line">&#123;</div><div class="line">  ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="类的析构函数"><a href="#类的析构函数" class="headerlink" title="类的析构函数"></a>类的析构函数</h3><p>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p><p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p><p>下面的实例有助于更好地理解析构函数的概念：<br>实例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span>;</div><div class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</div><div class="line">      Line();   <span class="comment">// 这是构造函数声明</span></div><div class="line">      ~Line();  <span class="comment">// 这是析构函数声明</span></div><div class="line"> </div><div class="line">   <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">double</span> length;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// 成员函数定义，包括构造函数</span></div><div class="line">Line::Line(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">Line::~Line(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being deleted"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">void</span> Line::setLength( <span class="keyword">double</span> len )</div><div class="line">&#123;</div><div class="line">    length = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">double</span> Line::getLength( <span class="keyword">void</span> )</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> length;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 程序的主函数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></div><div class="line">&#123;</div><div class="line">   Line line;</div><div class="line"> </div><div class="line">   <span class="comment">// 设置长度</span></div><div class="line">   line.setLength(<span class="number">6.0</span>); </div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Length of line : "</span> &lt;&lt; line.getLength() &lt;&lt;<span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object is being created</div><div class="line">Length of line : 6</div><div class="line">Object is being deleted</div></pre></td></tr></table></figure></p><h2 id="1-4-C-拷贝构造函数"><a href="#1-4-C-拷贝构造函数" class="headerlink" title="1.4.C++ 拷贝构造函数"></a>1.4.C++ 拷贝构造函数</h2><p><strong>拷贝构造函数</strong>是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p><pre><code>通过使用另一个同类型的对象来初始化新创建的对象。复制对象把它作为参数传递给函数。复制对象，并从函数返回这个对象。</code></pre><p><strong>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。</strong><br><strong>如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。</strong><br>拷贝构造函数的最常见形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">classname (const classname &amp;obj) &#123;</div><div class="line">   // 构造函数的主体</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里，obj 是一个对象引用，该对象是用于初始化另一个对象的。<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Line</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      int getLength( void );</div><div class="line">      Line( int len );             // 简单的构造函数</div><div class="line">      Line( const Line &amp;obj);      // 拷贝构造函数</div><div class="line">      ~Line();                     // 析构函数</div><div class="line"> </div><div class="line">   private:</div><div class="line">      int *ptr;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 成员函数定义，包括构造函数</div><div class="line">Line::Line(int len)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;调用构造函数&quot; &lt;&lt; endl;</div><div class="line">    // 为指针分配内存</div><div class="line">    ptr = new int;</div><div class="line">    *ptr = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Line::Line(const Line &amp;obj)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;调用拷贝构造函数并为指针 ptr 分配内存&quot; &lt;&lt; endl;</div><div class="line">    ptr = new int;</div><div class="line">    *ptr = *obj.ptr; // 拷贝值</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Line::~Line(void)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;释放内存&quot; &lt;&lt; endl;</div><div class="line">    delete ptr;</div><div class="line">&#125;</div><div class="line">int Line::getLength( void )</div><div class="line">&#123;</div><div class="line">    return *ptr;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void display(Line obj)</div><div class="line">&#123;</div><div class="line">   cout &lt;&lt; &quot;line 大小 : &quot; &lt;&lt; obj.getLength() &lt;&lt;endl;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Line line(10);</div><div class="line"> </div><div class="line">   display(line);</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">调用构造函数</div><div class="line">调用拷贝构造函数并为指针 ptr 分配内存</div><div class="line">line 大小 : 10</div><div class="line">释放内存</div><div class="line">释放内存</div></pre></td></tr></table></figure></p><p>下面的实例对上面的实例稍作修改，通过使用已有的同类型的对象来初始化新创建的对象：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Line</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      int getLength( void );</div><div class="line">      Line( int len );             // 简单的构造函数</div><div class="line">      Line( const Line &amp;obj);      // 拷贝构造函数</div><div class="line">      ~Line();                     // 析构函数</div><div class="line"> </div><div class="line">   private:</div><div class="line">      int *ptr;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 成员函数定义，包括构造函数</div><div class="line">Line::Line(int len)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;调用构造函数&quot; &lt;&lt; endl;</div><div class="line">    // 为指针分配内存</div><div class="line">    ptr = new int;</div><div class="line">    *ptr = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Line::Line(const Line &amp;obj)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;调用拷贝构造函数并为指针 ptr 分配内存&quot; &lt;&lt; endl;</div><div class="line">    ptr = new int;</div><div class="line">    *ptr = *obj.ptr; // 拷贝值</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Line::~Line(void)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;释放内存&quot; &lt;&lt; endl;</div><div class="line">    delete ptr;</div><div class="line">&#125;</div><div class="line">int Line::getLength( void )</div><div class="line">&#123;</div><div class="line">    return *ptr;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void display(Line obj)</div><div class="line">&#123;</div><div class="line">   cout &lt;&lt; &quot;line 大小 : &quot; &lt;&lt; obj.getLength() &lt;&lt;endl;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Line line1(10);</div><div class="line"> </div><div class="line">   Line line2 = line1; // 这里也调用了拷贝构造函数</div><div class="line"> </div><div class="line">   display(line1);</div><div class="line">   display(line2);</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">调用构造函数</div><div class="line">调用拷贝构造函数并为指针 ptr 分配内存</div><div class="line">调用拷贝构造函数并为指针 ptr 分配内存</div><div class="line">line 大小 : 10</div><div class="line">释放内存</div><div class="line">调用拷贝构造函数并为指针 ptr 分配内存</div><div class="line">line 大小 : 10</div><div class="line">释放内存</div><div class="line">释放内存</div><div class="line">释放内存</div></pre></td></tr></table></figure></p><h2 id="1-5-C-友元函数"><a href="#1-5-C-友元函数" class="headerlink" title="1.5.C++ 友元函数"></a>1.5.C++ 友元函数</h2><p><strong>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。</strong>尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p><p>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。</p><p>如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   double width;</div><div class="line">public:</div><div class="line">   double length;</div><div class="line">   friend void printWidth( Box box );</div><div class="line">   void setWidth( double wid );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>声明类 ClassTwo 的所有成员函数作为类 ClassOne 的友元，需要在类 ClassOne 的定义中放置如下声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">friend class ClassTwo;</div></pre></td></tr></table></figure></p><p>请看下面的程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   double width;</div><div class="line">public:</div><div class="line">   friend void printWidth( Box box );</div><div class="line">   void setWidth( double wid );</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 成员函数定义</div><div class="line">void Box::setWidth( double wid )</div><div class="line">&#123;</div><div class="line">    width = wid;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 请注意：printWidth() 不是任何类的成员函数</div><div class="line">void printWidth( Box box )</div><div class="line">&#123;</div><div class="line">   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</div><div class="line">   cout &lt;&lt; &quot;Width of box : &quot; &lt;&lt; box.width &lt;&lt;endl;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Box box;</div><div class="line"> </div><div class="line">   // 使用成员函数设置宽度</div><div class="line">   box.setWidth(10.0);</div><div class="line">   </div><div class="line">   // 使用友元函数输出宽度</div><div class="line">   printWidth( box );</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Width of box : 10</div></pre></td></tr></table></figure></p><h2 id="1-6-C-内联函数"><a href="#1-6-C-内联函数" class="headerlink" title="1.6.C++ 内联函数"></a>1.6.C++ 内联函数</h2><p>C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。</p><p>对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。</p><p><strong>如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。</strong>如果已定义的函数多于一行，编译器会忽略 inline 限定符。</p><p><strong>在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。</strong></p><p>下面是一个实例，使用内联函数来返回两个数中的最大值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">inline int Max(int x, int y)</div><div class="line">&#123;</div><div class="line">   return (x &gt; y)? x : y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line"></div><div class="line">   cout &lt;&lt; &quot;Max (20,10): &quot; &lt;&lt; Max(20,10) &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;Max (0,200): &quot; &lt;&lt; Max(0,200) &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;Max (100,1010): &quot; &lt;&lt; Max(100,1010) &lt;&lt; endl;</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Max (20,10): 20</div><div class="line">Max (0,200): 200</div><div class="line">Max (100,1010): 1010</div></pre></td></tr></table></figure></p><h2 id="1-7-C-this-指针"><a href="#1-7-C-this-指针" class="headerlink" title="1.7.C++ this 指针"></a>1.7.C++ this 指针</h2><p>在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p><p>友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。</p><p>下面的实例有助于更好地理解 this 指针的概念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      // 构造函数定义</div><div class="line">      Box(double l=2.0, double b=2.0, double h=2.0)</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt;&quot;Constructor called.&quot; &lt;&lt; endl;</div><div class="line">         length = l;</div><div class="line">         breadth = b;</div><div class="line">         height = h;</div><div class="line">      &#125;</div><div class="line">      double Volume()</div><div class="line">      &#123;</div><div class="line">         return length * breadth * height;</div><div class="line">      &#125;</div><div class="line">      int compare(Box box)</div><div class="line">      &#123;</div><div class="line">         return this-&gt;Volume() &gt; box.Volume();</div><div class="line">      &#125;</div><div class="line">   private:</div><div class="line">      double length;     // Length of a box</div><div class="line">      double breadth;    // Breadth of a box</div><div class="line">      double height;     // Height of a box</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">   Box Box1(3.3, 1.2, 1.5);    // Declare box1</div><div class="line">   Box Box2(8.5, 6.0, 2.0);    // Declare box2</div><div class="line"></div><div class="line">   if(Box1.compare(Box2))</div><div class="line">   &#123;</div><div class="line">      cout &lt;&lt; &quot;Box2 is smaller than Box1&quot; &lt;&lt;endl;</div><div class="line">   &#125;</div><div class="line">   else</div><div class="line">   &#123;</div><div class="line">      cout &lt;&lt; &quot;Box2 is equal to or larger than Box1&quot; &lt;&lt;endl;</div><div class="line">   &#125;</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Constructor called.</div><div class="line">Constructor called.</div><div class="line">Box2 is equal to or larger than Box1</div></pre></td></tr></table></figure></p><h2 id="1-8-C-指向类的指针"><a href="#1-8-C-指向类的指针" class="headerlink" title="1.8.C++ 指向类的指针"></a>1.8.C++ 指向类的指针</h2><p>一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符<code>-&gt;</code>，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。</p><p>下面的实例有助于更好地理解指向类的指针的概念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      // 构造函数定义</div><div class="line">      Box(double l=2.0, double b=2.0, double h=2.0)</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt;&quot;Constructor called.&quot; &lt;&lt; endl;</div><div class="line">         length = l;</div><div class="line">         breadth = b;</div><div class="line">         height = h;</div><div class="line">      &#125;</div><div class="line">      double Volume()</div><div class="line">      &#123;</div><div class="line">         return length * breadth * height;</div><div class="line">      &#125;</div><div class="line">   private:</div><div class="line">      double length;     // Length of a box</div><div class="line">      double breadth;    // Breadth of a box</div><div class="line">      double height;     // Height of a box</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">   Box Box1(3.3, 1.2, 1.5);    // Declare box1</div><div class="line">   Box Box2(8.5, 6.0, 2.0);    // Declare box2</div><div class="line">   Box *ptrBox;                // Declare pointer to a class.</div><div class="line"></div><div class="line">   // 保存第一个对象的地址</div><div class="line">   ptrBox = &amp;Box1;</div><div class="line"></div><div class="line">   // 现在尝试使用成员访问运算符来访问成员</div><div class="line">   cout &lt;&lt; &quot;Volume of Box1: &quot; &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; endl;</div><div class="line"></div><div class="line">   // 保存第二个对象的地址</div><div class="line">   ptrBox = &amp;Box2;</div><div class="line"></div><div class="line">   // 现在尝试使用成员访问运算符来访问成员</div><div class="line">   cout &lt;&lt; &quot;Volume of Box2: &quot; &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; endl;</div><div class="line">  </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Constructor called.</div><div class="line">Constructor called.</div><div class="line">Volume of Box1: 5.94</div><div class="line">Volume of Box2: 102</div></pre></td></tr></table></figure></p><h2 id="1-9-C-类的静态成员"><a href="#1-9-C-类的静态成员" class="headerlink" title="1.9.C++ 类的静态成员"></a>1.9.C++ 类的静态成员</h2><p>我们可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。</p><p>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化，如下面的实例所示。</p><p>下面的实例有助于更好地理解静成员态数据的概念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      static int objectCount;</div><div class="line">      // 构造函数定义</div><div class="line">      Box(double l=2.0, double b=2.0, double h=2.0)</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt;&quot;Constructor called.&quot; &lt;&lt; endl;</div><div class="line">         length = l;</div><div class="line">         breadth = b;</div><div class="line">         height = h;</div><div class="line">         // 每次创建对象时增加 1</div><div class="line">         objectCount++;</div><div class="line">      &#125;</div><div class="line">      double Volume()</div><div class="line">      &#123;</div><div class="line">         return length * breadth * height;</div><div class="line">      &#125;</div><div class="line">   private:</div><div class="line">      double length;     // 长度</div><div class="line">      double breadth;    // 宽度</div><div class="line">      double height;     // 高度</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 初始化类 Box 的静态成员</div><div class="line">int Box::objectCount = 0;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">   Box Box1(3.3, 1.2, 1.5);    // 声明 box1</div><div class="line">   Box Box2(8.5, 6.0, 2.0);    // 声明 box2</div><div class="line"></div><div class="line">   // 输出对象的总数</div><div class="line">   cout &lt;&lt; &quot;Total objects: &quot; &lt;&lt; Box::objectCount &lt;&lt; endl;</div><div class="line"></div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Constructor called.</div><div class="line">Constructor called.</div><div class="line">Total objects: 2</div></pre></td></tr></table></figure></p><h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><p>如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符<code>::</code> 就可以访问。</p><p>静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。</p><p>静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。</p><blockquote><p>   静态成员函数与普通成员函数的区别：</p><pre><code>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。</code></pre></blockquote><p>下面的实例有助于更好地理解静态成员函数的概念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      static int objectCount;</div><div class="line">      // 构造函数定义</div><div class="line">      Box(double l=2.0, double b=2.0, double h=2.0)</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt;&quot;Constructor called.&quot; &lt;&lt; endl;</div><div class="line">         length = l;</div><div class="line">         breadth = b;</div><div class="line">         height = h;</div><div class="line">         // 每次创建对象时增加 1</div><div class="line">         objectCount++;</div><div class="line">      &#125;</div><div class="line">      double Volume()</div><div class="line">      &#123;</div><div class="line">         return length * breadth * height;</div><div class="line">      &#125;</div><div class="line">      static int getCount()</div><div class="line">      &#123;</div><div class="line">         return objectCount;</div><div class="line">      &#125;</div><div class="line">   private:</div><div class="line">      double length;     // 长度</div><div class="line">      double breadth;    // 宽度</div><div class="line">      double height;     // 高度</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 初始化类 Box 的静态成员</div><div class="line">int Box::objectCount = 0;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">  </div><div class="line">   // 在创建对象之前输出对象的总数</div><div class="line">   cout &lt;&lt; &quot;Inital Stage Count: &quot; &lt;&lt; Box::getCount() &lt;&lt; endl;</div><div class="line"></div><div class="line">   Box Box1(3.3, 1.2, 1.5);    // 声明 box1</div><div class="line">   Box Box2(8.5, 6.0, 2.0);    // 声明 box2</div><div class="line"></div><div class="line">   // 在创建对象之后输出对象的总数</div><div class="line">   cout &lt;&lt; &quot;Final Stage Count: &quot; &lt;&lt; Box::getCount() &lt;&lt; endl;</div><div class="line"></div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Inital Stage Count: 0</div><div class="line">Constructor called.</div><div class="line">Constructor called.</div><div class="line">Final Stage Count: 2</div></pre></td></tr></table></figure></p><p>转自：<a href="http://www.runoob.com/cplusplus/cpp-classes-objects.html" target="_blank" rel="external">c++类&amp;对象|菜鸟教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-C-类-amp-对象&quot;&gt;&lt;a href=&quot;#1-C-类-amp-对象&quot; class=&quot;headerlink&quot; title=&quot;1.C++ 类 &amp;amp; 对象&quot;&gt;&lt;/a&gt;1.C++ 类 &amp;amp; 对象&lt;/h1&gt;&lt;p&gt;C++ 在 C 语言的基础上增加了面向对象编
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++笔记：（2）</title>
    <link href="http://yoursite.com/2017/11/13/c++%E7%AC%94%E8%AE%B0/c++%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2017/11/13/c++笔记/c++笔记：（2）/</id>
    <published>2017-11-13T13:08:57.000Z</published>
    <updated>2021-02-19T13:32:12.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-C-指针"><a href="#1-C-指针" class="headerlink" title="1.C++ 指针"></a>1.C++ 指针</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   int  var = 20;   // 实际变量的声明</div><div class="line">   int  *ip;        // 指针变量的声明</div><div class="line"> </div><div class="line">   ip = &amp;var;       // 在指针变量中存储 var 的地址</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;Value of var variable: &quot;;</div><div class="line">   cout &lt;&lt; var &lt;&lt; endl;</div><div class="line"> </div><div class="line">   // 输出在指针变量中存储的地址</div><div class="line">   cout &lt;&lt; &quot;Address stored in ip variable: &quot;;</div><div class="line">   cout &lt;&lt; ip &lt;&lt; endl;</div><div class="line"> </div><div class="line">   // 访问指针中地址的值</div><div class="line">   cout &lt;&lt; &quot;Value of *ip variable: &quot;;</div><div class="line">   cout &lt;&lt; *ip &lt;&lt; endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">Value of var variable: 20</div><div class="line">Address stored in ip variable: 0x7ffd7a7a7fd4</div><div class="line">Value of *ip variable: 20</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure><h1 id="2-C-传递指针给函数"><a href="#2-C-传递指针给函数" class="headerlink" title="2.C++ 传递指针给函数"></a>2.C++ 传递指针给函数</h1><p>c++指针传递给函数时，可以在函数中改变指针所指变量的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">// 函数声明</div><div class="line"></div><div class="line">double getAverage(int *arr, int size);</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">int main ()</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">   // 带有 5 个元素的整型数组</div><div class="line"></div><div class="line">   int balance[5] = &#123;1000, 2, 3, 17, 50&#125;;</div><div class="line"></div><div class="line">   double avg;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">   // 传递一个指向数组的指针作为参数</div><div class="line"></div><div class="line">   avg = getAverage( balance, 5 ) ;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">   // 输出返回值</div><div class="line"></div><div class="line">   cout &lt;&lt; &quot;Average value is: &quot; &lt;&lt; avg &lt;&lt; endl;</div><div class="line"></div><div class="line">    cout &lt;&lt; &quot;Average value is: &quot; &lt;&lt; balance[0] &lt;&lt; endl;</div><div class="line"></div><div class="line">     cout &lt;&lt; &quot;Average value is: &quot; &lt;&lt; balance[1] &lt;&lt; endl;</div><div class="line"></div><div class="line">      cout &lt;&lt; &quot;Average value is: &quot; &lt;&lt; balance[2]&lt;&lt; endl;</div><div class="line"></div><div class="line">       cout &lt;&lt; &quot;Average value is: &quot; &lt;&lt; balance[3] &lt;&lt; endl;</div><div class="line"></div><div class="line">        cout &lt;&lt; &quot;Average value is: &quot; &lt;&lt; balance[4] &lt;&lt; endl;</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">   return 0;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">double getAverage(int *arr, int size)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">  int    i, sum = 0;       </div><div class="line"></div><div class="line">  double avg;          </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">  for (i = 0; i &lt; size; ++i)</div><div class="line"></div><div class="line">  &#123;</div><div class="line"></div><div class="line">    sum += arr[i];</div><div class="line"></div><div class="line">    arr[i] =arr[i]+1;</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">  avg = double(sum) / size;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">  return avg;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line"></div><div class="line">Average value is: 214.4</div><div class="line"></div><div class="line">Average value is: 1001</div><div class="line"></div><div class="line">Average value is: 3</div><div class="line"></div><div class="line">Average value is: 4</div><div class="line"></div><div class="line">Average value is: 18</div><div class="line"></div><div class="line">Average value is: 51</div><div class="line"></div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure><h1 id="3-C-从函数返回指针"><a href="#3-C-从函数返回指针" class="headerlink" title="3.C++ 从函数返回指针"></a>3.C++ 从函数返回指针</h1><p>另外，C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。</p><p>现在，让我们来看下面的函数，它会生成 10 个随机数，并使用表示指针的数组名（即第一个数组元素的地址）来返回它们，具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;ctime&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 要生成和返回随机数的函数</div><div class="line">int * getRandom( )</div><div class="line">&#123;</div><div class="line">  static int  r[10];</div><div class="line"> </div><div class="line">  // 设置种子</div><div class="line">  srand( (unsigned)time( NULL ) );</div><div class="line">  for (int i = 0; i &lt; 10; ++i)</div><div class="line">  &#123;</div><div class="line">    r[i] = rand();</div><div class="line">    cout &lt;&lt; r[i] &lt;&lt; endl;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  return r;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 要调用上面定义函数的主函数</div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   // 一个指向整数的指针</div><div class="line">   int *p;</div><div class="line"> </div><div class="line">   p = getRandom();</div><div class="line">   for ( int i = 0; i &lt; 10; i++ )</div><div class="line">   &#123;</div><div class="line">       cout &lt;&lt; &quot;*(p + &quot; &lt;&lt; i &lt;&lt; &quot;) : &quot;;</div><div class="line">       cout &lt;&lt; *(p + i) &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">624723190</div><div class="line">1468735695</div><div class="line">807113585</div><div class="line">976495677</div><div class="line">613357504</div><div class="line">1377296355</div><div class="line">1530315259</div><div class="line">1778906708</div><div class="line">1820354158</div><div class="line">667126415</div><div class="line">*(p + 0) : 624723190</div><div class="line">*(p + 1) : 1468735695</div><div class="line">*(p + 2) : 807113585</div><div class="line">*(p + 3) : 976495677</div><div class="line">*(p + 4) : 613357504</div><div class="line">*(p + 5) : 1377296355</div><div class="line">*(p + 6) : 1530315259</div><div class="line">*(p + 7) : 1778906708</div><div class="line">*(p + 8) : 1820354158</div><div class="line">*(p + 9) : 667126415</div></pre></td></tr></table></figure></p><h1 id="4-C-引用"><a href="#4-C-引用" class="headerlink" title="4.C++ 引用"></a>4.C++ 引用</h1><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。<br>C++ 引用 vs 指针</p><h4 id="引用很容易与指针混淆，它们之间有三个主要的不同："><a href="#引用很容易与指针混淆，它们之间有三个主要的不同：" class="headerlink" title="引用很容易与指针混淆，它们之间有三个主要的不同："></a>引用很容易与指针混淆，它们之间有三个主要的不同：</h4><blockquote><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul></blockquote><h4 id="C-中创建引用"><a href="#C-中创建引用" class="headerlink" title="C++ 中创建引用"></a>C++ 中创建引用</h4><p>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int i = 17;</div></pre></td></tr></table></figure></p><p>我们可以为 i 声明引用变量，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int&amp;    r = i;</div></pre></td></tr></table></figure></p><p>在这些声明中，&amp; 读作引用。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   // 声明简单的变量</div><div class="line">   int    i;</div><div class="line">   double d;</div><div class="line"> </div><div class="line">   // 声明引用变量</div><div class="line">   int&amp;    r = i;</div><div class="line">   double&amp; s = d;</div><div class="line">   </div><div class="line">   i = 5;</div><div class="line">   cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r  &lt;&lt; endl;</div><div class="line"> </div><div class="line">   d = 11.7;</div><div class="line">   cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s  &lt;&lt; endl;</div><div class="line">   </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Value of i : 5</div><div class="line">Value of i reference : 5</div><div class="line">Value of d : 11.7</div><div class="line">Value of d reference : 11.7</div></pre></td></tr></table></figure></p><p>引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：<br>|概念    | 描述 |<br>|—|:—:|<br>| 4.1 把引用作为参数    | C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。|<br>|4.2 把引用作为返回值 |    可以从 C++ 函数中返回引用，就像返回其他数据类型一样。|</p><h1 id="4-1C-把引用作为参数"><a href="#4-1C-把引用作为参数" class="headerlink" title="4.1C++ 把引用作为参数"></a>4.1C++ 把引用作为参数</h1><p>我们已经讨论了如何使用指针来实现引用调用函数。下面的实例使用了引用来实现引用调用函数。<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 函数声明</div><div class="line">void swap(int&amp; x, int&amp; y);</div><div class="line"> </div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   // 局部变量声明</div><div class="line">   int a = 100;</div><div class="line">   int b = 200;</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;交换前，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;交换前，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;</div><div class="line"> </div><div class="line">   /* 调用函数来交换值 */</div><div class="line">   swap(a, b);</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;交换后，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;交换后，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 函数定义</div><div class="line">void swap(int&amp; x, int&amp; y)</div><div class="line">&#123;</div><div class="line">   int temp;</div><div class="line">   temp = x; /* 保存地址 x 的值 */</div><div class="line">   x = y;    /* 把 y 赋值给 x */</div><div class="line">   y = temp; /* 把 x 赋值给 y  */</div><div class="line">  </div><div class="line">   return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">交换前，a 的值： 100</div><div class="line">交换前，b 的值： 200</div><div class="line">交换后，a 的值： 200</div><div class="line">交换后，b 的值： 100</div></pre></td></tr></table></figure></p><h2 id="4-2-C-把引用作为返回值"><a href="#4-2-C-把引用作为返回值" class="headerlink" title="4.2 C++ 把引用作为返回值"></a>4.2 C++ 把引用作为返回值</h2><p>通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护。C++ 函数可以返回一个引用，方式与返回一个指针类似。</p><p>当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。例如，请看下面这个简单的程序：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">double vals[] = &#123;10.1, 12.6, 33.1, 24.1, 50.0&#125;;</div><div class="line"> </div><div class="line">double&amp; setValues( int i )</div><div class="line">&#123;</div><div class="line">  return vals[i];   // 返回第 i 个元素的引用</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 要调用上面定义函数的主函数</div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;改变前的值&quot; &lt;&lt; endl;</div><div class="line">   for ( int i = 0; i &lt; 5; i++ )</div><div class="line">   &#123;</div><div class="line">       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;</div><div class="line">       cout &lt;&lt; vals[i] &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   setValues(1) = 20.23; // 改变第 2 个元素</div><div class="line">   setValues(3) = 70.8;  // 改变第 4 个元素</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;改变后的值&quot; &lt;&lt; endl;</div><div class="line">   for ( int i = 0; i &lt; 5; i++ )</div><div class="line">   &#123;</div><div class="line">       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;</div><div class="line">       cout &lt;&lt; vals[i] &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">改变前的值</div><div class="line">vals[0] = 10.1</div><div class="line">vals[1] = 12.6</div><div class="line">vals[2] = 33.1</div><div class="line">vals[3] = 24.1</div><div class="line">vals[4] = 50</div><div class="line">改变后的值</div><div class="line">vals[0] = 10.1</div><div class="line">vals[1] = 20.23</div><div class="line">vals[2] = 33.1</div><div class="line">vals[3] = 70.8</div><div class="line">vals[4] = 50</div></pre></td></tr></table></figure></p><p>当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int&amp; func() &#123;</div><div class="line">   int q;</div><div class="line">   //! return q; // 在编译时发生错误</div><div class="line">   static int x;</div><div class="line">   return x;     // 安全，x 在函数作用域外依然是有效的</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="5-C-日期-amp-时间"><a href="#5-C-日期-amp-时间" class="headerlink" title="5.C++ 日期 &amp; 时间"></a>5.C++ 日期 &amp; 时间</h1><p>C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。</ctime></p><p>有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。</p><p>结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct tm &#123;</div><div class="line">  int tm_sec;   // 秒，正常范围从 0 到 59，但允许至 61</div><div class="line">  int tm_min;   // 分，范围从 0 到 59</div><div class="line">  int tm_hour;  // 小时，范围从 0 到 23</div><div class="line">  int tm_mday;  // 一月中的第几天，范围从 1 到 31</div><div class="line">  int tm_mon;   // 月，范围从 0 到 11</div><div class="line">  int tm_year;  // 自 1900 年起的年数</div><div class="line">  int tm_wday;  // 一周中的第几天，范围从 0 到 6，从星期日算起</div><div class="line">  int tm_yday;  // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起</div><div class="line">  int tm_isdst; // 夏令时</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="使用结构-tm-格式化时间"><a href="#使用结构-tm-格式化时间" class="headerlink" title="使用结构 tm 格式化时间"></a>使用结构 tm 格式化时间</h3><p>tm 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。</p><p>在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -&gt; 运算符来访问结构成员。<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;ctime&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   // 基于当前系统的当前日期/时间</div><div class="line">   time_t now = time(0);</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;1970 到目前经过秒数:&quot; &lt;&lt; now &lt;&lt; endl;</div><div class="line"> </div><div class="line">   tm *ltm = localtime(&amp;now);</div><div class="line"> </div><div class="line">   // 输出 tm 结构的各个组成部分</div><div class="line">   cout &lt;&lt; &quot;年: &quot;&lt;&lt; 1900 + ltm-&gt;tm_year &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;月: &quot;&lt;&lt; 1 + ltm-&gt;tm_mon&lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;日: &quot;&lt;&lt;  ltm-&gt;tm_mday &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;时间: &quot;&lt;&lt; ltm-&gt;tm_hour &lt;&lt; &quot;:&quot;;</div><div class="line">   cout &lt;&lt; ltm-&gt;tm_min &lt;&lt; &quot;:&quot;;</div><div class="line">   cout &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1970 到目前时间:1503564157</div><div class="line">年: 2017</div><div class="line">月: 8</div><div class="line">日: 24</div><div class="line">时间: 16:42:37</div></pre></td></tr></table></figure></p><h1 id="6-C-基本的输入输出"><a href="#6-C-基本的输入输出" class="headerlink" title="6.C++ 基本的输入输出"></a>6.C++ 基本的输入输出</h1><p>C++ 标准库提供了一组丰富的输入/输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。</p><blockquote><ul><li>如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。</li><li>如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。<br>I/O 库头文件</li></ul></blockquote><p>下列的头文件在 C++ 编程中很重要。<br>|头文件    |函数和描述|<br>|—|—|<br>| &lt; iostream &gt;     |该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。|<br>| &lt; iomanip &gt;    |该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。|<br>| &lt; fstream &gt;    | 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。|</p><h3 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a>标准输出流（cout）</h3><p>预定义的对象 cout 是 ostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符<code>&lt;&lt;</code>结合使用的，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   char str[] = &quot;Hello C++&quot;;</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;Value of str is : &quot; &lt;&lt; str &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Value of str is : Hello C++</div></pre></td></tr></table></figure></p><p>C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。<code>&lt;&lt;</code>运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。</p><p>流插入运算符<code>&lt;&lt;</code>在一个语句中可以多次使用，如上面实例中所示，<code>endl</code> 用于在行末添加一个换行符。</p><h3 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a>标准输入流（cin）</h3><p>预定义的对象<code>cin</code> 是 istream 类的一个实例。<code>cin</code>对象附属到标准输入设备，通常是键盘。<code>cin</code>是与流提取运算符 <code>&gt;&gt;</code>结合使用的，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   char name[50];</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;请输入您的名称： &quot;;</div><div class="line">   cin &gt;&gt; name;</div><div class="line">   cout &lt;&lt; &quot;您的名称是： &quot; &lt;&lt; name &lt;&lt; endl;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会提示用户输入名称。当用户输入一个值，并按回车键，就会看到下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">请输入您的名称： cplusplus</div><div class="line">您的名称是： cplusplus</div></pre></td></tr></table></figure></p><p>C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。</p><p>流提取运算符 <code>&gt;&gt;</code>在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cin &gt;&gt; name &gt;&gt; age;</div></pre></td></tr></table></figure></p><p>这相当于下面两个语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cin &gt;&gt; name;</div><div class="line">cin &gt;&gt; age;</div></pre></td></tr></table></figure></p><h3 id="标准错误流（cerr）"><a href="#标准错误流（cerr）" class="headerlink" title="标准错误流（cerr）"></a>标准错误流（cerr）</h3><p>预定义的对象 cerr 是 ostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p><p>cerr 也是与流插入运算符<code>&lt;&lt;</code> 结合使用的，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   char str[] = &quot;Unable to read....&quot;;</div><div class="line"> </div><div class="line">   cerr &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error message : Unable to read....</div></pre></td></tr></table></figure></p><h3 id="标准日志流（clog）"><a href="#标准日志流（clog）" class="headerlink" title="标准日志流（clog）"></a>标准日志流（clog）</h3><p>预定义的对象 clog 是 ostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。</p><p>clog 也是与流插入运算符 <code>&lt;&lt;</code>结合使用的，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   char str[] = &quot;Unable to read....&quot;;</div><div class="line"> </div><div class="line">   clog &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error message : Unable to read....</div></pre></td></tr></table></figure></p><p>通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</p><h1 id="7-C-数据结构"><a href="#7-C-数据结构" class="headerlink" title="7.C++ 数据结构"></a>7.C++ 数据结构</h1><p>C/C++ 数组允许定义可存储相同类型数据项的变量，但是结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p><p>结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Title ：标题</div><div class="line">Author ：作者</div><div class="line">Subject ：类目</div><div class="line">Book ID ：书的 ID</div></pre></td></tr></table></figure></p><h3 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h3><p>为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct type_name &#123;</div><div class="line">member_type1 member_name1;</div><div class="line">member_type2 member_name2;</div><div class="line">member_type3 member_name3;</div><div class="line">.</div><div class="line">.</div><div class="line">&#125; object_names;</div></pre></td></tr></table></figure></p><p>type_name 是结构体类型的名称，member_type1 member_name1 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 Books，变量为 book：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct Books</div><div class="line">&#123;</div><div class="line">   char  title[50];</div><div class="line">   char  author[50];</div><div class="line">   char  subject[100];</div><div class="line">   int   book_id;</div><div class="line">&#125; book;</div></pre></td></tr></table></figure></p><h3 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h3><p>为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。</p><p>下面的实例演示了结构的用法：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 声明一个结构体类型 Books </div><div class="line">struct Books</div><div class="line">&#123;</div><div class="line">   char  title[50];</div><div class="line">   char  author[50];</div><div class="line">   char  subject[100];</div><div class="line">   int   book_id;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Books Book1;        // 定义结构体类型 Books 的变量 Book1</div><div class="line">   Books Book2;        // 定义结构体类型 Books 的变量 Book2</div><div class="line"> </div><div class="line">   // Book1 详述</div><div class="line">   strcpy( Book1.title, &quot;C++ 教程&quot;);</div><div class="line">   strcpy( Book1.author, &quot;Runoob&quot;); </div><div class="line">   strcpy( Book1.subject, &quot;编程语言&quot;);</div><div class="line">   Book1.book_id = 12345;</div><div class="line"> </div><div class="line">   // Book2 详述</div><div class="line">   strcpy( Book2.title, &quot;CSS 教程&quot;);</div><div class="line">   strcpy( Book2.author, &quot;Runoob&quot;);</div><div class="line">   strcpy( Book2.subject, &quot;前端技术&quot;);</div><div class="line">   Book2.book_id = 12346;</div><div class="line"> </div><div class="line">   // 输出 Book1 信息</div><div class="line">   cout &lt;&lt; &quot;第一本书标题 : &quot; &lt;&lt; Book1.title &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;第一本书作者 : &quot; &lt;&lt; Book1.author &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;第一本书类目 : &quot; &lt;&lt; Book1.subject &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;第一本书 ID : &quot; &lt;&lt; Book1.book_id &lt;&lt;endl;</div><div class="line"> </div><div class="line">   // 输出 Book2 信息</div><div class="line">   cout &lt;&lt; &quot;第二本书标题 : &quot; &lt;&lt; Book2.title &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;第二本书作者 : &quot; &lt;&lt; Book2.author &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;第二本书类目 : &quot; &lt;&lt; Book2.subject &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;第二本书 ID : &quot; &lt;&lt; Book2.book_id &lt;&lt;endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>实例中定义了结构体类似 Books 及其两个变量 Book1 和 Book2。当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">第一本书标题 : C++ 教程</div><div class="line">第一本书作者 : Runoob</div><div class="line">第一本书类目 : 编程语言</div><div class="line">第一本书 ID : 12345</div><div class="line">第二本书标题 : CSS 教程</div><div class="line">第二本书作者 : Runoob</div><div class="line">第二本书类目 : 前端技术</div><div class="line">第二本书 ID : 12346</div></pre></td></tr></table></figure></p><h3 id="结构作为函数参数"><a href="#结构作为函数参数" class="headerlink" title="结构作为函数参数"></a>结构作为函数参数</h3><p>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line">void printBook( struct Books book );</div><div class="line"> </div><div class="line">// 声明一个结构体类型 Books </div><div class="line">struct Books</div><div class="line">&#123;</div><div class="line">   char  title[50];</div><div class="line">   char  author[50];</div><div class="line">   char  subject[100];</div><div class="line">   int   book_id;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Books Book1;        // 定义结构体类型 Books 的变量 Book1</div><div class="line">   Books Book2;        // 定义结构体类型 Books 的变量 Book2</div><div class="line"> </div><div class="line">    // Book1 详述</div><div class="line">   strcpy( Book1.title, &quot;C++ 教程&quot;);</div><div class="line">   strcpy( Book1.author, &quot;Runoob&quot;); </div><div class="line">   strcpy( Book1.subject, &quot;编程语言&quot;);</div><div class="line">   Book1.book_id = 12345;</div><div class="line"> </div><div class="line">   // Book2 详述</div><div class="line">   strcpy( Book2.title, &quot;CSS 教程&quot;);</div><div class="line">   strcpy( Book2.author, &quot;Runoob&quot;);</div><div class="line">   strcpy( Book2.subject, &quot;前端技术&quot;);</div><div class="line">   Book2.book_id = 12346;</div><div class="line"> </div><div class="line">   // 输出 Book1 信息</div><div class="line">   printBook( Book1 );</div><div class="line"> </div><div class="line">   // 输出 Book2 信息</div><div class="line">   printBook( Book2 );</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div><div class="line">void printBook( struct Books book )</div><div class="line">&#123;</div><div class="line">   cout &lt;&lt; &quot;书标题 : &quot; &lt;&lt; book.title &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;书作者 : &quot; &lt;&lt; book.author &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;书类目 : &quot; &lt;&lt; book.subject &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;书 ID : &quot; &lt;&lt; book.book_id &lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">书标题 : C++ 教程</div><div class="line">书作者 : Runoob</div><div class="line">书类目 : 编程语言</div><div class="line">书 ID : 12345</div><div class="line">书标题 : CSS 教程</div><div class="line">书作者 : Runoob</div><div class="line">书类目 : 前端技术</div><div class="line">书 ID : 12346</div></pre></td></tr></table></figure></p><h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct Books *struct_pointer;</div></pre></td></tr></table></figure></p><p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct_pointer = &amp;Book1;</div></pre></td></tr></table></figure></p><p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct_pointer-&gt;title;</div></pre></td></tr></table></figure></p><p>让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line">void printBook( struct Books *book );</div><div class="line"> </div><div class="line">struct Books</div><div class="line">&#123;</div><div class="line">   char  title[50];</div><div class="line">   char  author[50];</div><div class="line">   char  subject[100];</div><div class="line">   int   book_id;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Books Book1;        // 定义结构体类型 Books 的变量 Book1</div><div class="line">   Books Book2;        // 定义结构体类型 Books 的变量 Book2</div><div class="line"> </div><div class="line">    // Book1 详述</div><div class="line">   strcpy( Book1.title, &quot;C++ 教程&quot;);</div><div class="line">   strcpy( Book1.author, &quot;Runoob&quot;); </div><div class="line">   strcpy( Book1.subject, &quot;编程语言&quot;);</div><div class="line">   Book1.book_id = 12345;</div><div class="line"> </div><div class="line">   // Book2 详述</div><div class="line">   strcpy( Book2.title, &quot;CSS 教程&quot;);</div><div class="line">   strcpy( Book2.author, &quot;Runoob&quot;);</div><div class="line">   strcpy( Book2.subject, &quot;前端技术&quot;);</div><div class="line">   Book2.book_id = 12346;</div><div class="line"> </div><div class="line">   // 通过传 Book1 的地址来输出 Book1 信息</div><div class="line">   printBook( &amp;Book1 );</div><div class="line"> </div><div class="line">   // 通过传 Book2 的地址来输出 Book2 信息</div><div class="line">   printBook( &amp;Book2 );</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div><div class="line">// 该函数以结构指针作为参数</div><div class="line">void printBook( struct Books *book )</div><div class="line">&#123;</div><div class="line">   cout &lt;&lt; &quot;书标题  : &quot; &lt;&lt; book-&gt;title &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;书作者 : &quot; &lt;&lt; book-&gt;author &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;书类目 : &quot; &lt;&lt; book-&gt;subject &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;书 ID : &quot; &lt;&lt; book-&gt;book_id &lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">书标题  : C++ 教程</div><div class="line">书作者 : Runoob</div><div class="line">书类目 : 编程语言</div><div class="line">书 ID : 12345</div><div class="line">书标题  : CSS 教程</div><div class="line">书作者 : Runoob</div><div class="line">书类目 : 前端技术</div><div class="line">书 ID : 12346</div></pre></td></tr></table></figure></p><p>###typedef 关键字</p><p>下面是一种更简单的定义结构的方式，您可以为创建的类型取一个”别名”。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">   char  title[50];</div><div class="line">   char  author[50];</div><div class="line">   char  subject[100];</div><div class="line">   int   book_id;</div><div class="line">&#125;Books;</div></pre></td></tr></table></figure></p><p>现在，您可以直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字。下面是实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Books Book1, Book2;</div></pre></td></tr></table></figure></p><p>您可以使用 typedef 关键字来定义非结构类型，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef long int *pint32;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pint32 x, y, z;</div></pre></td></tr></table></figure><p>x, y 和 z 都是指向长整型 long int 的指针。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-C-指针&quot;&gt;&lt;a href=&quot;#1-C-指针&quot; class=&quot;headerlink&quot; title=&quot;1.C++ 指针&quot;&gt;&lt;/a&gt;1.C++ 指针&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++笔记：（1）</title>
    <link href="http://yoursite.com/2017/11/13/c++%E7%AC%94%E8%AE%B0/c++%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2017/11/13/c++笔记/c++笔记：（1）/</id>
    <published>2017-11-13T13:08:56.000Z</published>
    <updated>2021-02-19T13:32:12.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-C-指针运算符（-amp-和-）"><a href="#1-C-指针运算符（-amp-和-）" class="headerlink" title="1.C++ 指针运算符（&amp; 和 *）"></a>1.C++ 指针运算符（&amp; 和 *）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">int</span>  var;</div><div class="line">   <span class="keyword">int</span>  *ptr;</div><div class="line">   <span class="keyword">int</span>  val;</div><div class="line"></div><div class="line">   var = <span class="number">3000</span>;</div><div class="line"></div><div class="line">   <span class="comment">// 获取 var 的地址</span></div><div class="line">   ptr = &amp;var;</div><div class="line"></div><div class="line">   <span class="comment">// 获取 ptr 的值</span></div><div class="line">   val = *ptr;</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of var :"</span> &lt;&lt; var &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of ptr :"</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of val :"</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Value of var :<span class="number">3000</span></div><div class="line">Value of ptr :<span class="number">0xbff64494</span></div><div class="line">Value of val :<span class="number">3000</span></div></pre></td></tr></table></figure></p><h1 id="2-无限循环"><a href="#2-无限循环" class="headerlink" title="2.无限循环"></a>2.无限循环</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line"> </div><div class="line">   for( ; ; )</div><div class="line">   &#123;</div><div class="line">      printf(&quot;This loop will run forever.\n&quot;);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意：您可以按 Ctrl + C 键终止一个无限循环。</p><h1 id="3-C-随机数"><a href="#3-C-随机数" class="headerlink" title="3.C++ 随机数"></a>3.C++ 随机数</h1><p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 rand()，该函数只返回一个伪随机数。生成随机数之前必须先调用 srand() 函数。</p><p>下面是一个关于生成随机数的简单实例。实例中使用了 time() 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：<br>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;time.h&gt; /*用到了time函数，所以要有这个头文件*/</div><div class="line">#define MAX 10</div><div class="line"> </div><div class="line">int main( void)</div><div class="line">&#123;</div><div class="line">    int number[MAX] = &#123;0&#125;;</div><div class="line">    int i;</div><div class="line">    srand((unsigned) time(NULL)); /*播种子*/</div><div class="line">    for(i = 0; i &lt; MAX; i++)</div><div class="line">    &#123;</div><div class="line">        number[i] = rand() % 100; /*产生100以内的随机整数*/</div><div class="line">        printf(&quot;%d &quot;, number[i]);</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">36 32 0 2 45 89 48 73 93 79 </div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure><h1 id="4-关于“using-namespace-std”"><a href="#4-关于“using-namespace-std”" class="headerlink" title="4.关于“using namespace std”"></a>4.关于“using namespace std”</h1><p>　对于一个存在着标准输入输出的C++控制台程序，一般会在#include <iostream>的下一行发现一句话，using namespace std。这句话其实就表示了所有的标准库函数都在标准命名空间std中进行了定义。其作用就在于避免发生重命名的问题。<br>　　1. 关于namespace<br>　　C++引入了命名空间namespace主要解决了多个程序员在编写同一个项目中可能出现的函数等重名的现象。解决方法就是加上自己的命名空间。比如下面的例子：</iostream></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">namespace ZhangSan</div><div class="line">&#123;</div><div class="line">    int a=10; //张三把10赋值给了变量a</div><div class="line">&#125;</div><div class="line">namespace LiSi</div><div class="line">&#123;</div><div class="line">    int a=5; //李四把10赋值给了变量a</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">    int a=1;</div><div class="line">    cout&lt;&lt;&quot;张三定义的a=&quot;&lt;&lt;ZhangSan::a&lt;&lt;endl;</div><div class="line">    cout&lt;&lt;&quot;李四定义的a=&quot;&lt;&lt;LiSi::a&lt;&lt;endl;</div><div class="line">    cout&lt;&lt;&quot;主函数定义的a=&quot;&lt;&lt;a&lt;&lt;endl;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">张三定义的a=10</div><div class="line">李四定义的a=5</div><div class="line">主函数定义的a=1</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure></p><p>　　上例中的“ZhangSan::a”和“LiSi::a”分别表示了调用张三命名空间中的a变量和李四命名空间中的a变量。这样的好处显而易见，那就是虽然张三和李四这两个程序员都定义了一个变量a，但是并不会出现重名的危险。</p><h1 id="5-include-lt-iostream-gt-和-include-lt-iostream-h-gt-的区别"><a href="#5-include-lt-iostream-gt-和-include-lt-iostream-h-gt-的区别" class="headerlink" title="5.#include&lt;iostream&gt;和#include&lt;iostream.h&gt;的区别"></a>5.<code>#include&lt;iostream&gt;</code>和<code>#include&lt;iostream.h&gt;</code>的区别</h1><p>　　区别在于：如果用了isotream则一定要引入命名空间，即”using namespace std;<br>　　<br>    　　如果用了iostream.h，则不能引入命名空间，否则会引起编译错误，提示找不到命名空间. </p><p>例程如下：</p><p>情况一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//情况一：使用&lt;iostream&gt;和命名空间 </div><div class="line"> #include  &lt;iostream&gt; </div><div class="line"> using  namespace  std; </div><div class="line"> int main() </div><div class="line"> &#123; </div><div class="line">    cout&lt;&lt;&quot;&lt;iostream&gt;  need  to  use  namespace  std!\n&quot;; </div><div class="line">    return  0; </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;iostream&gt;  need  to  use  namespace  std! </div><div class="line"> Press  any  key  to  continue</div></pre></td></tr></table></figure></p><p>情况二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//情况二：使用&lt;iostream.h&gt;，不引入命名空间 </div><div class="line">  #include  &lt;iostream.h&gt; </div><div class="line">  //using  namespace  std; </div><div class="line">  int  main() </div><div class="line">  &#123; </div><div class="line">      cout&lt;&lt;&quot;&lt;iostream&gt;  need  to  use  namespace  std!\n&quot;; </div><div class="line">      return  0; </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;iostream&gt;  need  to  use  namespace  std! </div><div class="line"> Press  any  key  to  continue</div></pre></td></tr></table></figure></p><p>情况三：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//情况三：使用&lt;iostream.h&gt;，引入命名空间，这时候编译出错 </div><div class="line">#include  &lt;iostream.h&gt; </div><div class="line">using  namespace  std; </div><div class="line">int  main() </div><div class="line">&#123; </div><div class="line">   cout&lt;&lt;&quot;&lt;iostream&gt;  need  to  use  namespace  std!\n&quot;; </div><div class="line">   return  0; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>编译错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  error  C2871:  &apos;std&apos;  :  does  not  exist  or  is  not  a  namespace </div><div class="line">```    　　</div><div class="line"></div><div class="line">　　转自：http://blog.csdn.net/jzjwonderful/article/details/47866773</div><div class="line">　　</div><div class="line"></div><div class="line"></div><div class="line"># 6.C++ 数组</div><div class="line"></div><div class="line"></div><div class="line">C++ 支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</div></pre></td></tr></table></figure><p>#include <iostream><br>using namespace std;</iostream></p><p>#include <iomanip><br>/<em>主要是对cin,cout之类的一些操纵运算子，比如setfill,setw,setbase,setprecision等等。它是I/O流控制头文</em>/</iomanip></p><p>using std::setw;    /<em> setw(n) 设域宽为n个字符 </em>/</p><p>int main ()<br>{<br>   int n[ 10 ]; // n 是一个包含 10 个整数的数组</p><p>   // 初始化数组元素<br>   for ( int i = 0; i &lt; 10; i++ )<br>   {<br>      n[ i ] = i + 100; // 设置元素 i 为 i + 100<br>   }<br>   cout &lt;&lt; “Element” &lt;&lt; setw( 13 ) &lt;&lt; “Value” &lt;&lt; endl;</p><p>   // 输出数组中每个元素的值<br>   for ( int j = 0; j &lt; 10; j++ )<br>   {<br>      cout &lt;&lt; setw( 7 )&lt;&lt; j &lt;&lt; setw( 13 ) &lt;&lt; n[ j ] &lt;&lt; endl;<br>   }</p><p>   return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出：</div></pre></td></tr></table></figure></p><p>正在启动：/home/kuo/projects/test/build/test<br>Element        Value<br>      0          100<br>      1          101<br>      2          102<br>      3          103<br>      4          104<br>      5          105<br>      6          106<br>      7          107<br>      8          108<br>      9          109<br><strong><em> 正常退出 </em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## ６.1 C++ 多维数组</div></pre></td></tr></table></figure></p><p>#include <iostream><br>using namespace std;</iostream></p><p>int main ()<br>{<br>   // 一个带有 5 行 2 列的数组<br>   int a[5][2] = { {0,0}, {1,2}, {2,4}, {3,6},{4,8}};</p><p>   // 输出数组中每个元素的值<br>   for ( int i = 0; i &lt; 5; i++ )<br>      for ( int j = 0; j &lt; 2; j++ )<br>      {<br>         cout &lt;&lt; “a[“ &lt;&lt; i &lt;&lt; “][“ &lt;&lt; j &lt;&lt; “]: “;<br>         cout &lt;&lt; a[i][j]&lt;&lt; endl;<br>      }</p><p>   return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">输出：</div><div class="line">```c++</div><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">a[0][0]: 0</div><div class="line">a[0][1]: 0</div><div class="line">a[1][0]: 1</div><div class="line">a[1][1]: 2</div><div class="line">a[2][0]: 2</div><div class="line">a[2][1]: 4</div><div class="line">a[3][0]: 3</div><div class="line">a[3][1]: 6</div><div class="line">a[4][0]: 4</div><div class="line">a[4][1]: 8</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure></p><h2 id="6-2-C-指向数组的指针"><a href="#6-2-C-指向数组的指针" class="headerlink" title="6.2 C++ 指向数组的指针"></a>6.2 C++ 指向数组的指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   // 带有 5 个元素的整型数组</div><div class="line">   double balance[5] = &#123;1000.0, 2.0, 3.4, 17.0, 50.0&#125;;</div><div class="line">   double *p;  /*double *[p] 的意思是定义双精度指针变量p */</div><div class="line"></div><div class="line">   p = balance;    /*因为balance既是数组变量，也是指向数组第0个元素的指针变量*/</div><div class="line"> </div><div class="line">   // 输出数组中每个元素的值</div><div class="line">   cout &lt;&lt; &quot;使用指针的数组值 &quot; &lt;&lt; endl; </div><div class="line">   for ( int i = 0; i &lt; 5; i++ )</div><div class="line">   &#123;</div><div class="line">       cout &lt;&lt; &quot;*(p + &quot; &lt;&lt; i &lt;&lt; &quot;) : &quot;;</div><div class="line">       cout &lt;&lt; *(p + i) &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   cout &lt;&lt; &quot;使用 balance 作为地址的数组值 &quot; &lt;&lt; endl;</div><div class="line">   for ( int i = 0; i &lt; 5; i++ )</div><div class="line">   &#123;</div><div class="line">       cout &lt;&lt; &quot;*(balance + &quot; &lt;&lt; i &lt;&lt; &quot;) : &quot;;</div><div class="line">       cout &lt;&lt; *(balance + i) &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">使用指针的数组值 </div><div class="line">*(p + 0) : 1000</div><div class="line">*(p + 1) : 2</div><div class="line">*(p + 2) : 3.4</div><div class="line">*(p + 3) : 17</div><div class="line">*(p + 4) : 50</div><div class="line">使用 balance 作为地址的数组值 </div><div class="line">*(balance + 0) : 1000</div><div class="line">*(balance + 1) : 2</div><div class="line">*(balance + 2) : 3.4</div><div class="line">*(balance + 3) : 17</div><div class="line">*(balance + 4) : 50</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure></p><h2 id="6-3-C-传递数组给函数"><a href="#6-3-C-传递数组给函数" class="headerlink" title="6.3 C++ 传递数组给函数"></a>6.3 C++ 传递数组给函数</h2><p>C++ 不允许向函数传递一个完整的数组作为参数，但是，您可以通过指定不带索引的数组名来传递一个指向数组的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 函数声明</div><div class="line">double getAverage(int arr[], int size);</div><div class="line"></div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   // 带有 5 个元素的整型数组</div><div class="line">   int balance[5] = &#123;1000, 2, 3, 17, 50&#125;;</div><div class="line">   double avg;</div><div class="line"></div><div class="line">   // 传递一个指向数组的指针作为参数</div><div class="line">   avg = getAverage( balance, 5 ) ;</div><div class="line"> </div><div class="line">   // 输出返回值</div><div class="line">   cout &lt;&lt; &quot;平均值是：&quot; &lt;&lt; avg &lt;&lt; endl; </div><div class="line">    </div><div class="line">   return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//子函数：应用于求数组的指定元素的平均值；</div><div class="line">double getAverage(int arr[], int size)//传递数组的首地址和个数</div><div class="line">//还可以以这样的形式：void myFunction(int *param)</div><div class="line">&#123;</div><div class="line">  int    i, sum = 0;       </div><div class="line">  double avg;          </div><div class="line"></div><div class="line">  for (i = 0; i &lt; size; ++i)</div><div class="line">  &#123;</div><div class="line">    sum += arr[i];</div><div class="line">   &#125;</div><div class="line"></div><div class="line">  avg = double(sum) / size;</div><div class="line"></div><div class="line">  return avg;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">平均值是：214.4</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure></p><h2 id="6-4-C-从函数返回数组"><a href="#6-4-C-从函数返回数组" class="headerlink" title="6.4 C++ 从函数返回数组"></a>6.4 C++ 从函数返回数组</h2><p>C++ 不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。</p><p>如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int * myFunction()</div><div class="line">&#123;</div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>另外，C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。</p><p>现在，让我们来看下面的函数，它会生成 10 个随机数，并使用数组来返回它们，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;ctime&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 要生成和返回随机数的函数</div><div class="line">int * getRandom( )/*如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数*/</div><div class="line">&#123;</div><div class="line">  static int  r[10];/*C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。*/</div><div class="line"> </div><div class="line">  // 设置种子</div><div class="line">  srand( (unsigned)time( NULL ) );</div><div class="line">  for (int i = 0; i &lt; 10; ++i)</div><div class="line">  &#123;</div><div class="line">    r[i] = rand();</div><div class="line">    cout &lt;&lt; r[i] &lt;&lt; endl;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  return r;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 要调用上面定义函数的主函数</div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   // 一个指向整数的指针</div><div class="line">   int *p;</div><div class="line"> </div><div class="line">   p = getRandom();</div><div class="line">   for ( int i = 0; i &lt; 10; i++ )</div><div class="line">   &#123;</div><div class="line">       cout &lt;&lt; &quot;*(p + &quot; &lt;&lt; i &lt;&lt; &quot;) : &quot;;</div><div class="line">       cout &lt;&lt; *(p + i) &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">1643684660</div><div class="line">555897083</div><div class="line">1283025333</div><div class="line">67400210</div><div class="line">154404676</div><div class="line">2092591326</div><div class="line">1876825200</div><div class="line">1608593253</div><div class="line">1393148894</div><div class="line">621522198</div><div class="line">*(p + 0) : 1643684660</div><div class="line">*(p + 1) : 555897083</div><div class="line">*(p + 2) : 1283025333</div><div class="line">*(p + 3) : 67400210</div><div class="line">*(p + 4) : 154404676</div><div class="line">*(p + 5) : 2092591326</div><div class="line">*(p + 6) : 1876825200</div><div class="line">*(p + 7) : 1608593253</div><div class="line">*(p + 8) : 1393148894</div><div class="line">*(p + 9) : 621522198</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure></p><h1 id="7-C-字符串"><a href="#7-C-字符串" class="headerlink" title="7.C++ 字符串"></a>7.C++ 字符串</h1><p>C++ 提供了以下两种类型的字符串表示形式：</p><pre><code>C 风格字符串C++ 引入的 string 类类型</code></pre><h2 id="7-1-C-风格字符串"><a href="#7-1-C-风格字符串" class="headerlink" title="7.1 C 风格字符串"></a>7.1 C 风格字符串</h2><p>C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   char str1[11] = &quot;Hello&quot;;</div><div class="line">   char str2[11] = &quot;World&quot;;</div><div class="line">   char str3[11];</div><div class="line">   int  len ;</div><div class="line"> </div><div class="line">   // 复制 str1 到 str3</div><div class="line">   strcpy( str3, str1);</div><div class="line">   cout &lt;&lt; &quot;strcpy( str3, str1) : &quot; &lt;&lt; str3 &lt;&lt; endl;</div><div class="line"> </div><div class="line">   // 连接 str1 和 str2</div><div class="line">   strcat( str1, str2);</div><div class="line">   cout &lt;&lt; &quot;strcat( str1, str2): &quot; &lt;&lt; str1 &lt;&lt; endl;</div><div class="line"> </div><div class="line">   // 连接后，str1 的总长度</div><div class="line">   len = strlen(str1);</div><div class="line">   cout &lt;&lt; &quot;strlen(str1) : &quot; &lt;&lt; len &lt;&lt; endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">strcpy( str3, str1) : Hello</div><div class="line">strcat( str1, str2): HelloWorld</div><div class="line">strlen(str1) : 10</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure><p>其他：<br>|—|—|—|<br>| - - -  |  : - - - : |  - - -  |<br>| 4    | strcmp(s1,s2); |如果 s1 和 s2 是相同的，则返回 0；如果 s1 &lt; s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。 |<br>| 5     | strchr(s1, ch); | 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |<br>|6    | strstr(s1, s2); |返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。|</p><h2 id="7-2-C-中的-String-类"><a href="#7-2-C-中的-String-类" class="headerlink" title="7.2 C++ 中的 String 类"></a>7.2 C++ 中的 String 类</h2><p>C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    //定义一个string类对象</div><div class="line">    string http = &quot;www.runoob.com&quot;;</div><div class="line"></div><div class="line">   //打印字符串长度</div><div class="line">   cout&lt;&lt;http.length()&lt;&lt;endl;</div><div class="line"></div><div class="line">    //拼接</div><div class="line">    http.append(&quot;/C++&quot;);</div><div class="line">    cout&lt;&lt;http&lt;&lt;endl; //打印结果为：www.runoob.com/C++</div><div class="line"></div><div class="line">    //删除</div><div class="line">    int pos = http.find(&quot;/C++&quot;); //查找&quot;C++&quot;在字符串中的位置</div><div class="line">    cout&lt;&lt;pos&lt;&lt;endl;</div><div class="line">    http.replace(pos, 4, &quot;&quot;);   //从位置pos开始，之后的4个字符替换为空，即删除</div><div class="line">    cout&lt;&lt;http&lt;&lt;endl;</div><div class="line"></div><div class="line">    //找子串runoob</div><div class="line">    int first = http.find_first_of(&quot;.&quot;); //从头开始寻找字符&apos;.&apos;的位置</div><div class="line">    int last = http.find_last_of(&quot;.&quot;);   //从尾开始寻找字符&apos;.&apos;的位置</div><div class="line">    cout&lt;&lt;http.substr(first+1, last-first-1)&lt;&lt;endl; //提取&quot;runoob&quot;子串并打印</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">14</div><div class="line">www.runoob.com/C++</div><div class="line">14</div><div class="line">www.runoob.com</div><div class="line">runoob</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure><p>转自：<a href="http://www.runoob.com/cplusplus/cpp-strings.html" target="_blank" rel="external">http://www.runoob.com/cplusplus/cpp-strings.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-C-指针运算符（-amp-和-）&quot;&gt;&lt;a href=&quot;#1-C-指针运算符（-amp-和-）&quot; class=&quot;headerlink&quot; title=&quot;1.C++ 指针运算符（&amp;amp; 和 *）&quot;&gt;&lt;/a&gt;1.C++ 指针运算符（&amp;amp; 和 *）&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>rosb笔记：bug时间：环境变量设置问题——“解决 roscd beginner_tutorials 没有此文件的问题”</title>
    <link href="http://yoursite.com/2017/11/13/ros/rosb%E7%AC%94%E8%AE%B0%EF%BC%9Abug%E6%97%B6%E9%97%B4%EF%BC%9A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E2%80%9C%E8%A7%A3%E5%86%B3%20roscd%20beginner_tutorials%20%E6%B2%A1%E6%9C%89%E6%AD%A4%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98%E2%80%9D/"/>
    <id>http://yoursite.com/2017/11/13/ros/rosb笔记：bug时间：环境变量设置问题——“解决 roscd beginner_tutorials 没有此文件的问题”/</id>
    <published>2017-11-13T13:08:08.000Z</published>
    <updated>2021-02-19T13:32:13.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bug时间：环境变量设置问题"><a href="#bug时间：环境变量设置问题" class="headerlink" title="bug时间：环境变量设置问题"></a>bug时间：环境变量设置问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">. ~/catkin_ws/devel/setup.bash</div></pre></td></tr></table></figure><p>解决 roscd beginner_tutorials 没有此文件的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ roscd beginner_tutorials</div><div class="line">roscd: No such package/stack &apos;beginner_tutorials&apos;</div><div class="line">kuo@kuo-Inspiron-7420:~$ . ~/catkin_ws/devel/setup.bash</div><div class="line">kuo@kuo-Inspiron-7420:~$ roscd beginner_tutorials</div><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/src/beginner_tutorials$</div></pre></td></tr></table></figure></p><h1 id="2-解决："><a href="#2-解决：" class="headerlink" title="2.解决："></a>2.解决：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ERROR] [1508416151.165397241]: [registerPublisher] Failed to contact master at [localhost:11311].  Retrying...</div></pre></td></tr></table></figure><p>问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">uo@kuo-Inspiron-7420:~$ rosrun beginner_tutorials add_two_ints_server</div><div class="line">[rospack] Error: package &apos;beginner_tutorials&apos; not found</div><div class="line">kuo@kuo-Inspiron-7420:~$ . ~/catkin_ws/devel/setup.bash</div><div class="line">kuo@kuo-Inspiron-7420:~$ rosrun beginner_tutorials add_two_ints_server</div><div class="line">[ERROR] [1508416151.165397241]: [registerPublisher] Failed to contact master at [localhost:11311].  Retrying...</div></pre></td></tr></table></figure></p><p>请检查 roscore 是否正常打开。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;bug时间：环境变量设置问题&quot;&gt;&lt;a href=&quot;#bug时间：环境变量设置问题&quot; class=&quot;headerlink&quot; title=&quot;bug时间：环境变量设置问题&quot;&gt;&lt;/a&gt;bug时间：环境变量设置问题&lt;/h2&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="ros" scheme="http://yoursite.com/categories/ros/"/>
    
    
      <category term="ros" scheme="http://yoursite.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>ROS笔记：（7）其他</title>
    <link href="http://yoursite.com/2017/11/13/ros/ROS%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%887%EF%BC%89%E5%85%B6%E4%BB%96/"/>
    <id>http://yoursite.com/2017/11/13/ros/ROS笔记：（7）其他/</id>
    <published>2017-11-13T13:08:07.000Z</published>
    <updated>2021-02-19T13:32:13.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-编写简单的消息发布器和订阅器-C"><a href="#7-编写简单的消息发布器和订阅器-C" class="headerlink" title="7.编写简单的消息发布器和订阅器 (C++)"></a>7.<a href="http://wiki.ros.org/cn/ROS/Tutorials/WritingPublisherSubscriber%28c++%29" target="_blank" rel="external">编写简单的消息发布器和订阅器 (C++)</a></h2><p>本教程将介绍如何用 C++ 编写发布器节点和订阅器节点。</p><h2 id="8-写一个简单的消息发布器和订阅器-Python"><a href="#8-写一个简单的消息发布器和订阅器-Python" class="headerlink" title="8.写一个简单的消息发布器和订阅器 (Python)"></a>8.<a href="http://wiki.ros.org/cn/ROS/Tutorials/WritingPublisherSubscriber%28python%29" target="_blank" rel="external">写一个简单的消息发布器和订阅器 (Python)</a></h2><p>本教程将通过Python编写一个发布器节点和订阅器节点。</p><h2 id="9-测试消息发布器和订阅器"><a href="#9-测试消息发布器和订阅器" class="headerlink" title="9.测试消息发布器和订阅器"></a>9.<a href="http://wiki.ros.org/cn/ROS/Tutorials/ExaminingPublisherSubscriber" target="_blank" rel="external">测试消息发布器和订阅器</a></h2><p>本教程将测试上一教程所写的消息发布器和订阅器。</p><h2 id="10-编写简单的服务器和客户端-C"><a href="#10-编写简单的服务器和客户端-C" class="headerlink" title="10.编写简单的服务器和客户端 (C++)"></a>10.<a href="http://wiki.ros.org/cn/ROS/Tutorials/WritingServiceClient%28c++%29" target="_blank" rel="external">编写简单的服务器和客户端 (C++)</a></h2><p>本教程介绍如何用 C++ 编写服务器 Service 和客户端 Client 节点。</p><h2 id="11-编写简单的Service和Client-Python"><a href="#11-编写简单的Service和Client-Python" class="headerlink" title="11.编写简单的Service和Client (Python)"></a>11.<a href="http://wiki.ros.org/cn/ROS/Tutorials/WritingServiceClient%28python%29" target="_blank" rel="external">编写简单的Service和Client (Python)</a></h2><p>本教程介绍如何用Python编写Service和Client节点。</p><h2 id="12-测试简单的Service和Client"><a href="#12-测试简单的Service和Client" class="headerlink" title="12.测试简单的Service和Client"></a>12.<a href="http://wiki.ros.org/cn/ROS/Tutorials/ExaminingServiceClient" target="_blank" rel="external">测试简单的Service和Client</a></h2><p>本教程将测试之前所写的Service和Client。</p><h2 id="13-录制与回放数据"><a href="#13-录制与回放数据" class="headerlink" title="13.录制与回放数据"></a>13.<a href="http://wiki.ros.org/cn/ROS/Tutorials/Recording%20and%20playing%20back%20data" target="_blank" rel="external">录制与回放数据</a></h2><p>本教程将教你如何将ROS系统运行过程中的数据录制到一个.bag文件中，然后通过回放数据来重现相似的运行过程。</p><h2 id="14-roswtf入门"><a href="#14-roswtf入门" class="headerlink" title="14.roswtf入门"></a>14.<a href="http://wiki.ros.org/cn/ROS/Tutorials/Getting%20started%20with%20roswtf" target="_blank" rel="external">roswtf入门</a></h2><p>本教程介绍了roswtf工具的基本使用方法。</p><h2 id="15-探索ROS维基"><a href="#15-探索ROS维基" class="headerlink" title="15.探索ROS维基"></a>15.<a href="http://wiki.ros.org/cn/ROS/Tutorials/NavigatingTheWiki" target="_blank" rel="external">探索ROS维基</a></h2><p>本教程介绍了ROS维基(wiki.ros.org)的组织结构以及使用方法。同时讲解了如何才能从ROS维基中找到你需要的信息。</p><h2 id="16-接下来做什么？"><a href="#16-接下来做什么？" class="headerlink" title="16.接下来做什么？"></a>16.<a href="http://wiki.ros.org/cn/ROS/Tutorials/WhereNext" target="_blank" rel="external">接下来做什么？</a></h2><p>本教程将讨论获取更多知识的途径，以帮助你更好地使用ROS搭建真实或虚拟机器人。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;7-编写简单的消息发布器和订阅器-C&quot;&gt;&lt;a href=&quot;#7-编写简单的消息发布器和订阅器-C&quot; class=&quot;headerlink&quot; title=&quot;7.编写简单的消息发布器和订阅器 (C++)&quot;&gt;&lt;/a&gt;7.&lt;a href=&quot;http://wiki.ros.o
      
    
    </summary>
    
      <category term="ros" scheme="http://yoursite.com/categories/ros/"/>
    
    
      <category term="ros" scheme="http://yoursite.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>ros笔记：（6）使用rosed编辑ROS中的文件</title>
    <link href="http://yoursite.com/2017/11/13/ros/ros%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%886%EF%BC%89%E4%BD%BF%E7%94%A8rosed%E7%BC%96%E8%BE%91ROS%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/11/13/ros/ros笔记：（6）使用rosed编辑ROS中的文件/</id>
    <published>2017-11-13T13:08:06.000Z</published>
    <updated>2021-02-19T13:32:13.174Z</updated>
    
    <content type="html"><![CDATA[<p>Description: 本教程将展示如何使用rosed来简化编辑过程。</p><h2 id="使用-rosed"><a href="#使用-rosed" class="headerlink" title="使用 rosed"></a>使用 rosed</h2><p>rosed 是 rosbash 的一部分。利用它可以直接通过package名来获取到待编辑的文件而无需指定该文件的存储路径了。</p><p>使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosed [package_name] [filename]</div></pre></td></tr></table></figure></p><p>例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosed roscpp Logger.msg</div></pre></td></tr></table></figure></p><p>这个实例展示了如何编辑roscpp package里的Logger.msg文件。</p><p>如果该实例没有运行成功，那么很有可能是你没有安装vim编辑器。请参考编辑器部分进行设置。</p><p>如果文件名在package里不是唯一的，那么会呈现出一个列表，让你选择编辑哪一个文件。</p><h2 id="使用Tab键补全文件名"><a href="#使用Tab键补全文件名" class="headerlink" title="使用Tab键补全文件名"></a>使用Tab键补全文件名</h2><p>使用这个方法，在不知道准确文件名的情况下，你也可以看到并选择你所要编辑的文件。</p><p>使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosed [package_name] &lt;tab&gt;</div></pre></td></tr></table></figure></p><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>rosed默认的编辑器是vim。如果想要将其他的编辑器设置成默认的，你需要修改你的 ~/.bashrc 文件，增加如下语句:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export EDITOR=&apos;gedit&apos;</div></pre></td></tr></table></figure></p><p>这将gedit设置成为默认编辑器。</p><p>注意: .bashrc文件的改变，只会在新的终端才有效。已经打开的终端不受环境变量的影响。</p><p>打开一个新的终端，看看那是否定义了EDITOR:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ echo $EDITOR</div><div class="line"></div><div class="line">    emacs -nw</div></pre></td></tr></table></figure></p><p>现在你已经成功设置并使用了rosed，接下来我们将学习创建ROS消息和ROS服务. </p><p>转自：<a href="http://wiki.ros.org/cn/ROS/Tutorials/UsingRosEd#Editor" target="_blank" rel="external">http://wiki.ros.org/cn/ROS/Tutorials/UsingRosEd#Editor</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Description: 本教程将展示如何使用rosed来简化编辑过程。&lt;/p&gt;
&lt;h2 id=&quot;使用-rosed&quot;&gt;&lt;a href=&quot;#使用-rosed&quot; class=&quot;headerlink&quot; title=&quot;使用 rosed&quot;&gt;&lt;/a&gt;使用 rosed&lt;/h2&gt;&lt;p&gt;ro
      
    
    </summary>
    
      <category term="ros" scheme="http://yoursite.com/categories/ros/"/>
    
    
      <category term="ros" scheme="http://yoursite.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>ros笔记：（5）使用 rqt_console 和 roslaunch</title>
    <link href="http://yoursite.com/2017/11/13/ros/ros%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%885%EF%BC%89%E4%BD%BF%E7%94%A8%20rqt_console%20%E5%92%8C%20roslaunch/"/>
    <id>http://yoursite.com/2017/11/13/ros/ros笔记：（5）使用 rqt_console 和 roslaunch/</id>
    <published>2017-11-13T13:08:05.000Z</published>
    <updated>2021-02-19T13:32:13.172Z</updated>
    
    <content type="html"><![CDATA[<p>Description: 本教程介绍如何使用rqt_console和rqt_logger_level进行调试，以及如何使用roslaunch同时运行多个节点。</p><h2 id="预先安装rqt和turtlesim程序包"><a href="#预先安装rqt和turtlesim程序包" class="headerlink" title="预先安装rqt和turtlesim程序包"></a>预先安装rqt和turtlesim程序包</h2><p>本教程会用到rqt 和 turtlesim这两个程序包，如果你没有安装，请先安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install ros-&lt;distro&gt;-rqt ros-&lt;distro&gt;-rqt-common-plugins ros-&lt;distro&gt;-turtlesim</div></pre></td></tr></table></figure></p><p>请使用ROS发行版名称(比如 electric、fuerte、groovy、hydro或最新的indigo)替换掉<distro>。</distro></p><p>注意： 你可能已经在之前的某篇教程中编译过rqt和turtlesim，如果你不确定的话重新编译一次也没事。</p><h2 id="使用rqt-console和rqt-logger-level"><a href="#使用rqt-console和rqt-logger-level" class="headerlink" title="使用rqt_console和rqt_logger_level"></a>使用rqt_console和rqt_logger_level</h2><p>rqt_console属于ROS日志框架(logging framework)的一部分，用来显示节点的输出信息。rqt_logger_level允许我们修改节点运行时输出信息的日志等级（logger levels）（包括 DEBUG、WARN、INFO和ERROR）。</p><p>现在让我们来看一下turtlesim在rqt_console中的输出信息，同时在rqt_logger_level中修改日志等级。在启动turtlesim之前先在另外两个新终端中运行rqt_console和rqt_logger_level：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun rqt_console rqt_console</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun rqt_logger_level rqt_logger_level</div></pre></td></tr></table></figure><p>你会看到弹出两个窗口：</p><p><img src="http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch?action=AttachFile&amp;do=get&amp;target=rqt_console%28start%29.png" alt="这里写图片描述"></p><p><img src="http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch?action=AttachFile&amp;do=get&amp;target=rqt_logger_level.png" alt="这里写图片描述"></p><p>现在让我们在一个新终端中启动turtlesim：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun turtlesim turtlesim_node</div></pre></td></tr></table></figure></p><p>因为默认日志等级是INFO，所以你会看到turtlesim启动后输出的所有信息，如下图所示：</p><p><img src="http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch?action=AttachFile&amp;do=get&amp;target=rqt_console%28turtlesimstart%29.png" alt="这里写图片描述"></p><p>现在让我们刷新一下rqt_logger_level窗口并选择Warn将日志等级修改为WARN，如下图所示：</p><p><img src="http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch?action=AttachFile&amp;do=get&amp;target=rqt_logger_level%28error%29.png" alt="这里写图片描述"></p><p>现在我们让turtle动起来并观察rqt_console中的输出<br>hydro版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- &apos;[2.0, 0.0, 0.0]&apos; &apos;[0.0, 0.0, 0.0]&apos;</div></pre></td></tr></table></figure></p><p><img src="http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch?action=AttachFile&amp;do=get&amp;target=rqt_console%28turtlesimerror%29.png" alt="这里写图片描述"></p><h3 id="日志等级说明"><a href="#日志等级说明" class="headerlink" title="日志等级说明"></a>日志等级说明</h3><p>日志等级按以下优先顺序排列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Fatal</div><div class="line">Error</div><div class="line">Warn</div><div class="line">Info</div><div class="line">Debug</div></pre></td></tr></table></figure></p><p>Fatal是最高优先级，Debug是最低优先级。通过设置日志等级你可以获取该等级及其以上优先等级的所有日志消息。比如，将日志等级设为Warn时，你会得到Warn、Error和Fatal这三个等级的所有日志消息。</p><p>现在让我们按Ctrl-C退出turtlesim节点，接下来我们将使用roslaunch来启动多个turtlesim节点和一个模仿节点以让一个turtlesim节点来模仿另一个turtlesim节点。</p><h3 id="使用roslaunch"><a href="#使用roslaunch" class="headerlink" title="使用roslaunch"></a>使用roslaunch</h3><p>roslaunch可以用来启动定义在launch文件中的多个节点。</p><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ roslaunch [package] [filename.launch]</div></pre></td></tr></table></figure></p><p>先切换到beginner_tutorials程序包目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ roscd beginner_tutorials</div></pre></td></tr></table></figure></p><p>如果roscd执行失败了，记得设置你当前终端下的ROS_PACKAGE_PATH环境变量，设置方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ export ROS_PACKAGE_PATH=~/&lt;distro&gt;_workspace/sandbox:$ROS_PACKAGE_PATH</div><div class="line">$ roscd beginner_tutorials</div></pre></td></tr></table></figure></p><p>如果你仍然无法找到beginner_tutorials程序包，说明该程序包还没有创建，那么请返回到ROS/Tutorials/CreatingPackage教程，并按照创建程序包的操作方法创建一个beginner_tutorials程序包。</p><p>然后创建一个launch文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir launch</div><div class="line">$ cd launch</div></pre></td></tr></table></figure></p><h3 id="Launch-文件"><a href="#Launch-文件" class="headerlink" title="Launch 文件"></a>Launch 文件</h3><p>现在我们来创建一个名为turtlemimic.launch的launch文件并复制粘贴以下内容到该文件里面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;launch&gt;</div><div class="line"></div><div class="line">  &lt;group ns=&quot;turtlesim1&quot;&gt;</div><div class="line">    &lt;node pkg=&quot;turtlesim&quot; name=&quot;sim&quot; type=&quot;turtlesim_node&quot;/&gt;</div><div class="line">  &lt;/group&gt;</div><div class="line"></div><div class="line">  &lt;group ns=&quot;turtlesim2&quot;&gt;</div><div class="line">    &lt;node pkg=&quot;turtlesim&quot; name=&quot;sim&quot; type=&quot;turtlesim_node&quot;/&gt;</div><div class="line">  &lt;/group&gt;</div><div class="line"></div><div class="line">  &lt;node pkg=&quot;turtlesim&quot; name=&quot;mimic&quot; type=&quot;mimic&quot;&gt;</div><div class="line">    &lt;remap from=&quot;input&quot; to=&quot;turtlesim1/turtle1&quot;/&gt;</div><div class="line">    &lt;remap from=&quot;output&quot; to=&quot;turtlesim2/turtle1&quot;/&gt;</div><div class="line">  &lt;/node&gt;</div><div class="line"></div><div class="line">&lt;/launch&gt;</div></pre></td></tr></table></figure><h3 id="Launch-文件解析"><a href="#Launch-文件解析" class="headerlink" title="Launch 文件解析"></a>Launch 文件解析</h3><p>现在我们开始逐句解析launch xml文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;launch&gt;</div></pre></td></tr></table></figure><p>在这里我们以launch标签开头以表明这是一个launch文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3   &lt;group ns=&quot;turtlesim1&quot;&gt;</div><div class="line">4     &lt;node pkg=&quot;turtlesim&quot; name=&quot;sim&quot; type=&quot;turtlesim_node&quot;/&gt;</div><div class="line">5   &lt;/group&gt;</div><div class="line">6 </div><div class="line">7   &lt;group ns=&quot;turtlesim2&quot;&gt;</div><div class="line">8     &lt;node pkg=&quot;turtlesim&quot; name=&quot;sim&quot; type=&quot;turtlesim_node&quot;/&gt;</div><div class="line">9   &lt;/group&gt;</div></pre></td></tr></table></figure><p>在这里我们创建了两个节点分组并以’命名空间（namespace)’标签来区分，其中一个名为turtulesim1，另一个名为turtlesim2，两个组里面都使用相同的turtlesim节点并命名为’sim’。这样可以让我们同时启动两个turtlesim模拟器而不会产生命名冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">11   &lt;node pkg=&quot;turtlesim&quot; name=&quot;mimic&quot; type=&quot;mimic&quot;&gt;</div><div class="line">12     &lt;remap from=&quot;input&quot; to=&quot;turtlesim1/turtle1&quot;/&gt;</div><div class="line">13     &lt;remap from=&quot;output&quot; to=&quot;turtlesim2/turtle1&quot;/&gt;</div><div class="line">14   &lt;/node&gt;</div></pre></td></tr></table></figure><p>在这里我们启动模仿节点，并将所有话题的输入和输出分别重命名为turtlesim1和turtlesim2，这样就会使turtlesim2模仿turtlesim1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">16 &lt;/launch&gt;</div></pre></td></tr></table></figure><p>这个是launch文件的结束标签。</p><h3 id="roslaunching"><a href="#roslaunching" class="headerlink" title="roslaunching"></a>roslaunching</h3><p>现在让我们通过roslaunch命令来启动launch文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ roslaunch beginner_tutorials turtlemimic.launch</div></pre></td></tr></table></figure></p><p>现在将会有两个turtlesims被启动，然后我们在一个新终端中使用rostopic命令发送速度设定消息：</p><p>hydro版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic pub /turtlesim1/turtle1/cmd_vel geometry_msgs/Twist -r 1 -- &apos;[2.0, 0.0, 0.0]&apos; &apos;[0.0, 0.0, -1.8]&apos;</div></pre></td></tr></table></figure></p><p>你会看到两个turtlesims会同时开始移动，虽然发布命令只是给turtlesim1发送了速度设定消息。</p><p><img src="http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch?action=AttachFile&amp;do=get&amp;target=mimic.png" alt="这里写图片描述"></p><p>我们也可以通过rqt_graph来更好的理解在launch文件中所做的事情。运行rqt并在主窗口中选择rqt_graph：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rqt</div></pre></td></tr></table></figure></p><p>或者直接运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rqt_graph</div></pre></td></tr></table></figure></p><p><img src="http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch?action=AttachFile&amp;do=get&amp;target=mimiclaunch.jpg" alt="这里写图片描述"></p><p>到此，我们算是已经学会了rqt_console和roslaunch命令的使用，接下来我们开始学习使用rosed——ROS中的编辑器。现在你可以按Ctrl-C退出所有turtlesims节点了，因为在下一篇教程中你不会再用到它们。 </p><p>转自：<a href="http://wiki.ros.org/cn/ROS/Tutorials/UsingRqtconsoleRoslaunch" target="_blank" rel="external">http://wiki.ros.org/cn/ROS/Tutorials/UsingRqtconsoleRoslaunch</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Description: 本教程介绍如何使用rqt_console和rqt_logger_level进行调试，以及如何使用roslaunch同时运行多个节点。&lt;/p&gt;
&lt;h2 id=&quot;预先安装rqt和turtlesim程序包&quot;&gt;&lt;a href=&quot;#预先安装rqt和turtl
      
    
    </summary>
    
      <category term="ros" scheme="http://yoursite.com/categories/ros/"/>
    
    
      <category term="ros" scheme="http://yoursite.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>ros：（4）理解ROS服务和参数</title>
    <link href="http://yoursite.com/2017/11/13/ros/ros%EF%BC%9A%EF%BC%884%EF%BC%89%E7%90%86%E8%A7%A3ROS%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2017/11/13/ros/ros：（4）理解ROS服务和参数/</id>
    <published>2017-11-13T13:08:02.000Z</published>
    <updated>2021-02-19T13:32:13.194Z</updated>
    
    <content type="html"><![CDATA[<p>Description: 本教程介绍了ROS 服务和参数的知识，以及命令行工具rosservice 和 rosparam的使用方法。</p><p>本教程假设从前一教程启动的turtlesim_node仍在运行，现在我们来看看turtlesim提供了什么服务：</p><h2 id="ROS-Services"><a href="#ROS-Services" class="headerlink" title="ROS Services"></a>ROS Services</h2><p>服务（services）是节点之间通讯的另一种方式。服务允许节点发送请求（request） 并获得一个响应（response）</p><h2 id="使用rosservice"><a href="#使用rosservice" class="headerlink" title="使用rosservice"></a>使用rosservice</h2><p>rosservice可以很轻松的使用 ROS 客户端/服务器框架提供的服务。rosservice提供了很多可以在topic上使用的命令，如下所示：</p><p>使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">rosservice list         输出可用服务的信息</div><div class="line">rosservice call         调用带参数的服务</div><div class="line">rosservice type         输出服务类型</div><div class="line">rosservice find         依据类型寻找服务find services by service type</div><div class="line">rosservice uri          输出服务的ROSRPC uri</div></pre></td></tr></table></figure></p><h3 id="rosservice-list"><a href="#rosservice-list" class="headerlink" title="rosservice list"></a>rosservice list</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosservice list</div></pre></td></tr></table></figure><p>list 命令显示turtlesim节点提供了9个服务：重置（reset）, 清除（clear）, 再生（spawn）, 终止（kill）, turtle1/set_pen, /turtle1/teleport_absolute, /turtle1/teleport_relative, turtlesim/get_loggers, and turtlesim/set_logger_level. 同时还有另外两个rosout节点提供的服务: /rosout/get_loggers and /rosout/set_logger_level.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/clear</div><div class="line">/kill</div><div class="line">/reset</div><div class="line">/rosout/get_loggers</div><div class="line">/rosout/set_logger_level</div><div class="line">/spawn</div><div class="line">/teleop_turtle/get_loggers</div><div class="line">/teleop_turtle/set_logger_level</div><div class="line">/turtle1/set_pen</div><div class="line">/turtle1/teleport_absolute</div><div class="line">/turtle1/teleport_relative</div><div class="line">/turtlesim/get_loggers</div><div class="line">/turtlesim/set_logger_level</div></pre></td></tr></table></figure></p><p>我们使用rosservice type命令更进一步查看clear服务:</p><h3 id="rosservice-type"><a href="#rosservice-type" class="headerlink" title="rosservice type"></a>rosservice type</h3><p>使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rosservice type [service]</div></pre></td></tr></table></figure></p><p>我们来看看clear服务的类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rosservice type clear</div><div class="line"></div><div class="line">std_srvs/Empty</div></pre></td></tr></table></figure></p><p>服务的类型为空（empty),这表明在调用这个服务是不需要参数（比如，请求不需要发送数据，响应也没有数据）。下面我们使用rosservice call命令调用服务：</p><h3 id="rosservice-call"><a href="#rosservice-call" class="headerlink" title="rosservice call"></a>rosservice call</h3><p>使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rosservice call [service] [args]</div></pre></td></tr></table></figure></p><p>因为服务类型是空，所以进行无参数调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosservice call clear</div></pre></td></tr></table></figure></p><p>正如我们所期待的，服务清除了turtlesim_node的背景上的轨迹。</p><p><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingServicesParams?action=AttachFile&amp;do=get&amp;target=turtlesim.png" alt="这里写图片描述"></p><p>通过查看再生（spawn）服务的信息，我们来了解带参数的服务:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ rosservice type spawn| rossrv show</div><div class="line"></div><div class="line">    float32 x</div><div class="line">    float32 y</div><div class="line">    float32 theta</div><div class="line">    string name</div><div class="line">    ---</div><div class="line">    string name</div></pre></td></tr></table></figure></p><p>这个服务使得我们可以在给定的位置和角度生成一只新的乌龟。名字参数是可选的，这里我们不设具体的名字，让turtlesim自动创建一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosservice call spawn 2 2 0.2 &quot;&quot;</div></pre></td></tr></table></figure></p><p>服务返回了新产生的乌龟的名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name: turtle2</div></pre></td></tr></table></figure></p><p>现在我们的乌龟看起来应该是像这样的：</p><p><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingServicesParams?action=AttachFile&amp;do=get&amp;target=turtle%28service%29.png" alt="这里写图片描述"></p><h2 id="Using-rosparam"><a href="#Using-rosparam" class="headerlink" title="Using rosparam"></a>Using rosparam</h2><p>rosparam使得我们能够存储并操作ROS 参数服务器（Parameter Server）上的数据。参数服务器能够存储整型、浮点、布尔、字符串、字典和列表等数据类型。rosparam使用YAML标记语言的语法。一般而言，YAML的表述很自然：1 是整型, 1.0 是浮点型, one是字符串, true是布尔, [1, 2, 3]是整型列表, {a: b, c: d}是字典. rosparam有很多指令可以用来操作参数，如下所示:</p><p>使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">rosparam set            设置参数</div><div class="line">rosparam get            获取参数</div><div class="line">rosparam load           从文件读取参数</div><div class="line">rosparam dump           向文件中写入参数</div><div class="line">rosparam delete         删除参数</div><div class="line">rosparam list           列出参数名</div></pre></td></tr></table></figure></p><p>我们来看看现在参数服务器上都有哪些参数：</p><h3 id="rosparam-list"><a href="#rosparam-list" class="headerlink" title="rosparam list"></a>rosparam list</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosparam list</div></pre></td></tr></table></figure><p>我们可以看到turtlesim节点在参数服务器上有3个参数用于设定背景颜色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/background_b</div><div class="line">/background_g</div><div class="line">/background_r</div><div class="line">/roslaunch/uris/aqy:51932</div><div class="line">/run_id</div></pre></td></tr></table></figure></p><p>Let’s change one of the parameter values using rosparam set:</p><h3 id="rosparam-set-and-rosparam-get"><a href="#rosparam-set-and-rosparam-get" class="headerlink" title="rosparam set and rosparam get"></a>rosparam set and rosparam get</h3><p>Usage:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rosparam set [param_name]</div><div class="line">rosparam get [param_name]</div></pre></td></tr></table></figure></p><p>现在我们修改背景颜色的红色通道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosparam set background_r 150</div></pre></td></tr></table></figure></p><p>上述指令修改了参数的值，现在我们调用清除服务使得修改后的参数生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosservice call clear</div></pre></td></tr></table></figure></p><p>现在 我们的小乌龟看起来应该是像这样：</p><p><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingServicesParams?action=AttachFile&amp;do=get&amp;target=turtle%28param%29.png" alt="这里写图片描述"></p><p>现在我们来查看参数服务器上的参数值——获取背景的绿色通道的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rosparam get background_g </div><div class="line"></div><div class="line">    86</div></pre></td></tr></table></figure></p><p>我们可以使用rosparam get /来显示参数服务器上的所有内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ rosparam get /</div><div class="line"></div><div class="line">    background_b: 255</div><div class="line">    background_g: 86</div><div class="line">    background_r: 150</div><div class="line">    roslaunch:</div><div class="line">      uris: &#123;&apos;aqy:51932&apos;: &apos;http://aqy:51932/&apos;&#125;</div><div class="line">    run_id: e07ea71e-98df-11de-8875-001b21201aa8</div></pre></td></tr></table></figure></p><p>你可能希望存储这些信息以备今后重新读取。这通过rosparam很容易就可以实现:</p><h3 id="rosparam-dump-and-rosparam-load"><a href="#rosparam-dump-and-rosparam-load" class="headerlink" title="rosparam dump and rosparam load"></a>rosparam dump and rosparam load</h3><p>使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rosparam dump [file_name]</div><div class="line">rosparam load [file_name] [namespace]</div></pre></td></tr></table></figure></p><p>现在我们将所有的参数写入params.yaml文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosparam dump params.yaml</div></pre></td></tr></table></figure></p><p>你甚至可以将yaml文件重载入新的命名空间，比如说copy空间:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ rosparam load params.yaml copy</div><div class="line">$ rosparam get copy/background_b</div><div class="line"></div><div class="line">    255</div></pre></td></tr></table></figure></p><p>至此，我们已经了解了ROS服务和参数服务器的使用，接下来，我们一同试试使用 rqt_console 和 roslaunch</p><p>转自：<a href="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingServicesParams" target="_blank" rel="external">http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingServicesParams</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Description: 本教程介绍了ROS 服务和参数的知识，以及命令行工具rosservice 和 rosparam的使用方法。&lt;/p&gt;
&lt;p&gt;本教程假设从前一教程启动的turtlesim_node仍在运行，现在我们来看看turtlesim提供了什么服务：&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="ros" scheme="http://yoursite.com/categories/ros/"/>
    
    
      <category term="ros" scheme="http://yoursite.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>ros：（3）ROS话题_『ROS Topics』『rqt_graph』『ROS Messages』『rqt_plot』</title>
    <link href="http://yoursite.com/2017/11/13/ros/ros%EF%BC%9A%EF%BC%883%EF%BC%89ROS%E8%AF%9D%E9%A2%98_%E3%80%8EROS%20Topics%E3%80%8F%E3%80%8Erqt_graph%E3%80%8F%E3%80%8EROS%20Messages%E3%80%8F%E3%80%8Erqt_plot%E3%80%8F/"/>
    <id>http://yoursite.com/2017/11/13/ros/ros：（3）ROS话题_『ROS Topics』『rqt_graph』『ROS Messages』『rqt_plot』/</id>
    <published>2017-11-13T13:08:01.000Z</published>
    <updated>2021-02-19T13:32:13.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-开始"><a href="#1-开始" class="headerlink" title="1.开始"></a>1.开始</h1><h2 id="1-1-roscore"><a href="#1-1-roscore" class="headerlink" title="1.1 roscore"></a>1.1 roscore</h2><p>首先确保roscore已经运行, 打开一个新的终端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ roscore</div></pre></td></tr></table></figure></p><h2 id="1-2turtlesim"><a href="#1-2turtlesim" class="headerlink" title="1.2turtlesim"></a>1.2turtlesim</h2><p>在本教程中我们也会使用到turtlesim，请在一个新的终端中运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun turtlesim turtlesim_node</div></pre></td></tr></table></figure></p><h2 id="1-3通过键盘远程控制turtle"><a href="#1-3通过键盘远程控制turtle" class="headerlink" title="1.3通过键盘远程控制turtle"></a>1.3通过键盘远程控制turtle</h2><p>我们也需要通过键盘来控制turtle的运动，请在一个新的终端中运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun turtlesim turtle_teleop_key</div></pre></td></tr></table></figure></p><h2 id="1-4使用-rqt-graph"><a href="#1-4使用-rqt-graph" class="headerlink" title="1.4使用 rqt_graph"></a>1.4使用 rqt_graph</h2><p>rqt_graph能够创建一个显示当前系统运行情况的动态图形。rqt_graph是rqt程序包中的一部分。如果你没有安装，请通过以下命令来安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install ros-indigo-rqt</div><div class="line">$ sudo apt-get install ros-indigo-rqt-common-plugins</div></pre></td></tr></table></figure></p><p>在一个新终端中运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun rqt_graph rqt_graph</div></pre></td></tr></table></figure></p><p>就会弹出<code>rqt_graph</code>窗口</p><p><img src="http://img.blog.csdn.net/20170927222157598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h1 id="2-『ROS-Topics』"><a href="#2-『ROS-Topics』" class="headerlink" title="2.『ROS Topics』"></a>2.『ROS Topics』</h1><p>如上图所示：<br>turtlesim_node节点和turtle_teleop_key节点之间是通过一个ROS话题来互相通信的。turtle_teleop_key在一个话题上发布按键输入消息，而turtlesim（这里是my_turtle）则订阅该话题以接收该消息。</p><h2 id="2-1-rostopic介绍"><a href="#2-1-rostopic介绍" class="headerlink" title="2.1.rostopic介绍"></a>2.1.rostopic介绍</h2><p>rostopic命令工具能让你获取有关ROS话题的信息。 </p><h3 id="2-1-1你可以使用帮助选项查看rostopic的子命令："><a href="#2-1-1你可以使用帮助选项查看rostopic的子命令：" class="headerlink" title="2.1.1你可以使用帮助选项查看rostopic的子命令："></a>2.1.1你可以使用帮助选项查看rostopic的子命令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic -h</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">rostopic bw     display bandwidth used by topic</div><div class="line">rostopic echo   print messages to screen</div><div class="line">rostopic hz     display publishing rate of topic</div><div class="line">rostopic list   print information about active topics</div><div class="line">rostopic pub    publish data to topic</div><div class="line">rostopic type   print topic type</div></pre></td></tr></table></figure><h3 id="2-1-2rostopic-echo可以显示在某个话题上发布的数据"><a href="#2-1-2rostopic-echo可以显示在某个话题上发布的数据" class="headerlink" title="2.1.2rostopic echo可以显示在某个话题上发布的数据"></a>2.1.2rostopic echo可以显示在某个话题上发布的数据</h3><p>让我们在一个新终端中看一下turtle_teleop_key节点在 /turtle1/cmd_vel话题上发布的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$rostopic echo /turtle1/cmd_vel</div></pre></td></tr></table></figure></p><p>你可能看不到任何东西因为现在还没有数据发布到该话题上。接下来我们通过按下方向键使turtle_teleop_key节点发布数据。记住如果turtle没有动起来的话就需要你重新选中turtle_teleop_key节点运行时所在的终端窗口。</p><p>现在当你按下向上方向键时应该会看到下面的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">linear: </div><div class="line">  x: 2.0</div><div class="line">  y: 0.0</div><div class="line">  z: 0.0</div><div class="line">angular: </div><div class="line">  x: 0.0</div><div class="line">  y: 0.0</div><div class="line">  z: 0.0</div><div class="line">---</div><div class="line">linear: </div><div class="line">  x: 0.0</div><div class="line">  y: 0.0</div><div class="line">  z: 0.0</div><div class="line">angular: </div><div class="line">  x: 0.0</div><div class="line">  y: 0.0</div><div class="line">  z: 2.0</div><div class="line">---</div><div class="line">linear: </div><div class="line">  x: 0.0</div><div class="line">  y: 0.0</div><div class="line">  z: 0.0</div><div class="line">angular: </div><div class="line">  x: 0.0</div><div class="line">  y: 0.0</div><div class="line">  z: -2.0</div><div class="line">---</div></pre></td></tr></table></figure></p><p>现在让我们再看一下rqt_graph（你可能需要刷新一下ROS graph）。正如你所看到的，rostopic echo(红色显示部分）现在也订阅了turtle1/command_velocity话题。 </p><p><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics?action=AttachFile&amp;do=get&amp;target=rqt_graph_echo.png" alt="这里写图片描述"></p><h2 id="2-1-3使用-rostopic-list"><a href="#2-1-3使用-rostopic-list" class="headerlink" title="2.1.3使用 rostopic list"></a>2.1.3使用 rostopic list</h2><p>rostopic list能够列出所有当前订阅和发布的话题。</p><p>让我们查看一下list子命令需要的参数，在一个新终端中运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ rostopic list -h</div><div class="line"></div><div class="line">    Usage: rostopic list [/topic]</div><div class="line"></div><div class="line">    Options:</div><div class="line">      -h, --help            show this help message and exit</div><div class="line">      -b BAGFILE, --bag=BAGFILE</div><div class="line">                            list topics in .bag file</div><div class="line">      -v, --verbose         list full details about each topic</div><div class="line">      -p                    list only publishers</div><div class="line">      -s                    list only subscribers</div></pre></td></tr></table></figure></p><p>在rostopic list中使用verbose选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic list -v</div></pre></td></tr></table></figure></p><p>这会显示出有关所发布和订阅的话题及其类型的详细信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Published topics:</div><div class="line"> * /turtle1/color_sensor [turtlesim/Color] 1 publisher</div><div class="line"> * /turtle1/command_velocity [turtlesim/Velocity] 1 publisher</div><div class="line"> * /rosout [roslib/Log] 2 publishers</div><div class="line"> * /rosout_agg [roslib/Log] 1 publisher</div><div class="line"> * /turtle1/pose [turtlesim/Pose] 1 publisher</div><div class="line"></div><div class="line">Subscribed topics:</div><div class="line"> * /turtle1/command_velocity [turtlesim/Velocity] 1 subscriber</div><div class="line"> * /rosout [roslib/Log] 1 subscriber</div></pre></td></tr></table></figure></p><h1 id="3-ROS-Messages"><a href="#3-ROS-Messages" class="headerlink" title="3.ROS Messages"></a>3.ROS Messages</h1><p>话题之间的通信是通过在节点之间发送ROS消息实现的。对于发布器(turtle_teleop_key)和订阅器(turtulesim_node)之间的通信，发布器和订阅器之间必须发送和接收相同类型的消息。这意味着话题的类型是由发布在它上面的消息类型决定的。使用rostopic type命令可以查看发布在某个话题上的消息类型。</p><h2 id="3-1使用-rostopic-type"><a href="#3-1使用-rostopic-type" class="headerlink" title="3.1使用 rostopic type"></a>3.1使用 rostopic type</h2><p>rostopic type 命令用来查看所发布话题的消息类型。</p><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rostopic type [topic]</div></pre></td></tr></table></figure></p><p>hydro版请运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic type /turtle1/cmd_vel</div></pre></td></tr></table></figure></p><pre><code>你应该会看到:</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">geometry_msgs/Twist</div></pre></td></tr></table></figure><p>我们可以使用rosmsg命令来查看消息的详细情况：</p><p>hydro版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosmsg show geometry_msgs/Twist</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">geometry_msgs/Vector3 linear</div><div class="line">  float64 x</div><div class="line">  float64 y</div><div class="line">  float64 z</div><div class="line">geometry_msgs/Vector3 angular</div><div class="line">  float64 x</div><div class="line">  float64 y</div><div class="line">  float64 z</div></pre></td></tr></table></figure><p>现在我们已经知道了turtlesim节点所期望的消息类型，接下来我们就可以给turtle发布命令了。</p><h1 id="4-继续学习-rostopic"><a href="#4-继续学习-rostopic" class="headerlink" title="4.继续学习 rostopic"></a>4.继续学习 rostopic</h1><p>现在我们已经了解了什么是ROS的消息，接下来我们开始结合消息来使用rostopic。</p><h2 id="4-1使用-rostopic-pub"><a href="#4-1使用-rostopic-pub" class="headerlink" title="4.1使用 rostopic pub"></a>4.1使用 rostopic pub</h2><p>rostopic pub可以把数据发布到当前某个正在广播的话题上。</p><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rostopic pub [topic] [msg_type] [args]</div></pre></td></tr></table></figure></p><p>示例（hydro版)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- &apos;[2.0, 0.0, 0.0]&apos; &apos;[0.0, 0.0, 1.8]&apos;</div></pre></td></tr></table></figure></p><p>以上命令会发送一条消息给turtlesim，告诉它以2.0大小的线速度和1.8大小的角速度开始移动。<br><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics?action=AttachFile&amp;do=get&amp;target=turtle%28rostopicpub%29.png" alt="这里写图片描述"><br>这是一个非常复杂的例子，因此让我们来详细分析一下其中的每一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rostopic pub</div></pre></td></tr></table></figure></p><pre><code>这条命令将会发布消息到某个给定的话题。 </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-1</div></pre></td></tr></table></figure><pre><code>（单个破折号）这个参数选项使rostopic发布一条消息后马上退出。 </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/turtle1/command_velocity</div></pre></td></tr></table></figure><pre><code>这是消息所发布到的话题名称。 </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">turtlesim/Velocity</div></pre></td></tr></table></figure><pre><code>这是所发布消息的类型。 </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--</div></pre></td></tr></table></figure><pre><code>（双破折号）这会告诉命令选项解析器接下来的参数部分都不是命令选项。这在参数里面包含有破折号-（比如负号）时是必须要添加的。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.0 1.8</div></pre></td></tr></table></figure><pre><code>正如之前提到的，在一个turtlesim/Velocity消息里面包含有两个浮点型元素：linear和angular。在本例中，2.0是linear的值，1.8是angular的值。这些参数其实是按照YAML语法格式编写的，这在YAML文档中有更多的描述。 </code></pre><p>你可能已经注意到turtle已经停止移动了。这是因为turtle需要一个稳定的频率为1Hz的命令流来保持移动状态。我们可以使用rostopic pub -r命令来发布一个稳定的命令流（非hydro版）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic pub /turtle1/command_velocity turtlesim/Velocity -r 1 -- 2.0  -1.8</div></pre></td></tr></table></figure></p><p>hydro版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- &apos;[2.0, 0.0, 0.0]&apos; &apos;[0.0, 0.0, 1.8]&apos;</div></pre></td></tr></table></figure></p><p>这条命令以1Hz的频率发布速度命令到速度话题上。</p><p>  <img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics?action=AttachFile&amp;do=get&amp;target=turtle%28rostopicpub%292.png" alt="这里写图片描述"></p><p>我们也可以看一下rqt_graph中的情形，可以看到rostopic发布器节点（红色）正在与rostopic echo节点（绿色）进行通信：</p><p><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics?action=AttachFile&amp;do=get&amp;target=rqt_graph_pub.png" alt="这里写图片描述"></p><p>正如你所看到的，turtle正沿着一个圆形轨迹连续运动。我们可以在一个新终端中通过rostopic echo命令来查看turtlesim所发布的数据。</p><h2 id="4-2使用-rostopic-hz"><a href="#4-2使用-rostopic-hz" class="headerlink" title="4.2使用 rostopic hz"></a>4.2使用 rostopic hz</h2><p>rostopic hz命令可以用来查看数据发布的频率。</p><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rostopic hz [topic]</div></pre></td></tr></table></figure></p><p>我们看一下turtlesim_node发布/turtle/pose时有多快：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic hz /turtle1/pose</div></pre></td></tr></table></figure></p><p>你会看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">subscribed to [/turtle1/pose]</div><div class="line">average rate: 59.354</div><div class="line">        min: 0.005s max: 0.027s std dev: 0.00284s window: 58</div><div class="line">average rate: 59.459</div><div class="line">        min: 0.005s max: 0.027s std dev: 0.00271s window: 118</div><div class="line">average rate: 59.539</div><div class="line">        min: 0.004s max: 0.030s std dev: 0.00339s window: 177</div><div class="line">average rate: 59.492</div><div class="line">        min: 0.004s max: 0.030s std dev: 0.00380s window: 237</div><div class="line">average rate: 59.463</div><div class="line">        min: 0.004s max: 0.030s std dev: 0.00380s window: 290</div></pre></td></tr></table></figure></p><p>现在我们可以知道了turtlesim正以大约60Hz的频率发布数据给turtle。我们也可以结合rostopic type和rosmsg show命令来获取关于某个话题的更深层次的信息（非hydro版）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic type /turtle1/command_velocity | rosmsg show</div></pre></td></tr></table></figure></p><p>hydro版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rostopic type /turtle1/cmd_vel | rosmsg show</div></pre></td></tr></table></figure></p><p>到此我们已经完成了通过rostopic来查看话题相关情况的过程，接下来我将使用另一个工具来查看turtlesim发布的数据。</p><h1 id="5-使用-rqt-plot"><a href="#5-使用-rqt-plot" class="headerlink" title="5.使用 rqt_plot"></a>5.使用 rqt_plot</h1><p>注意：如果你使用的是electric或更早期的ROS版本，那么rqt命令是不可用的，请使用rxplot命令来代替。</p><p>rqt_plot命令可以实时显示一个发布到某个话题上的数据变化图形。这里我们将使用rqt_plot命令来绘制正在发布到/turtle1/pose话题上的数据变化图形。首先，在一个新终端中运行rqt_plot命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun rqt_plot rqt_plot</div></pre></td></tr></table></figure></p><p>这会弹出一个新窗口，在窗口左上角的一个文本框里面你可以添加需要绘制的话题。在里面输入/turtle1/pose/x后之前处于禁用状态的加号按钮将会被使能变亮。按一下该按钮，并对/turtle1/pose/y重复相同的过程。现在你会在图形中看到turtle的x-y位置坐标图。</p><p><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics?action=AttachFile&amp;do=get&amp;target=rqt_plot.png" alt="这里写图片描述"></p><p>按下减号按钮会显示一组菜单让你隐藏图形中指定的话题。现在隐藏掉你刚才添加的话题并添加/turtle1/pose/theta，你会看到如下图所示的图形：<br><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics?action=AttachFile&amp;do=get&amp;target=rqt_plot2.png" alt="这里写图片描述"><br>本部分教程到此为止，请使用Ctrl-C退出rostopic命令，但要保持turtlesim继续运行。</p><p>到此我们已经理解了ROS话题是如何工作的，接下来我们开始学习理解ROS服务和参数。 </p><p>来自：<br><a href="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics" target="_blank" rel="external">理解ROS话题</a><br>本教程介绍ROS话题（topics）以及如何使用rostopic 和 rqt_plot 命令行工具。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-开始&quot;&gt;&lt;a href=&quot;#1-开始&quot; class=&quot;headerlink&quot; title=&quot;1.开始&quot;&gt;&lt;/a&gt;1.开始&lt;/h1&gt;&lt;h2 id=&quot;1-1-roscore&quot;&gt;&lt;a href=&quot;#1-1-roscore&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="ros" scheme="http://yoursite.com/categories/ros/"/>
    
    
      <category term="ros" scheme="http://yoursite.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>ros：（2）ros节点</title>
    <link href="http://yoursite.com/2017/11/13/ros/ros%EF%BC%9A%EF%BC%882%EF%BC%89ros%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2017/11/13/ros/ros：（2）ros节点/</id>
    <published>2017-11-13T13:08:00.000Z</published>
    <updated>2021-02-19T13:32:13.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图概念概述"><a href="#图概念概述" class="headerlink" title="图概念概述"></a>图概念概述</h1><pre><code>Nodes:节点,一个节点即为一个可执行文件，它可以通过ROS与其它节点进行通信。Messages:消息，消息是一种ROS数据类型，用于订阅或发布到一个话题。Topics:话题,节点可以发布消息到话题，也可以订阅话题以接收消息。Master:节点管理器，ROS名称服务 (比如帮助节点找到彼此)。rosout: ROS中相当于stdout/stderr。roscore: 主机+ rosout + 参数服务器 (参数服务器会在后面介绍)。 </code></pre><h1 id="1-roscore"><a href="#1-roscore" class="headerlink" title="1.roscore"></a>1.roscore</h1><p>roscore 是你在运行所有ROS程序前首先要运行的命令。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws$ roscore</div></pre></td></tr></table></figure><h1 id="2-1使用rosnode"><a href="#2-1使用rosnode" class="headerlink" title="2.1使用rosnode"></a>2.1使用rosnode</h1><p>rosnode 显示当前运行的ROS节点信息。rosnode list 指令列出活跃的节点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ rosnode list</div><div class="line">/rosout</div><div class="line">/turtlesim</div></pre></td></tr></table></figure><h1 id="2-1rosnode-info-命令"><a href="#2-1rosnode-info-命令" class="headerlink" title="2.1rosnode info 命令"></a>2.1rosnode info 命令</h1><p>rosnode info 命令返回的是关于一个特定节点的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ rosnode info /rosout</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">--------------------------------------------------------------------------------</div><div class="line">Node [/rosout]</div><div class="line">Publications: </div><div class="line"> * /rosout_agg [rosgraph_msgs/Log]</div><div class="line"></div><div class="line">Subscriptions: </div><div class="line"> * /rosout [unknown type]</div><div class="line"></div><div class="line">Services: </div><div class="line"> * /rosout/set_logger_level</div><div class="line"> * /rosout/get_loggers</div><div class="line"></div><div class="line"></div><div class="line">contacting node http://kuo-Inspiron-7420:46315/ ...</div><div class="line">Pid: 5414</div></pre></td></tr></table></figure><h1 id="3-使用-rosrun"><a href="#3-使用-rosrun" class="headerlink" title="3.使用 rosrun"></a>3.使用 rosrun</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ rosrun turtlesim turtlesim_node</div></pre></td></tr></table></figure><p>出现以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[ INFO] [1506515421.527660398]: Starting turtlesim with node name /turtlesim</div><div class="line">[ INFO] [1506515421.540510002]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]</div></pre></td></tr></table></figure></p><p>同时弹出以下窗口:<br><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingNodes?action=AttachFile&amp;do=get&amp;target=turtlesim.png" alt="这里写图片描述"></p><p>在一个 新的终端:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosnode list</div></pre></td></tr></table></figure></p><p>你会看见类似于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/rosout</div><div class="line">/turtlesim</div></pre></td></tr></table></figure></p><h1 id="4-ROS的一个强大特性就是你可以通过命令行重新配置名称"><a href="#4-ROS的一个强大特性就是你可以通过命令行重新配置名称" class="headerlink" title="4.ROS的一个强大特性就是你可以通过命令行重新配置名称"></a>4.ROS的一个强大特性就是你可以通过命令行重新配置名称</h1><p>记得首先回到rosrun turtlesim终端并使用<code>ctrl-C</code><br>现在让我们重新运行它，但是这一次使用Remapping Argument改变节点名称:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ rosrun turtlesim turtlesim_node __name:=my_turtle</div></pre></td></tr></table></figure></p><p>此时再回到<code>rosnode list</code>端口，输入<code>rosnode list</code>会看到名字已经改了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ rosnode list</div><div class="line">/my_turtle  #注意，这里以前是turtlesim</div><div class="line">/rosout</div></pre></td></tr></table></figure></p><p>你可以用<code>rosnode ping</code>测试这个节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$  rosnode ping my_turtle</div><div class="line">rosnode: node is [/my_turtle]</div><div class="line">pinging /my_turtle with a timeout of 3.0s</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/time=0.518084ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/time=1.244068ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/time=1.185894ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/time=1.127005ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/time=0.943899ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/time=0.998020ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/time=0.899076ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/time=1.173973ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/time=1.152992ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/time=0.983000ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/time=1.232862ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/time=0.945091ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/time=1.293182ms</div><div class="line">^Cping average: 1.053627ms</div></pre></td></tr></table></figure></p><p>来自：<br><a href="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingNodes" target="_blank" rel="external">理解 ROS节点</a><br>本教程主要介绍 ROS 图（graph）概念 并讨论roscore、rosnode和 rosrun 命令行工具的使用。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图概念概述&quot;&gt;&lt;a href=&quot;#图概念概述&quot; class=&quot;headerlink&quot; title=&quot;图概念概述&quot;&gt;&lt;/a&gt;图概念概述&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;Nodes:节点,一个节点即为一个可执行文件，它可以通过ROS与其它节点进行通信。

Message
      
    
    </summary>
    
      <category term="ros" scheme="http://yoursite.com/categories/ros/"/>
    
    
      <category term="ros" scheme="http://yoursite.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>ros：（1）我的第一个ros文件</title>
    <link href="http://yoursite.com/2017/11/13/ros/ros%EF%BC%9A%EF%BC%881%EF%BC%89%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAros%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/11/13/ros/ros：（1）我的第一个ros文件/</id>
    <published>2017-11-13T13:07:59.000Z</published>
    <updated>2021-02-19T13:32:13.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-配置好环境"><a href="#1-配置好环境" class="headerlink" title="1.配置好环境"></a>1.配置好环境</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ source /opt/ros/indigo/setup.bash</div></pre></td></tr></table></figure><p>在每次打开终端时你都需要先运行上面这条命令后才能运行ros相关的命令，为了避免这一繁琐过程，你可以事先在.bashrc文件。</p><h1 id="2-创建ROS工作空间"><a href="#2-创建ROS工作空间" class="headerlink" title="2.创建ROS工作空间"></a>2.创建ROS工作空间</h1><h2 id="2-1-下面我们开始创建一个catkin-工作空间："><a href="#2-1-下面我们开始创建一个catkin-工作空间：" class="headerlink" title="2.1 下面我们开始创建一个catkin 工作空间："></a>2.1 下面我们开始创建一个catkin 工作空间：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ mkdir -p ~/catkin_ws/src</div><div class="line">kuo@kuo-Inspiron-7420:~$ ls</div><div class="line">catkin_ws         missfont.log  projects  模板</div></pre></td></tr></table></figure><h2 id="2-2-cat-make"><a href="#2-2-cat-make" class="headerlink" title="2.2 cat_make"></a>2.2 cat_make</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws$ catkin_make</div><div class="line">...</div><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws$ ls</div><div class="line">build  devel  src</div></pre></td></tr></table></figure><h3 id="2-3-source-setup-bash"><a href="#2-3-source-setup-bash" class="headerlink" title="2.3 source setup.bash"></a>2.3 source setup.bash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws$ cd devel</div><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/devel$ ls</div><div class="line">env.sh  lib  setup.bash  setup.sh  _setup_util.py  setup.zsh</div><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/devel$ source setup.bash</div></pre></td></tr></table></figure><h1 id="3-ROS文件系统介绍"><a href="#3-ROS文件系统介绍" class="headerlink" title="3.ROS文件系统介绍"></a>3.ROS文件系统介绍</h1><p>Description: 本教程介绍ROS文件系统概念，包括命令行工具roscd、rosls和rospack的使用。</p><h2 id="3-1-rospack-寻找文件夹地址"><a href="#3-1-rospack-寻找文件夹地址" class="headerlink" title="3.1 rospack :寻找文件夹地址"></a>3.1 <em>rospack</em> :寻找文件夹地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ rospack find roscpp</div><div class="line">/opt/ros/indigo/share/roscpp</div></pre></td></tr></table></figure><h2 id="3-2-roscd-进入文件夹"><a href="#3-2-roscd-进入文件夹" class="headerlink" title="3.2 roscd :进入文件夹"></a>3.2 <em>roscd</em> :进入文件夹</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ roscd roscpp</div><div class="line">kuo@kuo-Inspiron-7420:/opt/ros/indigo/share/roscpp$ pwd</div><div class="line">/opt/ros/indigo/share/roscpp</div></pre></td></tr></table></figure><h2 id="3-3-rosls-显示问价夹内容"><a href="#3-3-rosls-显示问价夹内容" class="headerlink" title="3.3 rosls :显示问价夹内容"></a>3.3 <em>rosls</em> :显示问价夹内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/.ros/log$ rosls roscpp_tutorials</div><div class="line">cmake  launch  package.xml  srv</div></pre></td></tr></table></figure><h1 id="4-创建ROS程序包"><a href="#4-创建ROS程序包" class="headerlink" title="4.创建ROS程序包"></a>4.创建ROS程序包</h1><p>Description: 本教程介绍如何使用 <em>roscreate-pkg</em> 或 <em>catkin</em> 创建一个新程序包,并使用 <em>rospack</em> 查看程序包的依赖关系。</p><h4 id="4-1-本教程中我们将会用到ros-tutorials程序包，请先安装："><a href="#4-1-本教程中我们将会用到ros-tutorials程序包，请先安装：" class="headerlink" title="4.1 本教程中我们将会用到ros-tutorials程序包，请先安装："></a>4.1 本教程中我们将会用到ros-tutorials程序包，请先安装：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/src$ sudo apt-get install ros-indigo-ros-tutorials</div></pre></td></tr></table></figure><h4 id="4-2-现在使用-catkin-create-pkg-命令来创建一个名为’beginner-tutorials’的新程序包，这个程序包依赖于std-msgs、roscpp和rospy："><a href="#4-2-现在使用-catkin-create-pkg-命令来创建一个名为’beginner-tutorials’的新程序包，这个程序包依赖于std-msgs、roscpp和rospy：" class="headerlink" title="4.2 现在使用 catkin_create_pkg 命令来创建一个名为’beginner_tutorials’的新程序包，这个程序包依赖于std_msgs、roscpp和rospy："></a>4.2 现在使用 <em>catkin_create_pkg</em> 命令来创建一个名为’beginner_tutorials’的新程序包，这个程序包依赖于std_msgs、roscpp和rospy：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/src$ cd ~/catkin_ws/src</div><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/src$ catkin_create_pkg beginner_tutorials std_msgs rospy roscpp</div></pre></td></tr></table></figure><h1 id="5-编译ROS程序包"><a href="#5-编译ROS程序包" class="headerlink" title="5.编译ROS程序包"></a>5.编译ROS程序包</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/src$ cd ~/catkin_ws/</div><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws$ catkin_make</div></pre></td></tr></table></figure><h1 id="6-运行ros"><a href="#6-运行ros" class="headerlink" title="6.运行ros"></a>6.运行ros</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws$ roscore</div></pre></td></tr></table></figure><h1 id="7-打开-turtlesim-窗口"><a href="#7-打开-turtlesim-窗口" class="headerlink" title="7.打开 turtlesim 窗口"></a>7.打开 turtlesim 窗口</h1><p>运行turtlesim包中的 turtlesim_node节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ rosrun turtlesim turtlesim_node</div><div class="line">[ INFO] [1506515421.527660398]: Starting turtlesim with node name /turtlesim</div><div class="line">[ INFO] [1506515421.540510002]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]</div></pre></td></tr></table></figure><p>如果出现 turtlesim 窗口，就表示文件创建成功！<br><img src="http://img.blog.csdn.net/20170927203643496?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h1 id="bug时间：环境变量设置问题"><a href="#bug时间：环境变量设置问题" class="headerlink" title="bug时间：环境变量设置问题"></a>bug时间：环境变量设置问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">. ~/catkin_ws/devel/setup.bash</div></pre></td></tr></table></figure><p>解决 <em>roscd beginner_tutorials</em> 没有此文件的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ roscd beginner_tutorials</div><div class="line">roscd: No such package/stack &apos;beginner_tutorials&apos;</div><div class="line">kuo@kuo-Inspiron-7420:~$ . ~/catkin_ws/devel/setup.bash</div><div class="line">kuo@kuo-Inspiron-7420:~$ roscd beginner_tutorials</div><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/src/beginner_tutorials$</div></pre></td></tr></table></figure></p><p>来自：初级教程1-4：<a href="http://wiki.ros.org/cn/ROS/Tutorials" target="_blank" rel="external">http://wiki.ros.org/cn/ROS/Tutorials</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-配置好环境&quot;&gt;&lt;a href=&quot;#1-配置好环境&quot; class=&quot;headerlink&quot; title=&quot;1.配置好环境&quot;&gt;&lt;/a&gt;1.配置好环境&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="ros" scheme="http://yoursite.com/categories/ros/"/>
    
    
      <category term="ros" scheme="http://yoursite.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>ros：（0）安装与教程</title>
    <link href="http://yoursite.com/2017/11/13/ros/ros%EF%BC%9A%EF%BC%880%EF%BC%89%E5%AE%89%E8%A3%85%E4%B8%8E%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/11/13/ros/ros：（0）安装与教程/</id>
    <published>2017-11-13T13:07:58.000Z</published>
    <updated>2021-02-19T13:32:13.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-ros"><a href="#1-ros" class="headerlink" title="1.ros"></a>1.ros</h1><h2 id="1-1安装"><a href="#1-1安装" class="headerlink" title="1.1安装"></a>1.1安装</h2><pre><code>一.在Ubuntu14.04上安装和配置ROS Indigo ：http://blog.csdn.net/zhuquan945/article/details/53079257</code></pre><h2 id="1-2学习教程"><a href="#1-2学习教程" class="headerlink" title="1.2学习教程"></a>1.2学习教程</h2><pre><code>一.ros官方中文教程：http://wiki.ros.org/cn/ROS/Tutorials二.ROS机器人操作系统的安装、配置与初级教程：https://www.shiyanlou.com/courses/854三.创客智造|ROS入门教程:http://www.ncnynl.com/archives/201608/497.html</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-ros&quot;&gt;&lt;a href=&quot;#1-ros&quot; class=&quot;headerlink&quot; title=&quot;1.ros&quot;&gt;&lt;/a&gt;1.ros&lt;/h1&gt;&lt;h2 id=&quot;1-1安装&quot;&gt;&lt;a href=&quot;#1-1安装&quot; class=&quot;headerlink&quot; title=&quot;1.1
      
    
    </summary>
    
      <category term="ros" scheme="http://yoursite.com/categories/ros/"/>
    
    
      <category term="ros" scheme="http://yoursite.com/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>机器人的自主定位导航</title>
    <link href="http://yoursite.com/2017/11/13/%E5%AF%BC%E8%88%AA/%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%89%E5%92%8Cdeep%20learning%E5%81%9A%E8%87%AA%E4%B8%BB%E5%AF%BC%E8%88%AA/"/>
    <id>http://yoursite.com/2017/11/13/导航/利用视觉和deep learning做自主导航/</id>
    <published>2017-11-13T13:06:58.000Z</published>
    <updated>2021-02-19T13:32:13.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h1><h2 id="1-1-机器人的自主定位导航"><a href="#1-1-机器人的自主定位导航" class="headerlink" title="1.1 机器人的自主定位导航"></a>1.1 <strong>机器人的自主定位导航</strong></h2><p><img src="http://img.blog.csdn.net/20171112195115316?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>正如图中所示，<strong>机器人自主定位导航技术</strong>中包括：<strong>定位和地图创建（SLAM）</strong>与<strong>路径规划和运动控制</strong>两个部分，而SLAM本身只是完成机器人的定位和地图创建，二者有所区别。</p><p>首先明确一下自主导航的两大解决方案：</p><blockquote><p>1.传统方案（稍微成熟一点）：SLAM+路径规划+运动控制；</p><p>2.深度学习（还不完善）：<br>这一两年，深度学习成为人工智能的代名词。在这个行业，前几年还是以比较传统的概率学，或者控制论的方式进行机器人自主定位导航。但这里展现的是完全通过深度学习，直接通过摄像头数据作为信号输入，再通过神经网络直接产生出机器人的控制信号。其中像 SLAM 的过程、路径规划的过程，完全通过学习的方式就可以进行实现。</p></blockquote><h2 id="1-2-传统方案"><a href="#1-2-传统方案" class="headerlink" title="1.2.传统方案"></a>1.2.传统方案</h2><p>传统方案是：（SLAM+路径规划+运动控制）</p><h3 id="1-2-1-SLAM"><a href="#1-2-1-SLAM" class="headerlink" title="1.2.1.SLAM"></a>1.2.1.SLAM</h3><p>SLAM是同步定位与地图构建(Simultaneous Localization And Mapping)的缩写，最早由Hugh Durrant-Whyte 和 John J.Leonard提出。</p><p>其实，SLAM更像是一个概念而不是一个算法，它本身包含许多步骤，其中的每一个步骤均可以使用不同的算法实现。主要用于解决移动机器人在未知环境中运行时即时定位与地图构建的问题。</p><p>当你身处异地，怎么准确找到想去的地方？在户外迷路时，怎么找到回家的路？没错，我们有导航软件和户外地图。</p><h4 id="1-选择地图"><a href="#1-选择地图" class="headerlink" title="1.选择地图"></a>1.选择地图</h4><p>和人类绘制地图一样，机器人描述环境、认识环境的过程主要就是依靠地图。它利用环境地图来描述其当前环境信息，并随着使用的算法与传感器差异采用不同的地图描述形式。</p><p>机器人学中地图的表示方法有四种：<strong>栅格地图、特征地图、直接表征法以及拓扑地图</strong>。</p><h5 id="（1）-栅格地图"><a href="#（1）-栅格地图" class="headerlink" title="（1）.栅格地图"></a>（1）.<strong>栅格地图</strong></h5><p>机器人对环境地图的描述的方式最常见的为栅格地图(Grid map)或者称为Occupancy Map。栅格地图就是把环境划分成一系列栅格，其中每一栅格给定一个可能值，表示该栅格被占据的概率。<br><img src="http://img.blog.csdn.net/20171112213014441?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>这种地图看起来和人们所认知的地图没什么区别，它最早由NASA的Alberto Elfes在1989年提出，在火星探测车上就用到过，其本质是一张位图图片，但其中每个“像素”则表示了实际环境中存在障碍物的概率分布。</p><p>一般来说，采用激光雷达、深度摄像头、超声波传感器等可以直接测量距离数据的传感器进行SLAM时，可以使用该地图。这种地图也可以通过距离测量传感器、超声波（早期）、激光雷达（现在）绘制出来。</p><h5 id="（2）-特征点地图"><a href="#（2）-特征点地图" class="headerlink" title="（2）.特征点地图"></a><strong>（2）.特征点地图</strong></h5><p>特征点地图，是用有关的几何特征（如点、直线、面）表示环境，常见于vSLAM（视觉SLAM）技术中。<br><img src="http://img.blog.csdn.net/20171112213152552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>相比栅格地图，这种地图看起来就不那么直观了。它一般通过如GPS、UWB以及摄像头配合稀疏方式的vSLAM算法产生，优点是相对数据存储量和运算量比较小，多见于最早的SLAM算法中。</p><h5 id="（3）-直接表征法"><a href="#（3）-直接表征法" class="headerlink" title="（3）.直接表征法"></a><strong>（3）.直接表征法</strong></h5><p>直接表征法中，省去了特征或栅格表示这一中间环节，直接用传感器读取的数据来构造机器人的位姿空间。</p><p><img src="http://img.blog.csdn.net/20171112213242871?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>上图就是直接记录了屋子内天花板画面的图像地图。这种方法就像卫星地图一样，直接将传感器原始数据通过简单处理拼接形成地图，相对来说更加直观。</p><h5 id="（4）-拓扑地图"><a href="#（4）-拓扑地图" class="headerlink" title="（4）.拓扑地图"></a><strong>（4）.拓扑地图</strong></h5><p>拓扑地图，是一种相对更加抽象的地图形式，它把室内环境表示为带结点和相关连接线的拓扑结构图，其中结点表示环境中的重要位置点（拐角、门、电梯、楼梯等），边表示结点间的连接关系，如走廊等。这种方法只记录所在环境拓扑链接关系，这类地图一般是由前几类地图通过相关算法提取得到。</p><p>比如扫地机器人要进行房间清扫的时候，就会建立这样的拓扑地图：<br><img src="http://img.blog.csdn.net/20171112213350432?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h5 id="（5）-小结"><a href="#（5）-小结" class="headerlink" title="（5）.小结"></a><strong>（5）.小结</strong></h5><p>在机器人技术中，SLAM的地图构建通常指的是建立与环境几何一致的地图。</p><p>一般算法中建立的<strong>拓扑地图</strong>只反映了环境中的各点连接关系，并不能构建几何一致的地图，因此，这些拓扑算法不能被用于SLAM。</p><p><strong>直接表征法</strong>类似卫星地图，它是直接使用传感器（一般是图像传感器）构建得到。这种方法的信息冗余度最大，对于数据存储是很大的挑战，同时，机器人要从中提取出有用的数据也要耗费一番周折，因此在实际应用中很少使用。</p><p><strong>特征点地图</strong>又是另一个极端，虽然数据量少，但是它往往不能反应所在环境的一些必须的信息，比如环境中障碍物的位置。vSLAM技术中，多采用这种地图来解决机器人定位问题。想让机器人进行自主避障和路径规划，还需要额外配置距离传感器，如激光雷达、超声波来完成。</p><p><strong>栅格地图</strong>，或者Occupancy Map（占据地图）恰好介于其中，一方面它能表示空间环境中的很多特征，机器人可以用它来进行路径规划，另一方面，它又不直接记录传感器的原始数据，相对实现了空间和时间消耗的最优。因此，栅格地图是目前机器人所广泛应用的地图存储方式。</p><p><img src="http://img.blog.csdn.net/20171112224222094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="2-定位及传感器选择"><a href="#2-定位及传感器选择" class="headerlink" title="2.定位及传感器选择"></a>2.定位及传感器选择</h4><p>当你打开手机中的导航软件，在选择前往目的地的最佳路线之前，首先要做的动作是什么呢？没错，就是定位。我们要先知道自己在地图中的位置，才可以进行后续的路径规划。</p><p>在机器人实时定位问题中，由于通过机器人运动估计得到的机器人位置信息通常具有较大的误差，我们还需要使用测距单元得到的周围环境信息更正机器人的位置。</p><p>关于定位方案的选择，具体看这里：<a href="http://www.arduino.cn/thread-45526-1-1.html" target="_blank" rel="external">干货|服务机器人常用的定位导航技术及优缺点分析</a></p><p>目前，常见的测距单元包括激光测距、超声波测距以及图像测距三种。其中，凭借激光良好的指向性和高度聚焦性，<strong>激光雷达</strong>已经成为移动机器人的核心传感器，同时它也是目前最可靠、最稳定的定位技术。</p><p>自1988年被提出以来，SLAM的理论研究发展十分迅速。在实际应用时，除配备激光雷达外，还需要机器人具有IMU（惯性测量单元）、里程计来为激光雷达提供辅助数据，这一过程的运算消耗是巨大的，传统上需要PC级别的处理器，这也成为限制SLAM广泛应用的瓶颈之一。</p><h4 id="3-传感器数据预处理"><a href="#3-传感器数据预处理" class="headerlink" title="3.传感器数据预处理"></a>3.传感器数据预处理</h4><p>这是一个完整的SLAM和导航系统的主要架构图：</p><p><img src="http://img.blog.csdn.net/20171112215345477?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>其中，SLAM核心过程包括3个步骤，第一步称为<strong>预处理</strong>。我们知道，激光雷达和其他雷达设备一样，某一个时刻只能获取它所在位置的环境信息。</p><p>这就是我们所说的点云，它只能反映机器人所在环境中的一个部分。第一步预处理就是对激光雷达原始数据进行优化，剔除一些有问题的数据，或者进行滤波。</p><center><img src="http://img.blog.csdn.net/20171112215550615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></center><h4 id="4-匹配"><a href="#4-匹配" class="headerlink" title="4.匹配"></a>4.匹配</h4><p>第二步是<strong>匹配</strong>，也就是说把当前这一个局部环境的点云数据在已经建立地图上寻找到对应的位置，这个步骤非常关键。</p><center><img src="http://img.blog.csdn.net/20171112215731166?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></center><p>这个是ICP的点云匹配算法，用于实现匹配。说这个过程关键，就是因为它的好坏，直接影响了SLAM构建地图的精度。这个过程和我们玩拼图游戏有点类似，就是在已经拼好的画面中找到相似之处，确定新的一个拼图该放在哪里。</p><p>在SLAM过程中，需要将激光雷达当前采集的点云（红色部分）匹配拼接到原有地图中。</p><p><img src="http://img.blog.csdn.net/20171112220423025?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>如果不进行匹配过程，所构建的地图可能就乱成一团，变成这样。</p><p><img src="http://img.blog.csdn.net/20171112220456272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="5-地图融合"><a href="#5-地图融合" class="headerlink" title="5.地图融合"></a>5.地图融合</h4><p>在这个部分完毕以后，就进行第三步，<strong>地图融合</strong>，也就是将这一轮来自激光雷达的新数据拼接到原始地图当中，最终完成地图的更新。</p><p>就像这个图一样，这个过程是永远伴随SLAM过程的。</p><p><img src="http://img.blog.csdn.net/20171112220620581?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>数据融合和简单的贴图是有很大的差异的。因为实际上传感器描绘的世界存在一定的误差，或者正巧在这个时间环境有了变化，例如机器人旁边闯入了一只小猫。</p><p>因此，实际要进行的过程会更加复杂，需要用很多概率算法，并采用滤波的方式进行融合。将上述这个过程逐次执行，就最终产生了我们看到的栅格地图。</p><p><img src="http://img.blog.csdn.net/20171112220715666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="6-Loop-Closure（回环）问题"><a href="#6-Loop-Closure（回环）问题" class="headerlink" title="6.Loop Closure（回环）问题"></a>6.Loop Closure（回环）问题</h4><p>这个过程听起来其实并不复杂，但是要处理好有很大难度。这里举几个例子，比如叫做<strong>Loop Closure（回环）问题</strong>。如果匹配算法不足够优秀，或者环境中存在很不巧的干扰，当机器人绕着环境一圈后，就会发现原本是应该闭合的一个环形走廊断开了。</p><p>比如正常地图应该这样：</p><p><img src="http://img.blog.csdn.net/20171112220901937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>如果处理不好，实际地图就成这样：</p><p><img src="http://img.blog.csdn.net/20171112220931142?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>对于环境比较大的场景，回环问题是不得不面对的，但现实总是不完美的，即使是激光雷达这种高精度传感器，也难免存在误差。而回环问题的难点恰恰在于在一开始出现少许误差的时候，并不会被发觉，直到机器人绕着环路一圈，随着误差的累加，发现环路已经无法闭合时，此时已经酿成大错，一般很难回天。</p><p>当然这个问题并不是无解，一个好的商用化SLAM系统，回环问题是否能很好的解决，就成为评判这个系统实力的指标了。</p><p>这是前两天在『思岚科技』办公室进行的测试，左边的视频是基于开源的ROS机器人操作系统进行的地图构建，右边的是基于SLAMWARE构建的地图。</p><p>『视频暂缺』</p><p>当机器人已经绕场一周后，ROS构建的地图出现了中断，而SLAMWARE构建的地图是一个完美的闭环，它与我们办公室的设计图完美重合。</p><p><img src="http://img.blog.csdn.net/20171112221129621?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>除了算法层面的回环问题，SLAM实际应用中还有很多这种坑，比如<strong>走廊问题</strong>与<strong>外界干扰问题</strong>。</p><p>以外界干扰问题来说，通常，激光雷达作为机器人的眼睛，一般是安装在底盘上的，它能看到的视野很有限。当受到外界干扰（人类或者宠物等等）后，机器人很容易丢失定位精度，无法正常完成后续的建图工作。</p><p>当机器人安装SLAMWARE后，机器人受到干扰，可以完全不受影响，照样能够正常工作。</p><p>『视频暂缺』</p><p>目前，SLAM的开源实现代表多为学术界，实际应用有很多Corner Case要处理，需要传感器、系统参数、其他辅助设备的联合调优。</p><p>一般来说，上述的SLAM过程对于运算消耗是巨大的，虽然并没有达到像训练神经网络动用服务器集群那种地步，但传统上需要PC级别的处理器。</p><p>除配备激光雷达外，还需要机器人具有IMU（惯性测量单元）、里程计来为激光雷达提供辅助数据，否则SLAM系统也难以得到运行。总的来说，SLAM算法本身是一个对于外部系统有着多种依赖的算法，这是一个切实的工程问题。</p><h4 id="7-算法优化及商用"><a href="#7-算法优化及商用" class="headerlink" title="7.算法优化及商用"></a>7.算法优化及商用</h4><p>很多机器人，比如扫地机是不可能装一个PC进去的，为了让SLAM能在这类设备里运行，除了解决激光雷达成本外，还要对SLAM算法做出很好的优化。</p><blockquote><p>了解，不是本文主题：</p><p>这也是我们思岚科技SLAMTEC主要的努力方向，一方面，我们这7年多很好的解决了各类实际SLAM算法难点，另一方面，我们把SLAM这个复杂的系统做了很大的优化，可以放到一个硬币那么大的模块内部，降低尺寸功耗。此外，它还集成了IMU等配套传感器，力求做到对于SLAM的使用便捷性。</p></blockquote><h3 id="1-2-2-路径规划"><a href="#1-2-2-路径规划" class="headerlink" title="1.2.2.路径规划"></a>1.2.2.路径规划</h3><p>那么，机器人利用SLAM技术得到了有效的空间信息后，它是怎样实现路径规划的？SLAM和路径规划之间关系是怎样的？</p><p><img src="http://img.blog.csdn.net/20171112221822109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>实际上，SLAM算法本身只是完成了机器人的<strong>定位和地图构建</strong>两件事情，与我们说的<strong>导航定位</strong>并不是完全等价的。这里的导航，其实是SLAM算法做不了的。它在业内叫做<strong>运动规划(Motion Planning)</strong>。</p><p><strong>运动规划</strong>是一个很大的概念，从机械臂的运动、到飞行器的飞行，再到这里我们说的扫地机的清扫<strong>路径规划，都是运动规划的范畴</strong>。</p><p>我们先谈谈针对扫地机这类轮式机器人的运动规划。这里所需的基础能力就是<strong>路径规划</strong>，也就是一般在完成SLAM后，要进行一个叫做目标点导航的能力。通俗的说，就是规划一条从A点到B点的路径出来，然后让机器人移动过去。</p><p><img src="http://img.blog.csdn.net/20171112222723876?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h4 id="1-全局规划"><a href="#1-全局规划" class="headerlink" title="1.全局规划"></a>1.全局规划</h4><p>要实现这个过程，运动规划要实现至少两个层次的模块，一个叫做<strong>全局规划</strong>，这个和我们车载导航仪有一点像，它需要在地图上预先规划一条线路，也要有当前机器人的位置。这是由我们的SLAM系统提供出来的。行业内一般会用叫做<strong>A*</strong>的算法来实现这个过程，它是一种启发式的搜索算法，非常优秀。它最多的应用，是在游戏中，比如像星际争霸、魔兽争霸之类的即时战略游戏，都是使用这个算法来计算单位的运动轨迹的。</p><h4 id="2-局部规划"><a href="#2-局部规划" class="headerlink" title="2.局部规划"></a>2.局部规划</h4><p>当然，仅仅规划了路径还是不够的，现实中会有很多突发情况，比如正巧有个小孩子挡道了，就需要调整原先的路径。当然，有时候这种调整并不需要重新计算一遍全局路径，机器人可能稍微绕一个弯就可以。此时，我们就需要另一个层次的规划模块，叫做<strong>局部规划</strong>。它可能并不知道机器人最终要去哪，但是对于机器人怎么绕开眼前的障碍物特别在行。</p><h4 id="3-已知地图（A）与未知地图（D）算法"><a href="#3-已知地图（A）与未知地图（D）算法" class="headerlink" title="3.已知地图（A）与未知地图（D）算法"></a>3.已知地图（A<em>）与未知地图（D</em>）算法</h4><p>这两个层次的规划模块协同工作，机器人就可以很好的实现从A点到B点的行动了，不过实际工作环境下，上述配置还不够。比如<strong>A＊算法规划的路径是根据已知地图，预先规划好的</strong>，一旦机器人前往目的地的过程中遇到了新的障碍物，就只好完全停下来，等待障碍物离开或者重新规划路径了。如果扫地机器人买回家，必须先把屋子都走一遍以后才肯扫地，那用户体验就会很差。</p><p>为此，也会有针对这类算法的改进，比如SLAMWARE内我们采用改良的<strong>D*算法</strong>进行路径规划，这也是美国火星探测器采用的核心寻路算法。<strong>这是一种动态启发式路径搜索算法，它让机器人在陌生环境中行动自如，在瞬息万变的环境中游刃有余。</strong></p><p><strong>D*算法的最大优点是不需要预先探明地图，机器人可以和人一样，即使在未知环境中，也可以展开行动，随着机器人不断探索，路径也会时刻调整。</strong></p><h4 id="4-空间覆盖（space-coverage）"><a href="#4-空间覆盖（space-coverage）" class="headerlink" title="4.空间覆盖（space coverage）"></a>4.空间覆盖（space coverage）</h4><p>以上是目前大部分移动机器人都需要的路径规划算法，而扫地机器人作为最早出现在消费市场的服务机器人之一，它需要的路径规划算法更为复杂。</p><p>一般来说，扫地机需要这么几个规划能力：贴边打扫、折返的工字形清扫以及没电时候自主充电。单单依靠前面介绍的D*这类算法，无法满足这些基础需要。</p><p>扫地机器人还需要有额外的规划算法，比如针对折返的工字形清扫，有很多问题要处理。扫地机如何最有效进行清扫而不重复清扫？如何让扫地机和人一样，理解房间、门、走廊这种概念？</p><p>针对这些问题，学术界长久以来有一个专门的研究课题，叫做空间覆盖（space coverage），同时也提出了非常多的算法和理论。其中，比较有名的是Morse Decompositions，扫地机通过它实现对空间进行划分，随后进行清扫。</p><p><img src="http://img.blog.csdn.net/20171112223348348?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>20世纪70年代，卡内基梅陇大学（CMU）完全依靠超声波做到了现在我们扫地机的行为，当然造价也十分昂贵。</p><p><img src="http://img.blog.csdn.net/20171112223518498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>前面介绍的从A点到B点移动路径规划也是实现这类更高级路径规划的基础。实际上，要从SLAM实现到扫地机器人所需要的这些功能，还是有非常多的工作要做的。</p><blockquote><p>了解，不是主题</p><p>针对扫地机器人，我们将其特有的路径规划功能预先内置在SLAMWARE中，方便厂家进行整合，不需要进行二次开发。</p></blockquote><p>参考：<a href="http://www.arduino.cn/thread-46394-1-1.html" target="_blank" rel="external">http://www.arduino.cn/thread-46394-1-1.html</a><br><a href="http://www.arduino.cn/thread-46541-1-1.html" target="_blank" rel="external">http://www.arduino.cn/thread-46541-1-1.html</a><br><a href="http://www.arduino.cn/thread-46992-1-1.html" target="_blank" rel="external">http://www.arduino.cn/thread-46992-1-1.html</a><br><a href="http://www.arduino.cn/thread-45526-1-1.html" target="_blank" rel="external">http://www.arduino.cn/thread-45526-1-1.html</a></p><p>扩展阅读：<a href="http://blog.sina.com.cn/s/blog_bee56e800102wbpk.html" target="_blank" rel="external">机器人自主导航四大方案</a></p><p><a href="http://www.robot-china.com/news/201707/10/42910.html" target="_blank" rel="external">自主定位导航技术的现状和未来应用趋势</a></p><h2 id="1-3基于深度学习的自主导航"><a href="#1-3基于深度学习的自主导航" class="headerlink" title="1.3基于深度学习的自主导航"></a>1.3基于深度学习的自主导航</h2><p>V SLAM 还是 LIDAR SLAM？</p><p>　　最后讲一下未来导航定位系统的发展趋势。</p><blockquote><p><a href="http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html" target="_blank" rel="external">这篇博客解释了SLAM和Deep Learning的关系，写得非常仔细。</a></p></blockquote><p>　　对于 V SLAM 和 LIDAR SLAM 谁更重要的问题，实际上是一个融合的过程。这两种技术都有优缺点，激光的缺点毋庸置疑，传统激光雷达很贵，第二很多方面不大灵活，目前为止，传感器还不成熟。对环境光影的变化或者室内比较昏暗的场景，V SLAM技术都没办法使用，但如果把这两种 SLAM 技术融合在一起，并且配以目前低成本的传感器，这种融合式的 SLAM 方式会是未来比较重要的趋势。</p><p>　　提取语义信息，也是配合视觉激光做的。目前绘制的地图还比较平级，通过采集图象数据和深度学习，可以主动在地图上进行标记，就可以避开前面提到的人工 POI 标注过程。</p><p>　　前行业中还有一个趋势——深度学习。这一两年，深度学习成为人工智能的代名词。在这个行业，前几年还是以比较传统的概率学，或者控制论的方式进行机器人自主定位导航。但这里展现的是完全通过深度学习，直接通过摄像头数据作为信号输入，再通过神经网络直接产生出机器人的控制信号。其中像 SLAM 的过程、路径规划的过程，完全通过学习的方式就可以进行实现。</p><p>　　我认为这种技术可能会成为未来的一种潮流，但是不是在有限的将来，在实际产品中进行体现，还是需要给予时日。但不变的是，在行业中取长补短，结合不同新的技术进行融合，这是不会改变的事实。<br>　　<br>　　从目前的研究情况来看，深度学习在SLAM这个问题上还没有完全取代传统方法的能力。希望各位同僚继续努力！跳出SLAM，说点题外话，利用深度强化学习来进行端对端的机器人导航，已经有了不错的结果。人类在环境中导航，不也是直接输入image，输出action吗？有兴趣的可以看看这两篇文章：</p><p>(1) <a href="https://sites.google.com/view/cognitive-mapping-and-planning/" target="_blank" rel="external">[1702.03920] Cognitive Mapping and Planning for Visual Navigation</a></p><p><a href="https://www.sohu.com/a/126513259_465975" target="_blank" rel="external">《视觉导航的认知映射与规划 》</a></p><blockquote><p>摘要<br>我们介绍了一种用于在全新的环境中导航的神经架构。我们提出的架构可以学习根据第一人称视角构建地图（mapping）和在环境中规划（planning）到达目的地的动作序列。这个认知型地图构建器和规划器（CMP/Cognitive Mapper and Planner）基于两个关键思想：a）一个用于地图构建和规划的统一联合架构，这样使得该地图构建可由规划者的需求来驱动；b）一个可以在关于世界的观察集合不完整时能够进行规划的空间记忆。CMP 能构建一个自上而下的关于世界的可信度地图（belief map）并应用一个可微神经网络规划器来在每一个时间步骤产生下一个动作。这种关于世界的积累的可信度使得该代理（agent）能够跟踪其环境中已经访问过的区域。我们的实验表明该 CMP 的表现超过了反应策略（reactive strategies）和标准的基于记忆的架构，并且可以在全新的环境中获得良好的表现。此外，我们还表明 CMP 也能够实现特定语义的目标，比如「go to a chair」。</p></blockquote><p><img src="http://img.blog.csdn.net/20171113163838058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>(2) 当然，DL 在 navigation 方面也已经有一些研究了，例如 Feifei Li 实验室的工作：通过 DRL 实现机器人自主导航。</p><p><a href="https://arxiv.org/abs/1609.05143" target="_blank" rel="external">[1609.05143] Target-driven Visual Navigation in Indoor Scenes using Deep Reinforcement Learning</a></p><p><a href="http://www.jianshu.com/p/1ef3cebe366e" target="_blank" rel="external">《基于深度增强的室内场景目标驱动视觉导航 》</a></p><p>但是，目前所有这些工作都存在一个问题：只是训练出一个 local planner，无法实现全局的路径规划。所以，我个人认为，「用 DL 学习到全局的信息，进而引导 navigation」，会比「尝试用 DL 建立精确的地图，之后用这个地图进行 navigation」更有前景。未来，可能就没有 SLAM + navigation 这种框架了。</p><blockquote><p>摘要<br>两个较少的深层强化学习问题是：（1）缺乏对新的目标目标的泛化能力;（2）数据低效率，即模型需要几次（通常是昂贵的）尝试和错误的聚合，这使得它不切实际 应用于真实世界的场景。 在本文中，我们解决这两个问题，并将我们的模型应用于目标驱动的视觉导航任务。 为了解决第一个问题，我们提出了一个行为者 - 评论者模型，其政策是目标的功能以及当前状态，从而能够更好地概括。 为了解决第二个问题，我们提出了AI2-THOR框架，它提供了一个高质量的3D场景和物理引擎的环境。 我们的框架使代理能够采取行动并与对象进行交互。 因此，我们可以高效地收集大量的训练样本。</p></blockquote><p><img src="http://img.blog.csdn.net/20171113165826756?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>（3） <a href="http://xueshu.baidu.com/s?wd=paperuri:%28f25e0510cc61360db434474c94a01677%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http://arxiv.org/abs/1611.03673&amp;ie=utf-8&amp;sc_us=1983469550890279566" target="_blank" rel="external">Mirowski, Piotr, et al. （Learning to navigate in complex environments.）</a></p><p><a href="http://blog.csdn.net/mrhcat/article/details/71267200" target="_blank" rel="external">在复杂环境中学习导航</a><br><a href="http://www.rosclub.cn/post-628.html" target="_blank" rel="external">http://www.rosclub.cn/post-628.html</a></p><blockquote><p>摘要<br>学习在具有动态元素的复杂环境中进行导航是开发AI代理的重要里程碑。 在这项工作中，我们将导航问题作为一个强化学习问题，并且表明通过利用多模式感官输入的附加辅助任务可以显着提高数据效率和任务性能。 具体而言，我们考虑联合学习目标驱动强化学习问题与辅助深度预测和闭环分类任务。 这种方法可以学习从复杂的3D迷宫中的原始感官输入导航，即使在目标位置经常变化的情况下也能接近人类的表现。 我们对代理行为，本地化能力和网络活动动态进行详细的分析，显示代理隐式学习关键导航能力。</p></blockquote><p>（4）ETH 室内导航：<a href="https://arxiv.org/abs/1609.07910" target="_blank" rel="external">From Perception to Decision: A Data-driven Approach to End-to-end Motion Planning for Autonomous Ground Robots</a><br>从感知到决策：一种基于数据驱动的端到端运动规划方法 </p><p>（5）CMU 无人机穿越森林：<a href="https://arxiv.org/pdf/1211.1690.pdf" target="_blank" rel="external">Learning Monocular Reactive UAV Control in Cluttered Natural Environments</a><br>学习单目无功无人机控制在复杂的自然环境 </p><p>（6）<a href="https://mp.weixin.qq.com/s?__biz=MzA5MDE2MjQ0OQ==&amp;mid=2652786682&amp;idx=1&amp;sn=21e1a64a2a47c865cb73c381c3f10001&amp;chksm=8be53b84bc92b292e841e7cb15e425763a72751806b5a942d2508d286b7eff383053e05f9eac#rd" target="_blank" rel="external">运动规划 | 视频篇</a> </p><blockquote><p>了解<br>你好，答主好，我也想做基于dp的自动驾驶的运动规划。现在自动驾驶的决策主要分成四层来完成：1.大路线规划；2.汽车行为决策（变道/减速等）；3.路径/轨迹规划；4.轨迹跟随控制。目前4已经完全没问题了，3也有很多完全并可靠的算法，而在2中的难点主要在于其他交通参与者的运动意图预测，这里是机器学习切入的地方，也是四个层面中最契合机器学习的，其他部分现有的算法已经足够好并且可靠。而运动意图预测似乎更像是cs的活，距离运动规划比较远了。因此我很犹豫下一步研究方向该怎么走。想和二位讨论一下。</p></blockquote><p>（7）第一期我们与大家分享的是苏黎世大学Davide Scaramuzza教授研究团队的最新成果——基于深度神经网络利用单目视觉帮助无人机穿过森林小道。这项研究入选理由是迄今为止第一次实现了基于机载硬件在真实林间小路上实时地规划和控制。<a href="https://mp.weixin.qq.com/s/oTGC8i0NKGi-ad7TlfsRfg" target="_blank" rel="external">https://mp.weixin.qq.com/s/oTGC8i0NKGi-ad7TlfsRfg</a></p><p>(8)<a href="https://arxiv.org/abs/1705.02550" target="_blank" rel="external">Toward Low-Flying Autonomous MAV Trail Navigation using Deep Neural Networks for Environmental Awareness</a></p><p>（9）<a href="https://github.com/cometa/Autonomia" target="_blank" rel="external">https://github.com/cometa/Autonomia</a></p><p>（10）<a href="https://github.com/RyanZotti/Self-Driving-Car" target="_blank" rel="external">https://github.com/RyanZotti/Self-Driving-Car</a></p><p>（11）<a href="https://github.com/DJTobias/Cherry-Autonomous-Racecar" target="_blank" rel="external">https://github.com/DJTobias/Cherry-Autonomous-Racecar</a></p><p>（12）<a href="https://github.com/hamuchiwa/AutoRCCar" target="_blank" rel="external">https://github.com/hamuchiwa/AutoRCCar</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-背景介绍&quot;&gt;&lt;a href=&quot;#1-背景介绍&quot; class=&quot;headerlink&quot; title=&quot;1.背景介绍&quot;&gt;&lt;/a&gt;1.背景介绍&lt;/h1&gt;&lt;h2 id=&quot;1-1-机器人的自主定位导航&quot;&gt;&lt;a href=&quot;#1-1-机器人的自主定位导航&quot; class=&quot;
      
    
    </summary>
    
      <category term="自主导航" scheme="http://yoursite.com/categories/%E8%87%AA%E4%B8%BB%E5%AF%BC%E8%88%AA/"/>
    
    
      <category term="DL" scheme="http://yoursite.com/tags/DL/"/>
    
      <category term="导航" scheme="http://yoursite.com/tags/%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>Google超有趣 AI 小实验合集</title>
    <link href="http://yoursite.com/2017/11/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Google%E8%B6%85%E6%9C%89%E8%B6%A3%20AI%20%E5%B0%8F%E5%AE%9E%E9%AA%8C%E5%90%88%E9%9B%86/"/>
    <id>http://yoursite.com/2017/11/13/机器学习/Google超有趣 AI 小实验合集/</id>
    <published>2017-11-13T13:06:58.000Z</published>
    <updated>2021-02-19T13:32:13.202Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://zhuanlan.zhihu.com/p/30501448" target="_blank" rel="external">不论你会不会编程，你都可以在这感受到AI的乐趣（园长诚意推荐）</a></p><pre><code>简评：都是些特别有趣的、有意义、有想法的小项目，让人工智能落地，接地气，看得见摸得着。真不错，其中能玩的我都玩了。</code></pre><p>Google Experiment（谷歌实验）是谷歌官方出品的，各种前沿技术的新锐实验，让非技术用户也能够体验到最新的技术成果。<br>入口：Google Ai 实验<br>（因为是 Google 的，都要科学上网)</p><p>这个网页是这样的：</p><p><img src="http://img.blog.csdn.net/20171028211408689?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><pre><code>原网页：https://experiments.withgoogle.com/ai</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30501448&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;不论你会不会编程，你都可以在这感受到AI的乐趣（园长诚意推荐）&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;简评：都
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>是AI就躲个飞机-纯Python实现人工智能</title>
    <link href="http://yoursite.com/2017/11/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%98%AFAI%E5%B0%B1%E8%BA%B2%E4%B8%AA%E9%A3%9E%E6%9C%BA-%E7%BA%AFPython%E5%AE%9E%E7%8E%B0%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    <id>http://yoursite.com/2017/11/13/机器学习/是AI就躲个飞机-纯Python实现人工智能/</id>
    <published>2017-11-13T13:06:58.000Z</published>
    <updated>2021-02-19T13:32:13.216Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="http://blog.csdn.net/u014365862/article/details/54380422" target="_blank" rel="external">是AI就躲个飞机-纯Python实现人工智能</a></p><p>很久以前微信流行过一个小游戏：打飞机，这个游戏简单又无聊。在2017年来临之际，我就实现一个超级弱智的人工智能（AI），这货可以躲避从屏幕上方飞来的飞机。本帖只使用纯Python实现，不依赖任何高级库。</p><p>本文的AI基于<a href="https://en.wikipedia.org/wiki/Neuroevolution" target="_blank" rel="external">neuro-evolution</a>，首先简单科普一下neuro-evolution。从neuro-evolution这个名字就可以看出它由两部分组成-neuro and evolution，它是使用进化算法（遗传算法是进化算法的一种）提升人工神经网络的机器学习技术，其实就是用进化算法改进并选出最优的神经网络。</p><p>   <a href="http://blog.topspeedsnail.com/archives/10709" target="_blank" rel="external">使用TPOT自动选择scikit-learn机器学习模型和参数</a></p><h2 id="neuro-evolution"><a href="#neuro-evolution" class="headerlink" title="neuro-evolution"></a>neuro-evolution</h2><p>定义一些变量：</p><figure class="highlight plain"><figcaption><span>view plain copy</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import math  </div><div class="line">import random  </div><div class="line">   </div><div class="line"># 神经网络3层, 1个隐藏层; 4个input和1个output  </div><div class="line">network = [4, [16], 1]  </div><div class="line"># 遗传算法相关  </div><div class="line">population = 50  </div><div class="line">elitism = 0.2   </div><div class="line">random_behaviour = 0.1  </div><div class="line">mutation_rate = 0.5  </div><div class="line">mutation_range = 2  </div><div class="line">historic = 0  </div><div class="line">low_historic = False  </div><div class="line">score_sort = -1  </div><div class="line">n_child = 1</div></pre></td></tr></table></figure><p>定义神经网络：</p><figure class="highlight plain"><figcaption><span>view plain copy</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># 激活函数  </div><div class="line">def sigmoid(z):  </div><div class="line">    return 1.0/(1.0+math.exp(-z))  </div><div class="line"># random number  </div><div class="line">def random_clamped():  </div><div class="line">    return random.random()*2-1  </div><div class="line">   </div><div class="line"># &quot;神经元&quot;  </div><div class="line">class Neuron():  </div><div class="line">    def __init__(self):  </div><div class="line">        self.biase = 0  </div><div class="line">        self.weights = []  </div><div class="line">   </div><div class="line">    def init_weights(self, n):  </div><div class="line">        self.weights = []  </div><div class="line">        for i in range(n):  </div><div class="line">            self.weights.append(random_clamped())  </div><div class="line">    def __repr__(self):  </div><div class="line">        return &apos;Neuron weight size:&#123;&#125;  biase value:&#123;&#125;&apos;.format(len(self.weights), self.biase)  </div><div class="line">   </div><div class="line"># 层  </div><div class="line">class Layer():  </div><div class="line">    def __init__(self, index):  </div><div class="line">        self.index = index  </div><div class="line">        self.neurons = []  </div><div class="line">   </div><div class="line">    def init_neurons(self, n_neuron, n_input):  </div><div class="line">        self.neurons = []  </div><div class="line">        for i in range(n_neuron):  </div><div class="line">            neuron = Neuron()  </div><div class="line">            neuron.init_weights(n_input)  </div><div class="line">            self.neurons.append(neuron)  </div><div class="line">   </div><div class="line">    def __repr__(self):  </div><div class="line">        return &apos;Layer ID:&#123;&#125;  Layer neuron size:&#123;&#125;&apos;.format(self.index, len(self.neurons))  </div><div class="line">   </div><div class="line"># 神经网络  </div><div class="line">class NeuroNetwork():  </div><div class="line">    def __init__(self):  </div><div class="line">        self.layers = []  </div><div class="line">   </div><div class="line">    # input:输入层神经元数 hiddens:隐藏层 output:输出层神经元数  </div><div class="line">    def init_neuro_network(self, input, hiddens , output):  </div><div class="line">        index = 0  </div><div class="line">        previous_neurons = 0  </div><div class="line">        # input  </div><div class="line">        layer = Layer(index)  </div><div class="line">        layer.init_neurons(input, previous_neurons)  </div><div class="line">        previous_neurons = input  </div><div class="line">        self.layers.append(layer)  </div><div class="line">        index += 1  </div><div class="line">        # hiddens  </div><div class="line">        for i in range(len(hiddens)):  </div><div class="line">            layer = Layer(index)  </div><div class="line">            layer.init_neurons(hiddens[i], previous_neurons)  </div><div class="line">            previous_neurons = hiddens[i]  </div><div class="line">            self.layers.append(layer)  </div><div class="line">            index += 1  </div><div class="line">        # output  </div><div class="line">        layer = Layer(index)  </div><div class="line">        layer.init_neurons(output, previous_neurons)  </div><div class="line">        self.layers.append(layer)  </div><div class="line">   </div><div class="line">    def get_weights(self):  </div><div class="line">        data = &#123; &apos;network&apos;:[], &apos;weights&apos;:[] &#125;  </div><div class="line">        for layer in self.layers:  </div><div class="line">            data[&apos;network&apos;].append(len(layer.neurons))  </div><div class="line">            for neuron in layer.neurons:  </div><div class="line">                for weight in neuron.weights:  </div><div class="line">                    data[&apos;weights&apos;].append(weight)  </div><div class="line">        return data  </div><div class="line">   </div><div class="line">    def set_weights(self, data):  </div><div class="line">        previous_neurons = 0  </div><div class="line">        index = 0  </div><div class="line">        index_weights = 0  </div><div class="line">   </div><div class="line">        self.layers = []  </div><div class="line">        for i in data[&apos;network&apos;]:  </div><div class="line">            layer = Layer(index)  </div><div class="line">            layer.init_neurons(i, previous_neurons)  </div><div class="line">            for j in range(len(layer.neurons)):  </div><div class="line">                for k in range(len(layer.neurons[j].weights)):  </div><div class="line">                    layer.neurons[j].weights[k] = data[&apos;weights&apos;][index_weights]  </div><div class="line">                    index_weights += 1  </div><div class="line">            previous_neurons = i  </div><div class="line">            index += 1  </div><div class="line">            self.layers.append(layer)  </div><div class="line">   </div><div class="line">    # 输入游戏环境中的一些条件(如敌机位置), 返回要执行的操作  </div><div class="line">    def feed_forward(self, inputs):  </div><div class="line">        for i in range(len(inputs)):  </div><div class="line">            self.layers[0].neurons[i].biase = inputs[i]  </div><div class="line">   </div><div class="line">        prev_layer = self.layers[0]  </div><div class="line">        for i in range(len(self.layers)):  </div><div class="line">            # 第一层没有weights  </div><div class="line">            if i == 0:  </div><div class="line">                continue  </div><div class="line">            for j in range(len(self.layers[i].neurons)):  </div><div class="line">                sum = 0  </div><div class="line">                for k in range(len(prev_layer.neurons)):  </div><div class="line">                    sum += prev_layer.neurons[k].biase * self.layers[i].neurons[j].weights[k]  </div><div class="line">                self.layers[i].neurons[j].biase = sigmoid(sum)  </div><div class="line">            prev_layer = self.layers[i]  </div><div class="line">   </div><div class="line">        out = []  </div><div class="line">        last_layer = self.layers[-1]  </div><div class="line">        for i in range(len(last_layer.neurons)):  </div><div class="line">            out.append(last_layer.neurons[i].biase)  </div><div class="line">        return out  </div><div class="line">   </div><div class="line">    def print_info(self):  </div><div class="line">        for layer in self.layers:  </div><div class="line">            print(layer)</div></pre></td></tr></table></figure><p>遗传算法：</p><figure class="highlight plain"><figcaption><span>view plain copy</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># &quot;基因组&quot;  </div><div class="line">class Genome():  </div><div class="line">    def __init__(self, score, network_weights):  </div><div class="line">        self.score = score  </div><div class="line">        self.network_weights = network_weights  </div><div class="line">   </div><div class="line">class Generation():  </div><div class="line">    def __init__(self):  </div><div class="line">        self.genomes = []  </div><div class="line">   </div><div class="line">    def add_genome(self, genome):  </div><div class="line">        i = 0  </div><div class="line">        for i in range(len(self.genomes)):  </div><div class="line">            if score_sort &lt; 0:  </div><div class="line">                if genome.score &gt; self.genomes[i].score:  </div><div class="line">                    break  </div><div class="line">            else:  </div><div class="line">                if genome.score &lt; self.genomes[i].score:  </div><div class="line">                    break  </div><div class="line">        self.genomes.insert(i, genome)  </div><div class="line">   </div><div class="line">        # 杂交+突变  </div><div class="line">    def breed(self, genome1, genome2, n_child):  </div><div class="line">        datas = []  </div><div class="line">        for n in range(n_child):  </div><div class="line">            data = genome1  </div><div class="line">            for i in range(len(genome2.network_weights[&apos;weights&apos;])):  </div><div class="line">                if random.random() &lt;= 0.5:  </div><div class="line">                    data.network_weights[&apos;weights&apos;][i] = genome2.network_weights[&apos;weights&apos;][i]  </div><div class="line">   </div><div class="line">            for i in range(len(data.network_weights[&apos;weights&apos;])):  </div><div class="line">                if random.random() &lt;= mutation_rate:  </div><div class="line">                    data.network_weights[&apos;weights&apos;][i] += random.random() * mutation_range * 2 - mutation_range  </div><div class="line">            datas.append(data)  </div><div class="line">        return datas  </div><div class="line">   </div><div class="line">        # 生成下一代  </div><div class="line">    def generate_next_generation(self):  </div><div class="line">        nexts = []  </div><div class="line">        for i in range(round(elitism*population)):  </div><div class="line">            if len(nexts) &lt; population:  </div><div class="line">                nexts.append(self.genomes[i].network_weights)  </div><div class="line">   </div><div class="line">        for i in range(round(random_behaviour*population)):  </div><div class="line">            n = self.genomes[0].network_weights  </div><div class="line">            for k in range(len(n[&apos;weights&apos;])):  </div><div class="line">                n[&apos;weights&apos;][k] = random_clamped()  </div><div class="line">            if len(nexts) &lt; population:  </div><div class="line">                nexts.append(n)  </div><div class="line">   </div><div class="line">        max_n = 0  </div><div class="line">        while True:  </div><div class="line">            for i in range(max_n):  </div><div class="line">                childs = self.breed(self.genomes[i], self.genomes[max_n], n_child if n_child &gt; 0 else 1)  </div><div class="line">                for c in range(len(childs)):  </div><div class="line">                    nexts.append(childs[c].network_weights)  </div><div class="line">                    if len(nexts) &gt;= population:  </div><div class="line">                        return nexts  </div><div class="line">            max_n += 1  </div><div class="line">            if max_n &gt;= len(self.genomes)-1:  </div><div class="line">                max_n = 0</div></pre></td></tr></table></figure><p>NeuroEvolution：</p><figure class="highlight plain"><figcaption><span>view plain copy</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Generations():  </div><div class="line">    def __init__(self):  </div><div class="line">        self.generations = []  </div><div class="line">   </div><div class="line">    def first_generation(self):  </div><div class="line">        out = []  </div><div class="line">        for i in range(population):  </div><div class="line">            nn = NeuroNetwork()  </div><div class="line">            nn.init_neuro_network(network[0], network[1], network[2])  </div><div class="line">            out.append(nn.get_weights())  </div><div class="line">        self.generations.append(Generation())  </div><div class="line">        return out  </div><div class="line">          </div><div class="line">    def next_generation(self):  </div><div class="line">        if len(self.generations) == 0:  </div><div class="line">            return False  </div><div class="line">   </div><div class="line">        gen = self.generations[-1].generate_next_generation()  </div><div class="line">        self.generations.append(Generation())  </div><div class="line">        return gen  </div><div class="line">   </div><div class="line">    def add_genome(self, genome):  </div><div class="line">        if len(self.generations) == 0:  </div><div class="line">            return False  </div><div class="line">   </div><div class="line">        return self.generations[-1].add_genome(genome)  </div><div class="line">   </div><div class="line">class NeuroEvolution():  </div><div class="line">    def __init__(self):  </div><div class="line">        self.generations = Generations()  </div><div class="line">   </div><div class="line">    def restart(self):  </div><div class="line">        self.generations = Generations()  </div><div class="line">   </div><div class="line">    def next_generation(self):  </div><div class="line">        networks = []  </div><div class="line">        if len(self.generations.generations) == 0:  </div><div class="line">            networks = self.generations.first_generation()  </div><div class="line">        else:  </div><div class="line">            networks = self.generations.next_generation()  </div><div class="line">   </div><div class="line">        nn = []  </div><div class="line">        for i in range(len(networks)):  </div><div class="line">            n = NeuroNetwork()  </div><div class="line">            n.set_weights(networks[i])  </div><div class="line">            nn.append(n)  </div><div class="line">   </div><div class="line">        if low_historic:  </div><div class="line">            if len(self.generations.generations) &gt;= 2:  </div><div class="line">                genomes = self.generations.generations[len(self.generations.generations) - 2].genomes  </div><div class="line">                for i in range(genomes):  </div><div class="line">                    genomes[i].network = None  </div><div class="line">   </div><div class="line">        if historic != -1:  </div><div class="line">            if len(self.generations.generations) &gt; historic+1:  </div><div class="line">                del self.generations.generations[0:len(self.generations.generations)-(historic+1)]  </div><div class="line">   </div><div class="line">        return nn  </div><div class="line">   </div><div class="line">    def network_score(self, score, network):  </div><div class="line">        self.generations.add_genome(Genome(score, network.get_weights()))</div></pre></td></tr></table></figure><p>是AI就躲个飞机<br><figure class="highlight plain"><figcaption><span>view plain copy</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import pygame  </div><div class="line">import sys  </div><div class="line">from pygame.locals import *  </div><div class="line">import random  </div><div class="line">import math  </div><div class="line">   </div><div class="line">import neuro_evolution  </div><div class="line">   </div><div class="line">BACKGROUND = (200, 200, 200)  </div><div class="line">SCREEN_SIZE = (320, 480)  </div><div class="line">   </div><div class="line">class Plane():  </div><div class="line">    def __init__(self, plane_image):  </div><div class="line">        self.plane_image = plane_image  </div><div class="line">        self.rect = plane_image.get_rect()  </div><div class="line">   </div><div class="line">        self.width = self.rect[2]  </div><div class="line">        self.height = self.rect[3]  </div><div class="line">        self.x = SCREEN_SIZE[0]/2 - self.width/2  </div><div class="line">        self.y = SCREEN_SIZE[1] - self.height  </div><div class="line">   </div><div class="line">        self.move_x = 0  </div><div class="line">        self.speed = 2  </div><div class="line">   </div><div class="line">        self.alive = True  </div><div class="line">   </div><div class="line">    def update(self):  </div><div class="line">        self.x += self.move_x * self.speed  </div><div class="line">   </div><div class="line">    def draw(self, screen):  </div><div class="line">        screen.blit(self.plane_image, (self.x, self.y, self.width, self.height))  </div><div class="line">   </div><div class="line">    def is_dead(self, enemes):  </div><div class="line">        if self.x &lt; -self.width or self.x + self.width &gt; SCREEN_SIZE[0]+self.width:  </div><div class="line">            return True  </div><div class="line">   </div><div class="line">        for eneme in enemes:  </div><div class="line">            if self.collision(eneme):  </div><div class="line">                return True  </div><div class="line">        return False  </div><div class="line">   </div><div class="line">    def collision(self, eneme):  </div><div class="line">        if not (self.x &gt; eneme.x + eneme.width or self.x + self.width &lt; eneme.x or self.y &gt; eneme.y + eneme.height or self.y + self.height &lt; eneme.y):  </div><div class="line">            return True  </div><div class="line">        else:  </div><div class="line">            return False  </div><div class="line">   </div><div class="line">    def get_inputs_values(self, enemes, input_size=4):  </div><div class="line">        inputs = []  </div><div class="line">   </div><div class="line">        for i in range(input_size):  </div><div class="line">            inputs.append(0.0)  </div><div class="line">   </div><div class="line">        inputs[0] = (self.x*1.0 / SCREEN_SIZE[0])  </div><div class="line">        index = 1  </div><div class="line">        for eneme in enemes:  </div><div class="line">            inputs[index] = eneme.x*1.0 / SCREEN_SIZE[0]  </div><div class="line">            index += 1  </div><div class="line">            inputs[index] = eneme.y*1.0 / SCREEN_SIZE[1]  </div><div class="line">            index += 1  </div><div class="line">        #if len(enemes) &gt; 0:  </div><div class="line">            #distance = math.sqrt(math.pow(enemes[0].x + enemes[0].width/2 - self.x + self.width/2, 2) + math.pow(enemes[0].y + enemes[0].height/2 - self.y + self.height/2, 2));  </div><div class="line">        if len(enemes) &gt; 0 and self.x &lt; enemes[0].x:  </div><div class="line">            inputs[index] = -1.0  </div><div class="line">            index += 1  </div><div class="line">        else:  </div><div class="line">            inputs[index] = 1.0  </div><div class="line">   </div><div class="line">        return inputs  </div><div class="line">   </div><div class="line">class Enemy():  </div><div class="line">    def __init__(self, enemy_image):  </div><div class="line">        self.enemy_image = enemy_image  </div><div class="line">        self.rect = enemy_image.get_rect()  </div><div class="line">   </div><div class="line">        self.width = self.rect[2]  </div><div class="line">        self.height = self.rect[3]  </div><div class="line">        self.x = random.choice(range(0, int(SCREEN_SIZE[0] - self.width/2), 71))  </div><div class="line">        self.y = 0  </div><div class="line">   </div><div class="line">    def update(self):  </div><div class="line">        self.y += 6  </div><div class="line">   </div><div class="line">    def draw(self, screen):  </div><div class="line">        screen.blit(self.enemy_image, (self.x, self.y, self.width, self.height))  </div><div class="line">   </div><div class="line">    def is_out(self):  </div><div class="line">        return True if self.y &gt;= SCREEN_SIZE[1] else False  </div><div class="line">   </div><div class="line">class Game():  </div><div class="line">    def __init__(self):  </div><div class="line">        pygame.init()  </div><div class="line">        self.screen = pygame.display.set_mode(SCREEN_SIZE)  </div><div class="line">        self.clock = pygame.time.Clock()  </div><div class="line">        pygame.display.set_caption(&apos;是AI就躲个飞机&apos;)  </div><div class="line">   </div><div class="line">        self.ai = neuro_evolution.NeuroEvolution()  </div><div class="line">        self.generation = 0  </div><div class="line">   </div><div class="line">        self.max_enemes = 1  </div><div class="line">                # 加载飞机、敌机图片  </div><div class="line">        self.plane_image = pygame.image.load(&apos;plane.png&apos;).convert_alpha()  </div><div class="line">        self.enemy_image = pygame.image.load(&apos;enemy.png&apos;).convert_alpha()  </div><div class="line">   </div><div class="line">    def start(self):  </div><div class="line">        self.score = 0  </div><div class="line">        self.planes = []  </div><div class="line">        self.enemes = []  </div><div class="line">   </div><div class="line">        self.gen = self.ai.next_generation()  </div><div class="line">        for i in range(len(self.gen)):  </div><div class="line">            plane = Plane(self.plane_image)  </div><div class="line">            self.planes.append(plane)  </div><div class="line">   </div><div class="line">        self.generation += 1  </div><div class="line">        self.alives = len(self.planes)  </div><div class="line">   </div><div class="line">    def update(self, screen):  </div><div class="line">        for i in range(len(self.planes)):  </div><div class="line">            if self.planes[i].alive:  </div><div class="line">                inputs = self.planes[i].get_inputs_values(self.enemes)  </div><div class="line">                res = self.gen[i].feed_forward(inputs)  </div><div class="line">                if res[0] &lt; 0.45:  </div><div class="line">                    self.planes[i].move_x = -1  </div><div class="line">                elif res[0] &gt; 0.55:  </div><div class="line">                    self.planes[i].move_x = 1  </div><div class="line">   </div><div class="line">   </div><div class="line">                self.planes[i].update()  </div><div class="line">                self.planes[i].draw(screen)  </div><div class="line">   </div><div class="line">                if self.planes[i].is_dead(self.enemes) == True:  </div><div class="line">                    self.planes[i].alive = False  </div><div class="line">                    self.alives -= 1  </div><div class="line">                    self.ai.network_score(self.score, self.gen[i])  </div><div class="line">                    if self.is_ai_all_dead():  </div><div class="line">                        self.start()  </div><div class="line">   </div><div class="line">          </div><div class="line">        self.gen_enemes()  </div><div class="line">   </div><div class="line">        for i in range(len(self.enemes)):  </div><div class="line">            self.enemes[i].update()  </div><div class="line">            self.enemes[i].draw(screen)  </div><div class="line">            if self.enemes[i].is_out():  </div><div class="line">                del self.enemes[i]  </div><div class="line">                break  </div><div class="line">   </div><div class="line">        self.score += 1  </div><div class="line">   </div><div class="line">        print(&quot;alive:&#123;&#125;, generation:&#123;&#125;, score:&#123;&#125;&quot;.format(self.alives, self.generation, self.score), end=&apos;\r&apos;)  </div><div class="line">   </div><div class="line">    def run(self, FPS=1000):  </div><div class="line">        while True:  </div><div class="line">            for event in pygame.event.get():  </div><div class="line">                if event.type == QUIT:  </div><div class="line">                    pygame.quit()  </div><div class="line">                    sys.exit()  </div><div class="line">   </div><div class="line">            self.screen.fill(BACKGROUND)  </div><div class="line">   </div><div class="line">            self.update(self.screen)  </div><div class="line">   </div><div class="line">            pygame.display.update()  </div><div class="line">            self.clock.tick(FPS)  </div><div class="line">   </div><div class="line">    def gen_enemes(self):  </div><div class="line">        if len(self.enemes) &lt; self.max_enemes:  </div><div class="line">            enemy = Enemy(self.enemy_image)  </div><div class="line">            self.enemes.append(enemy)  </div><div class="line">   </div><div class="line">    def is_ai_all_dead(self):  </div><div class="line">        for plane in self.planes:  </div><div class="line">            if plane.alive:  </div><div class="line">                return False  </div><div class="line">        return True  </div><div class="line">   </div><div class="line">   </div><div class="line">game = Game()  </div><div class="line">game.start()  </div><div class="line">game.run()</div></pre></td></tr></table></figure></p><h2 id="AI的工作逻辑"><a href="#AI的工作逻辑" class="headerlink" title="AI的工作逻辑"></a>AI的工作逻辑</h2><p>假设你是AI，你首先繁殖一个种群（50个个体），开始的个体大都是歪瓜裂枣（上来就被敌机撞）。但是，即使是歪瓜裂枣也有表现好的，在下一代，你会使用这些表现好的再繁殖一个种群，经过代代相传，存活下来的个体会越来越优秀。其实就是仿达尔文进化论，种群-&gt;自然选择-&gt;优秀个体-&gt;杂交、变异-&gt;种群-&gt;循环n世代。</p><p>ai开始时候的表现：<br><img src="http://blog.topspeedsnail.com/wp-content/uploads/2016/12/ai1.gif" alt="是AI就躲个飞机 - 纯Python实现人工智能图片被拉扁了 sorry"></p><p>经过几百代之后，ai开始娱乐的躲飞机：</p><p><img src="http://blog.topspeedsnail.com/wp-content/uploads/2016/12/ai2.gif" alt="是AI就躲个飞机 - 纯Python实现人工智能"></p><p>代码：<a href="https://github.com/xiongdemao/py_game_AI_plane.git" target="_blank" rel="external">https://github.com/xiongdemao/py_game_AI_plane.git</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自：&lt;a href=&quot;http://blog.csdn.net/u014365862/article/details/54380422&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;是AI就躲个飞机-纯Python实现人工智能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很久
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>opencv安装问题`ippicv_linux_20140513.tgz...`</title>
    <link href="http://yoursite.com/2017/11/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/opencv%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%60ippicv_linux_20140513.tgz...%60/"/>
    <id>http://yoursite.com/2017/11/13/机器学习/opencv安装问题`ippicv_linux_20140513.tgz...`/</id>
    <published>2017-11-13T13:06:58.000Z</published>
    <updated>2021-02-19T13:32:13.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ubuntu14-04安装OpenCV3-0-http-blog-csdn-net-u011762313-article-details-47263845"><a href="#Ubuntu14-04安装OpenCV3-0-http-blog-csdn-net-u011762313-article-details-47263845" class="headerlink" title="Ubuntu14.04安装OpenCV3.0 :http://blog.csdn.net/u011762313/article/details/47263845"></a>Ubuntu14.04安装OpenCV3.0 :<a href="http://blog.csdn.net/u011762313/article/details/47263845" target="_blank" rel="external">http://blog.csdn.net/u011762313/article/details/47263845</a></h2><h2 id="opencv安装问题ippicv-linux-20140513-tgz"><a href="#opencv安装问题ippicv-linux-20140513-tgz" class="headerlink" title="opencv安装问题ippicv_linux_20140513.tgz..."></a>opencv安装问题<code>ippicv_linux_20140513.tgz...</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">-- ICV: Downloading ippicv_linux_20140513.tgz...</div><div class="line">CMake Error at 3rdparty/ippicv/downloader.cmake:71 (file):</div><div class="line">  file DOWNLOAD HASH mismatch</div><div class="line"></div><div class="line">    for file: [/home/kuo/opencv/opencv-3.0.0-alpha/3rdparty/ippicv/downloads/linux-d80cb24f3a565113a9d6dc56344142f6/ippicv_linux_20140513.tgz]</div><div class="line">      expected hash: [d80cb24f3a565113a9d6dc56344142f6]</div><div class="line">        actual hash: [d41d8cd98f00b204e9800998ecf8427e]</div><div class="line"></div><div class="line">Call Stack (most recent call first):</div><div class="line">  3rdparty/ippicv/downloader.cmake:108 (_icv_downloader)</div><div class="line">  cmake/OpenCVFindIPP.cmake:212 (include)</div><div class="line">  cmake/OpenCVFindLibsPerf.cmake:12 (include)</div><div class="line">  CMakeLists.txt:449 (include)</div><div class="line"></div><div class="line"></div><div class="line">CMake Error at 3rdparty/ippicv/downloader.cmake:75 (message):</div><div class="line">  ICV: Failed to download ICV package: ippicv_linux_20140513.tgz.</div><div class="line">  Status=35;&quot;SSL connect error&quot;</div><div class="line">Call Stack (most recent call first):</div><div class="line">  3rdparty/ippicv/downloader.cmake:108 (_icv_downloader)</div><div class="line">  cmake/OpenCVFindIPP.cmake:212 (include)</div><div class="line">  cmake/OpenCVFindLibsPerf.cmake:12 (include)</div><div class="line">  CMakeLists.txt:449 (include)</div><div class="line"></div><div class="line"></div><div class="line">-- Configuring incomplete, errors occurred!</div><div class="line">See also &quot;/home/kuo/opencv/opencv-3.0.0-alpha/CMakeFiles/CMakeOutput.log&quot;.</div><div class="line">See also &quot;/home/kuo/opencv/opencv-3.0.0-alpha/CMakeFiles/CMakeError.log&quot;.</div></pre></td></tr></table></figure><p><a href="https://osdn.net/projects/sfnet_opencvlibrary/downloads/3rdparty/ippicv/ippicv_linux_20140513.tgz/" target="_blank" rel="external">https://osdn.net/projects/sfnet_opencvlibrary/downloads/3rdparty/ippicv/ippicv_linux_20140513.tgz/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Ubuntu14-04安装OpenCV3-0-http-blog-csdn-net-u011762313-article-details-47263845&quot;&gt;&lt;a href=&quot;#Ubuntu14-04安装OpenCV3-0-http-blog-csdn-net-u
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
