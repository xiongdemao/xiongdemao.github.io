<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[《3D Point Cloud Registration for Localization using a Deep Neural Network Auto-Encoder》读书笔记]]></title>
      <url>/2017/11/13/%E9%9A%8F%E7%AC%94/%E3%80%8A3D%20Point%20Cloud%20Registration%20for%20Localization%20using%20a%20Deep%20Neural%20Network%20Auto-Encoder%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><a href="https://www.researchgate.net/publication/316455393_3D_Point_Cloud_Registration_for_Localization_Using_a_Deep_Neural_Network_Auto-Encoder" target="_blank" rel="external">3D Point Cloud Registration for Localization using a Deep Neural Network Auto-Encoder</a></p>
<p>题目：基于深度神经网络自编码的3D激光点云匹配定位方法</p>
<blockquote>
<p>介绍：<br>本文将介绍一种3D点云定位方法，该方法需要一个全局的3D点云地图，以及几次连续扫描得到局部的点云子集，而无需考虑先验信息。</p>
<p>局部的点云子集又称为超点集。超点集是连续几次扫描得到的、外围具有重合区域的点云，并初步过滤了低质量的、不重要的区域。它们表示环境的几何结构信息。</p>
<p>通常的方法是人工设计关键点描述子的进行粗略匹配，本文利用超点集代替了关键点，这样可以充分利用点云的几何结构关系，进行更准确仿射变换。并借鉴了机器视觉的研究趋势，将自编码深度神经网络应用于局部3D点云。本方法经过许多具有挑战性的点云数据检验，相比以往的方法，在有噪音、缺少数据的情况下，更加鲁棒。</p>
</blockquote>
<p>##摘要</p>
<p> 　　我们提供了一种在大规模点云和近距离扫描点云之间的匹配的算法，提供了一个完全独立于两个点云坐标系统初始位置信息的定位解决方案。该算法表示为“LORAX”，它选择用我们称之为“超点集”的局部点云子集和”低维描述符”描述每个点的几何结构。然后使用这些描述符来推断潜在的匹配区域以进行有效的粗略匹配处理，然后进行微调阶段。通过覆盖重叠的点云来选择超点集合，然后过滤出低质量或不明显的区域。“描述符”是使用最先进的无监督机器学习来计算的，利用基于深度神经网络的自编码技术。<br> 　　<br>　　针对普遍的使用手动设计的关键点描述符来进行粗点云匹配，这个新颖的框架提供了一个强有力的替代方法。利用超点集而不是关键点集，可以更好地利用可用的几何数据来找到正确的转换。在编码局部三维几何结构时使用深度神经网络自编码器代替传统的“描述符”继续在其他计算机视觉应用中看到的趋势，并且确实取得优异的结果。该算法在具有挑战性的点云匹配数据集上进行了测试，与之前的方法比较其优点体现在对密度变化，噪声和缺失数据的鲁棒性。 </p>
<p>##１．引言</p>
<p>###1.1概况<br> 　　点云与图像类似，含有描述我们周围的世界的对象的语义信息。 与图像数据不同的是，图像数据在一个固定的网格场景保存了二维目标，点云是一组的在统一的坐标系中无组织的三维点，它捕捉的是3D空间信息。点云数据分析方法已经在过去的几十年里的到了发展[^footnote]，并且这个领域正在不断取得显著性突破的一个重要原因是经济实惠高质量的3D扫描技术的进步[^footnote]，机器学习突破和新的有趣的应用程序。</p>
<p>　　点云匹配的定义是找到在两个独立的点云坐标系之间的转换公式。它是“即时定位与地图构建”（SLAM）[^footnote] [^footnote]，场景的三维重建[^footnote]等的关键。它已成为基于视觉的自主驾驶的的核心问题[^footnote]。点云匹配取得了很大的进展，但仍然有重大的进展挑战，如大规模点云的匹配，具有低场景重叠且没有先前的位置信息。<br>　　<br> 　　今天的户外定位严重依赖于GPS技术，在地面增强系统的辅助下，提高准确性 。卫星定位需要接收来自多个卫星的信号，准确度受到卫星数量，天气和物理障碍物阻塞或改变信号路径的影响。这项技术在在一些卫星地面基础设施不完善的地区是不准确的[^footnote]。<br> 　　<br>　　在本文中，我们重点介绍一种定位技术，它依靠匹配一个全局点云和一个在同一个场景内不同时间扫描得到的局部点云技术。匹配在云的初始坐标系中与邻近信息无关。我们定义了两种类型的点云：一个“全局点云”，由一个大型户外场景扫描得到的点云，它的坐标是现实世界的地理坐标系统；另外一个是“ 局部点云”，由一个小得多的点云组成，它处在在全局点云场景内的未知位置和未知方向。在局部点云和全局点云之间的转换公式是使用一个机器学习的几何分析进行计算而得到的。这种技术作为一种高质量的定位方法在户外环境是完全与GPS的独立的。『 参见图1』 </p>
<p><img src="https://www.researchgate.net/profile/Gil_Elbaz/publication/316455393/figure/fig1/AS:486979151372288@1493116285586/Figure-1-Registration-between-a-close-proximity-point-cloud-colored-and-a-large-scale.ppm" alt="这里写图片描述"><br>          <em>图1 绿色为超点集，灰色为全局的3D点云地图</em>
　　</p>
<p>###1.2相关工作</p>
<p> 　　匹配算法分为粗匹配和精细匹配。粗略的匹配算法对点云的位置没有先前的临近假设，只是一个粗略的对齐，这意味着他的一个损失函数比较宽松。精细的匹配算法假定输入点云大致对齐; 因此它们利用点之间的初始接近度来调整点云坐标系之间的对齐。当连续获取两个场景之间大量重叠时，或者作为粗略匹配过程的后续，可以使用精细匹配 。</p>
<p>　　虽然已经有大量的点云粗匹配方法[^footnote]，但粗匹配仍然是一个开放的挑战，有很大的改进空间。在快速点特征直方图[^footnote][^footnote]（FPFH）算法中，一个针对点云内的每个点在多个尺度上计算基于直方图的描述符。多尺度计算中的显著持续直方图被标记为关键点，然后将其匹配以找到点云之间的配准。其他描述符也用于定位和描述关键点。参见[^footnote]进行调查。一些例子是3D-SIFT [^footnote]，NARF [^footnote]和SHOT [11]。许多复杂的手工编码特征被提出，其目标是旋转和平移不变，对噪声具有鲁棒性。</p>
<p>　　在二维计算机视觉领域，由于深度学习领域的突破性研究 [^footnote]，类似的手动编码特征的发展时期已经戛然而止。使用深度学习方法，从数据中计算出更先进的特征（具有超越人性化设计的复杂性），推进了二维计算机视觉领域的主要领域，如检测，分类，分割，定位和配准 [^footnote]。这些方法几乎专注于二维数据。非结构化的，连续的和大的点云数据集产生了这样的极端的问题，这个问题是2维数据不能直接的适应3维空间。为了在我们的方法中利用三维数据，点云被密集采样，并且每个局部表面的2.5维数据被捕获和组合。深度学习的先进工具被应用到这些数据中，以无监督机器学习的形式来实现高质量降维 [^footnote]，作为粗略点云匹配的关键阶段 。<br>　　<br>　　针对机载LIDAR点云的粗略配准，开发了一种基于线性平面匹配的不同方法[^footnote]。 依靠线性结构的存在，这种方法仅限于特定的数据集类。<br>　　<br>　　点云之间精细配准的问题已经被深入研究，目前在线应用如SLAM存在高质量的解决方案[3,4]。 解决方案围绕迭代最近点（ICP）[^footnote]算法及其改进[^footnote]。 一个值得注意的基于傅里叶域[^footnote]扩展高斯图像相关性的精细配准方法被提出来作为ICP的一个替代方案，尽管最后一个阶段再次依靠ICP迭代来进行微调。 良好的匹配并不是本研究的重点，尽管为了实现端到端匹配，标准的ICP算法在其最终阶段被使用。<br>　　<br>　　上述所有匹配方法都是针对输入点云对进行设计的，这些输入点云对数量级相差不大，数量较少（低于100万）。</p>
<p>##1.3.贡献<br>　　这项工作提出并测试了两种原创的方法，首次提出基于点云的匹配方法。<br>　　<br>　　1.使用超级点（由随机球体覆盖集选择）作为匹配的基本单位，而不是常用的关键点或局部线性结构。 这利用了更广泛的几何结构，并更好地利用可用数据来发现正确的转换。 此外，它将算法的其余部分的复杂性转化为与点云场景中覆盖的表面积相关，而不是场景中的点数。 它非常简单，快速，并且具有可扩展性。<br>　　<br>　　2.使用深度神经网络自动编码器编码局部3D几何结构。 该方法在图像分析应用程序中提供了最先进的编码。 通过对数据进行调整并在开发的算法流水线中应用这种方法，可以从数据中创建出功能优于人工设计的局部几何特征。<br>　　<br>　　我们在这里展示，结合这些想法在多个具有挑战性的数据集上产生达到期望的的匹配结果。该方法是通用的，它可以处理任何数据，而不管传感器或场景的类型如何。<br>　　<br>　　虽然大多数配准算法处理相似的点云，但我们采用点云的独特问题设置，它们的尺寸明显不同，我们设计的算法对大规模扫描数据有效。 虽然算法需要初始阶段，但在线阶段可以高效地并行执行，使其适用于实时应用程序。</p>
<p>#2.基于“LORAX”的点云匹配算法</p>
<p>　　我们专注于两类点云的匹配：描绘大型户外区域的全局点云，以及从全局点云场景内捕获的小型局部点云。全局点云可以包含多达1亿个3D点，而局部点云可以小2-3个数量级。<br>　　<br>　　在本节中，我们提出使用基于深自动编码器减少的覆盖集（LORAX）的匹配算法来进行定位。</p>
<p>##2.1.算法概貌<br>这个算法包含以下几步：<br>　　1．使用“Random Sphere Cover Set algorithm”算法将点云分为超点集。<br>　　2.为每一个超点集选择一个归一化的局部坐标系。<br>　　3.将超点集数据投影到二维深度图上。<br>　　4.对于超点集进行显著性检测和渗透（ﬁltration）。<br>　　5.利用深度遗传网络自编码器来降维。<br>　　6.寻找相关描述符之间的候选匹配。<br>　　7.利用本地化搜索来进行粗匹配。<br>　　8.微调迭代最近点。<br>接下来，算法的每一步将进行详尽的解释和分析。</p>
<p>##2.2.Random Sphere Cover Set (RSCS）“随机球体覆盖集”　　<br>　　首先超点集（SP）将用作匹配过程的基本单位被定义。 每个超点集是描述局部曲面的点的一个子集。重叠是允许的（即一个点可以包含在几个中超点）。 为了获得云中几乎所有点（〜95％）的覆盖率，我们建议采用下面的迭代过程：（1）随机选择一个不属于任何SP的点“P”; （2）将一个新的SP定义为位于以“P”为中心的固定半径为“Rsphere”的球体内的一组点。<br>　　<img src="https://www.researchgate.net/profile/Gil_Elbaz/publication/316455393/figure/fig2/AS:486979151372290@1493116285843/Figure-2-Coverage-of-points-vs-RSCS-iterations.ppm" alt="这里写图片描述"><br>      Figure 2: Coverage of points vs. RSCS iterations</p>
<p>　　这个简单的过程，我们称之为RSCS，具有有趣的属性，可以估计半径“Rsphere”参数。在随机球体填充中，非重叠的球体显示出填充大约64％的封闭3D区域[^footnote]。 假设“Vlocal”是包含局部点云的球体的体积，并且是在算法的最后阶段使用的匹配数量。 为了确保最少m个SP对匹配，我们选择半径“Rsphere”，这样就有可能在体积”Vlocal“内随机打包”2m“个球体。</p>
<p><img src="http://chart.googleapis.com/chart?cht=tx&chl=R_%7Bsphere%7D%5Capprox%20(%5Cfrac%7B3%7D%7B4*pi%7D*%5Cfrac%7B0.64%7D%7B2*m%7D*V_%7Blocal%7D)%5E%7B%5Cfrac%7B1%7D%7B3%7D%7D" style="border:none;">              (1)</p>
<p>　　在补充材料中分析了给定局部和全局点云内在参数的RSCS算法创建的SP数量。结果表明，该方法覆盖了点云呈指数衰减的点。 图2显示了作为RSCS迭代函数的覆盖点的百分比。 RSCS算法在全局点云上应用一次，在局部点云上多次应用，以便在后期的鲁棒性。 如图7（a）和（b）所示，从RSCS的多个应用程序在本地点云上找到的<img src="http://chart.googleapis.com/chart?cht=tx&chl=N%5E%7Blocal%7D_%7BSP%7D" style="border:none;"> SP在算法的下一个阶段被组合成一个代表本地点云的单个集合。</p>
<p>##2.3.为每一个超点集选择一个归一化的局部坐标系<br>　　一个SP的局部坐标系定义如下：原点被设置为SP的质心，然后在SP内点的估计协方差矩阵上使用奇异值分解（SVD）来设置SP的坐标系 。<br>　　假设每个SP描述场景表面在这个阶段被利用。曲面的特征值是具有两个大小相近的大特征向量和一个较小的特征向量。这意味着这些点主要分散在两个维度上，而第三维的变化则显着较低。 z轴被设置为第三特征向量。 为了定义x轴，计算SP的不连续径向切片的平均高度并插入到极坐标直方图中。 然后将x轴设置为与最大仓（bin）对应的方向。 这个局部坐标系统创建不变的SP的位置和方向，同时保留其几何特性。</p>
<p>##2.4.深度图投影<br>　　将每个SP代入本地坐标系后，可以直接进行比较。 然而，结果将是完全不可靠的，因为它们已经受到点密度变化和随机噪声的影响。 降低维度对于减轻这些影响至关重要。 为此，连续点位置数据被转换成离散图像格式（大小为[dim1，dim1]）。将SP缩放到图像dim1的尺寸（我们使用dim1 = 64），之后将每个点的z轴高度投影到每个对应像素的深度图上。 最后，将图像裁剪为[dim2，dim2]（我们使用dim2 = 32），以去除深度图中SP的圆形边缘。 参见图3（a）和（b）</p>
<p><img src="https://www.researchgate.net/profile/Gil_Elbaz/publication/316455393/viewer/AS:486979138789376@1493116282891/background/4.png" alt="这里写链接内容"><br>(a) Example SP     (b) The depth map     (c) The reconstruction<br>Figure 3: Super-point depth map projection  </p>
<p>　　为了减少噪音和变化的密度的影响，最大的过滤器和平均过滤器被应用于图像。SP信息的修改可以通过从深度图重构SP来可视化。 如图3（c）所示，重构可靠地保持与原始SP点云相同的几何形状和质量，同时在未知稀疏区域上创建完整覆盖。</p>
<p>##2.5.显著性检测和过滤</p>
<p>　　为了获得最快和最好的质量的匹配，应该减少通过这条管线的不相关SP的数量。不相关的SP被三个标准过滤：密度，几何特性和显着性水平。<br>　　<strong>密度测试</strong>：密度是以绝对值和其他SP值来衡量的。这意味着包含少于<img src="http://chart.googleapis.com/chart?cht=tx&chl=N_%7Bd%7D" style="border:none;">点的SP被滤除。另外，与其最接近的相邻SP（在SP重心之间测量的欧几里德距离）相比，具有相对较少点的SP也被滤除。<br>　　<strong>几何质量测试</strong>：测量各个局部坐标系内各个SP的高度。过滤掉在表面的低高度SP信号。<br>　　<strong>显着性测试</strong>：来自全局点云的SP深度图被重新整形成长度为<img src="http://chart.googleapis.com/chart?cht=tx&chl=d%5E%7B2%7D_%7Bim2%7D" style="border:none;">的列“深度矢量”。对于该组深度矢量执行主成分分析（PCA）。仅使用前三个特征向量精确重构的SP（SP来自于局部和全局点云）已经在数据集中发现了几何特征，因此被滤除。这降低了位于不同点云区域的类似SP的匹配机会 。</p>
<p>##2.6.通过自动编码器来降维<br>　　该算法的一个关键阶段是比较全局和局部点云内部的SP几何。 即使具有相同的语义含义，高维物体的比较也容易产生较大的噪音和方差。为了比较SP几何的语义，必须在保留最大几何信息的同时减小深度图像的尺寸。本文研究了两种单独的降维方法。 第一个基于PCA，第二个基于深度自动编码器（DAE）。
　　</p>
<p>###2.6.1线性降维<br>　　PCA方法通过将其投影到较低维的线性超平面上来降低数据的维数。 根据全局点云SP的深度向量（类似于显着性检测，但是这里k&gt; 3）来计算基本向量的基数。 对应于特征向量的特征值定义重建每个SP所需的叠加。 保持SP的几何信息的紧凑表示特征被表示为主分量分析超点特征（PCAF）。 需要注意的是，PCA创建了数据的线性投影，这导致高数据损失和相对较大的简化形式。 这种方法是DAE方法的可比基准。
　　</p>
<p>###2.6.2深度自动编码器降维</p>
<p>　　结果表明，DAE神经网络[16]产生了最先进的图像压缩。 在这里，我们使用这种技术来获得在深度图中捕获的2.5D超点几何体的紧凑表示。<br>　　DAE神经网络架构由编码器和解码器阶段组成。 编码器阶段从输入层开始，然后连接到隐藏层，逐渐减小直到达到所需的紧凑尺寸。 解码器阶段从数据的紧凑表示开始; 每个后继隐含层的维数较高，直到输出层维数达到输入维数为止。损失函数定义为输入层和输出层之间的像素误差，优化网络实现用图像的最佳紧凑表示。<br>　　为了设计适合我们应用的DAE，我们进行了大量的实证测试和优化。 我们得出结论，一个具有4个完全连接隐藏层的网络，使用每个层之间的S形非线性激活函数和输入层上的压差（DO），会返回满意的结果。 为了进一步减少网络中的参数数量，第四和第一隐藏层以及第三和第二层以相同权重彼此镜像，同时保留单独学习的偏差值。 这种权重共享意味着反向传播学习算法被约束为编码和解码过程优化相同的权重[^footnote]。 缩小的紧凑尺寸由编码器输出尺寸定义。 该架构使用以下维度：1032（input），[1032,128]（L1），[128,10]（L2），[10,128]（L3），（128,1032）（L4），1032（output）。 参见图4。<br>　　<img src="http://img.blog.csdn.net/20171109204736502?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>Figure 4: Deep Auto-encoder architecture</p>
<p>　　利用数据驱动和综合深度图的组合来初始训练深度神经网络。使用100,000个超点集深度图来训练所提出的DAE。 训练阶段是无监督的，即不需要手动注释数据，网络以随机权重初始化。 这个培训过程是有效的，网络可以通过周期性地更新，从扫描的本地云中获取附加的点云数据来改善。 流程训练过程可能很长，但编码部分可以在线并且快速地激活。<br>　　这种紧凑的低维表示可以被看作是捕获整个SP的几何信息的特征。 它代表一个固定的低维向量的SP，与SP中的点数不相关。 与在每个点上竞争的局部描述符相比，这是在复杂度的降低方面的实质性改进。 基于SP自动编码器的特征（SAF）可以用于许多任务，例如检测或分类3D对象，而在这里我们优化它的匹配。<br>　　　<img src="http://img.blog.csdn.net/20171109204803901?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>Figure 5: Visualization of deep auto-encoder input, reduction and reconstruction</p>
<p>　　图5示出了输入到DAE中的深度图的例子，并且被简化为10维SAF（为了更好的可视化而被放大的5×2矩阵），然后通过解码器被重构成原始尺寸。 深度图的高度被转换为颜色：蓝色对应于零高度，深红色对应于最大高度。 重建与输入不相同，但它确实捕获了SP的一般几何形状。 这对噪声的鲁棒性和对我们的应用而言至关重要的小的改变是最佳的，同时捕获重要的SP几何特性。<br>　　为了进一步显示DAE的有效性，分析从数据内学习到的特征，并将其与从PCA方法计算的特征向量进行比较。为此，将SAF向量中的每个维度的独立激活输入到解码器中以可视化 DAE学到了什么。参见图6。<br>　　PCA的特征向量和DAE的独立解码器激活是紧凑表示“构建块”的两种创建的方法。 图6（a）显示了每个特征向量的增长的复杂性，它是根据特征值排序的。 这与图6（b）的非结构化DAE激活图像形成对比。 PCA方法可以近似为只有线性函数的单隐层神经网络[^footnote]。 这意味着为了表示复杂的几何图形，需要复杂的特征向量。 由于DAE中数值的多层叠加，复杂的几何体使用相对简单的“构建块”来表示。
　　</p>
<p><img src="http://img.blog.csdn.net/20171109203628375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(a) PCA eigenvectors</p>
<p><img src="http://img.blog.csdn.net/20171109203728076?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(b) DAE independent decoder activations<br>Figure 6: Compact Representation Vectors</p>
<p>##2.7.选择理想的匹配</p>
<p>　　在用SAF向量描述每个SP之后，我们选择一组类似描述的SP对作为匹配的候选。 通过测量SAF特征之间的欧几里得距离，局部点云中的每个SP与来自全局点云（我们将K设置为3）的K个最近邻居配对。 当与i + 1最邻近点相关的距离显着大于与i最近邻点相关的距离时，我们滤出候选值i + 1到K.请注意，<img src="http://chart.googleapis.com/chart?cht=tx&chl=P_%7Bcandidates%20%7D" style="border:none;">的数量是O（<img src="http://chart.googleapis.com/chart?cht=tx&chl=N%5E%7Blocal%7D%20_%7BSP%7D" style="border:none;">）的顺序。 为了得到所选择的候选点云集的数量，考虑一个全局点云数量为1000万点，局部点云数为50万的问题。 对于这个集合，我们从本地点云中获得大约200个SP，这意味着选择了大约550个候选者。 参见图7（c）。</p>
<p><img src="http://img.blog.csdn.net/20171111192506338?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(a) Global point cloud with RSCS (b) Local point cloud<br>with RSCS<br><img src="http://img.blog.csdn.net/20171111192603271?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(c) Matching candidate connections</p>
<p>Figure 7: RSCS and matching candidates (each point is col-<br>ored according to the last RSCS iteration to cover it)</p>
<p>##2.8.基于本地化搜索的粗匹配<br> 　　为了找到点云之间的6DoF（6自由度）变换，至少需要3个匹配（为了鲁棒性，我们使用了m = 6）。处理至少<img src="http://chart.googleapis.com/chart?cht=tx&chl=P%5E%7Bcandidates%7D%20_%7Bm%7D%0A" style="border:none;">的搜索空间大小是不切实际的（对于上面的例子超过<img src="http://chart.googleapis.com/chart?cht=tx&chl=10%5E%7B13%7D" style="border:none;">）。因此，我们考虑每个迭代只有m个候选对，所有全局云点可以包含在一个体积不超过<img src="http://chart.googleapis.com/chart?cht=tx&chl=V_%7Blocal%7D" style="border:none;">的球体中。这将转换选项的搜索空间减少了8到9个数量级（将上例中的选项减少到约40,000）。我们使用RANSAC [^footnote]程序，迭代地选择6个候选对，计算变换，并通过测量本地点云中的变换点与其全局点云中的最近邻点之间的平均（物理）距离来检查一致性。 （为了节省运行时间，我们只转换局部点云的稀释版本。）我们测试了10,000个随机选择（约1/4的搜索空间）。我们不是只选择最好的评分变换作为粗略配准步骤的结果，而是记录5个最佳变换（T1，…，T5），其中局部点云不重叠。然后将精细调整步骤（在下一节中介绍）应用于每个调整步骤，最后得到最佳评分细节的调整步骤将被选中。</p>
<p>##2.9.微调最近迭代点<br>　　简单迭代最近点（ICP）精细调整被执行，由T1，…，T5转换中的每一个进行初始化。选择具有最低ICP损失的配准，定义LORAX输出变换。这个步骤源于我们认识到“最接近的”粗配准结果并不总是与正确的配准结果相关，因为优化函数中存在许多局部最小值。最好的匹配会根据经验显示对应于约75％的案例中最好的粗略匹配，约18％的案例是次优匹配，约4％是第三好的匹配。 这个阶段可以被任何微调方法取代。</p>
<p>##2.10.效率讨论<br>　　我们目前的实施并未针对实时性能进行优化。然而，考虑到全局点云通过航空LIDAR或立体重建提前捕获，该算法确实有潜力被纳入现场设备并执行实时定位。我们设计了神经网络训练过程和全局点云到降维阶段的计算。来自全局点云的紧凑描述符可以与全局点云的降采样版本一起保存到在线设备中。一旦本地点云从全局场景内的未知位置在线捕获，SP分区，归一化，显着性检测和DAE降维阶段可以独立地为每个SP并行执行。然后，基于KD树[^footnote]，基于RANSAC的局部候选搜索[^footnote]和ICP [^footnote]的KNN候选选择也可以并行地（使用多个CPU和/或GPU）并行地完成。 RSCS方法和SAF描述符的代码可在以下网址获得：<a href="https%EF%BC%9A//github.com/gilbaz/LORAX">https：//github.com/gilbaz/LORAX</a></p>
<p>#3.实验及其结果<br>　　在整个实验中显示了RSCS SP创建优于FPFH持久性关键点检测的优点，以及SAF与FPFH描述符相比的描述性质量。 每个登记阶段都使用“点云配准算法的挑战性数据集”[^footnote]进行了广泛的测试，将近距离点云与两个不同季节拍摄的同一场景的全局大型点云进行匹配。此外， 为了更好地理解不同类型噪声对配准的影响，采用大尺度航空点云进行对比实验。</p>
<p>##3.1.挑战性的数据集配准测试<br>　　所使用的数据集包含许多户外场景的点云，由地面LIDAR扫描仪捕捉，多个季节。 通过将每个场景中捕获的点云激光扫描拼接在一起，创建出真实的全局点云。 这个点云数据是测试LORAX算法的理想选择。 我们通过将局部点云记录到同一场景的全局点云中进行测试，并在不同季节拍摄。 这种设置确实充满挑战。 场景中包含一些刚性静止的物体，如凉亭结构，灯柱和长凳，还有人，灌木和树枝等不一致的物体。 这个挑战由于扫描角度和遮挡而丢失信息而提高。<br>　　参见图1为LORAX结果的一个例子。 颜色表示局部点云（匹配之后）中每个点与全局点云中最近邻点之间的相对距离，其中绿色更接近，红色更远。<br>　　我们测试和比较RSCS超点集与关键点的匹配表现，还有FPFH描述符与PCAF的匹配表现，以及FPFH描述符与SAF的匹配表现。结果总结在表1中。<br><img src="http://img.blog.csdn.net/20171111201208718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>　　为了比较基于关键点的方法，我们遵循[9] 。 “RSCS + FPFH”方法计算与RSCS超点集中心点对应的FPFH描述符。报告的每个结果是12个局部点云的平均性能，来自“Gazebo”数据集的9个和来自“Wood”数据集的3个。对于每个记录结果，我们测量[^footnote]中使用和定义的相对平移误差（RTE）和相对旋转误差（RRE）。当RTE低于预定义的阈值（我们使用1米）时，匹配结果被定义为二进制“成功”。对于每个测试，我们报告二进制成功率和成功测试的平均RTE和RRE分数。所有方法使用相同的微调程序，因此实现相似的RTE，但是它们具有不同的结果RRE和二进制成功率，表示质量以及粗略匹配的鲁棒性。</p>
<p>　　表1显示，使用RSCS组合的点云细分和DAE来创建SAF会产生最稳健和最高质量的匹配结果。从RSCS获得的鲁棒性在KP + FPFH与RSCS + FPFH的比较中是明显的。 RSCS + FPFH到RSCS + PCAF和RSCS + SAF的比较显示了使用基于机器学习的功能优于手动设计的功能的优点，以及SAF优于PCAF的优点。</p>
<p>##3.2.噪声，遮挡和密度敏感度测试</p>
<p>　　为了进一步测试LORAX的质量和局限性，我们使用了一些由[^footnote]提供的城市户外场景点云。这些点云大约150万个点，描绘了250平方米的大面积。参见图8的例子。图8：描绘与周围的房屋和道路的小山的空中扫描点云。<br>　　<img src="http://img.blog.csdn.net/20171111201938808?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>Figure 8: Aerial scanned point cloud depicting hill with sur-<br>rounding houses and roads. An example from [30] dataset</p>
<p>　　为了能够控制噪声，密度和遮挡的不同参数，我们进行半合成实验，从大的原始点云中裁剪半径为15-50米的小点云.将LORAX和KP + FPFH配准算法在局部点云的改动版本上进行测试，并将其与原始全局点云进行匹配。<br>　　噪声修改包括：（1）随机移动10％，20％，50％ （2）随机抽取10％，20％，50％的点，测试对云密度的敏感性;（3）模拟去除局部随机球内的10％， 20％，50％的遮挡。 参见图9。<br><img src="http://img.blog.csdn.net/20171111202755641?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>(a) Original cropped local point cloud<br>(b) Same cloud with simulated noise and occlusions<br>Figure 9: Simulating noise, density change, and occlusions</p>
<p>　　对3个全景场景中的50个随机剪切点云进行了测试，分析了下采样（密度变化）（DS），随机重定位噪声（RN）和遮挡（OC）对各自的影响。图10总结了结果。为了澄清，在给定噪声指定的情况下，图上的每个点代表50个配准测试的平均二进制成功率。在这个实验中，二进制成功率由2.5米的RTE阈值定义（由于全局点云的大尺度）。<br>　　<br>　　<img src="http://img.blog.csdn.net/20171111204639218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>Figure 10: Noise, Occlusion, and Density Sensitivity Tests</p>
<p>　　由于深度图投影阶段，这些结果显示对点密度具有高度的鲁棒性。随机噪声对我们的算法影响不大，因为SAF表示法只捕捉主要的几何特征。堵塞是最难处理的缺陷。该算法在较低的水平上克服了遮挡，但是受到很大的阻碍。总的来说，我们看到LORAX对大量的随机噪声，密度变化和遮挡不太​​敏感，而且其鲁棒性只在极端水平下才会恶化。 KP + FPFH算法（虚线）由于在全局点云的许多部分缺乏“关键点”诱导场景特征而在干净的局部点云上进行测试时返回了较低的二进制成功率。这些结果增加了对这项研究方向的信心。</p>
<p>#4.总结<br>　　本文提出了一种创新的点云配准算法LORAX。该算法以室外定位为目标，处理两个匹配点云之间的点数差异存在多个挑战，并涉及大量的点数。提出了两种原始方法：1）使用超点集（由随机点云的点集合组成）作为匹配的基本单位，而不是关键点; 2）使用深度神经网络自编码器编码局部3D几何结构。我们已经表明，这些想法的组合在具有挑战性的数据集上产生有希望的匹配结果。该方法是通用的，它可以处理任何数据，而不管传感器或场景的类型如何。而且，虽然它包含了一个有效的训练阶段，但在线阶段可以高效并行执行，使其适用于实时应用。</p>
<p>　　在未来的工作中;我们打算将这种方法适用于具有小场景重叠的类似大小的点云。另一个有趣的方向是设计这种算法的多尺度超级版本。最后，使用具有高度和颜色信息输入的卷积自动编码器可以产生出色的超点功能，可用于各种点云分析任务。</p>
<p>#感谢<br>　　这项研究得到了以色列工业和贸易部的Technion和Magnet Omek联盟的部分支持。 作者要感谢Elbit Systems Ltd为这项研究提供数据。</p>
<p>#摘要<br> 1.<a href="https://www.researchgate.net/publication/236675142_Registration_of_3D_Point_Clouds_and_Meshes_A_Survey_from_Rigid_to_Nonrigid" target="_blank" rel="external">Registration of 3D Point Clouds and Meshes: A Survey from Rigid to Nonrigid.</a>《3D点云与网格匹配：一个由刚性到非刚性的调查》</p>
<blockquote>
<p>摘要<br>3D表面匹配变换多个3D数据集到同一坐标系中以便对准这些集合中的重叠部分。最近的调查覆盖的是刚性或非刚性匹配，但很少有团队能够从不同方面讨论全过程。我们的研究有两个目的：（i）对两种类型的匹配进行了全面调查，专注于三维点云和网格，（ii）从数据拟合的角度更好地了解匹配。匹配是与数据拟合密切相关的，它包括三个核心：模式选择，相关性和约束性，优化。研究这些组分：（i）提供了一个比较不同新奇技术的比较基础，（ⅱ）揭示了刚性和非刚性在representations问题匹配的相似性 ;（iii）显示非刚性匹配过度拟合产生的原因，同时增加我们对内在技术的兴趣。我们进一步总结匹配的一些实际问题，其中包括初始化和评估，并讨论一些我们自己的意见，见解和可预见的发展趋势研究 </p>
</blockquote>
<p>2.<a href="https://www.nature.com/nphoton/journal/v4/n7/abs/nphoton.2010.148.html" target="_blank" rel="external">Brent Schwarz. Mapping the world in 3d. Nat. Photonics,4(7):429–430, 2010.[3] Hugh D</a>《激光雷达：用3D来映射世界》</p>
<blockquote>
<p>摘要<br>具有64个半导体激光器的旋转传感器头的高分辨率激光雷达系统可以以前所未有的细节高效生成3D环境地图。</p>
</blockquote>
<p>3.<a href="http://ieeexplore.ieee.org/document/1638022/" target="_blank" rel="external">Hugh Durrant-Whyte and Tim Bailey. Simultaneous localization and mapping: part i. IEEE robotics&amp; automation magazine, 13(2):99–110, 2006.</a>《定位同时建图：部分一》</p>
<blockquote>
<p>摘要<br>本文介绍了同时定位和建图（SLAM）问题和解决SLAM问题的基本方法，并总结了该方法的关键实现和演示。 虽然仍然有许多实际问题需要克服，特别是在更复杂的户外环境中，一般的SLAM方法现在已经成为机器人的一个很好的理解和建立的部分。 本教程的另一部分概述了解决SLAM中剩余的一些问题的最近的工作，包括计算，功能表示和数据关联。</p>
</blockquote>
<p>4 <a href="http://xueshu.baidu.com/s?wd=paperuri:%288d7f210f73ebaf20d4e03873a1dbe06d%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http://link.springer.com/chapter/10.1007/978-3-319-10605-2_54&amp;ie=utf-8&amp;sc_us=9457780068583818158" target="_blank" rel="external">Jakob Engel, Thomas Schöps, and Daniel Cremers.Lsd-slam: Large-scale direct monocular slam. In European Conference on Computer Vision, pages 834–849. Springer, 2014</a>《Lsd-slam：大规模直接单目slam》</p>
<blockquote>
<p>摘要<br>我们提出了一种直接（无特征）的单眼SLAM算法，与当前直接方法的最新技术相比，它允许构建大规模，一致的环境地图。 除了基于直接图像对齐的高度精确的姿态估计之外，3D环境被实时重建为具有关联半密集深度图的关键帧的姿态图。 这些是通过对大量像素小基线立体比较进行滤波而获得的。 明确的尺度漂移感知公式允许该方法在具有挑战性的序列上操作，包括场景尺度的大的变化。 主要的推动力是两个关键的新颖之处：（1）一种新颖的直接跟踪方法，在sim（3）上运行，从而明确地检测尺度漂移，（2）优雅的概率解决方案，包括噪声深度值的影响跟踪。 由此产生的直接单目SLAM系统在CPU上实时运行。</p>
</blockquote>
<p>5 <a href="http://www.sciencedirect.com/science/article/pii/S0924271610000894" target="_blank" rel="external">Norbert Haala and Martin Kada. An update on automatic 3d building reconstruction. ISPRS Journal of Photogrammetry and Remote Sensing, 65(6):570–580, 2010</a>《三维建筑物自动重建的最新进展 》</p>
<blockquote>
<p>摘要<br>近二十年前，开发3D城市模型的工具就开始了。 从一开始，全自动重建系统就设想满足高效数据采集的需要。 然而，对城市自动建模的研究仍然是一个非常活跃的领域。 本文将回顾一些当前的方法，以全面阐述重建方法的现状和各自的原则。 最初，自动城市建模只针对多面体建筑物，主要反映了各自的屋顶形状和建筑物的脚印。 为此目的，使用空中图像或激光扫描。 除了这些发展之外，本文还将回顾目前从地面数据收集中生成更加详细的立面几何的方法。</p>
</blockquote>
<p>6 <a href="http://ieeexplore.ieee.org/document/5940562/" target="_blank" rel="external">Jesse Levinson, Jake Askeland, Jan Becker, Jennifer Dolson, David Held, Soeren Kammel, J Zico Kolter,Dirk Langer, Oliver Pink, Vaughan Pratt, et al. Towards fully autonomous driving: Systems and algorithms. In Intelligent Vehicles Symposium (IV), 2011 IEEE, pages 163–168. IEEE, 2011.</a>《走向全自主驾驶：系统与算法 》</p>
<blockquote>
<p>摘要<br>为了在交通不可预知的城市中实现车辆的自主运行，几个实时系统必须互操作，包括环境感知，本地化，规划和控制。此外，具有适当传感器，计算硬件，网络和软件基础设施的强大车辆平台是至关重要的。我们以前发表了“2007年DARPA城市挑战赛”中斯坦福大学Junior的概述。这场比赛是一场封闭式的比赛，虽然历史悠久，在这个领域取得了很大的进展，但并不能完全代表现实世界中存在的情况。在本文中，我们总结了我们最近的研究，旨在在更现实的情况下实现安全和强大的自主操作。首先，三个无监督算法自动校准我们的64光束旋转激光雷达，精度优于繁琐的手工测量。然后，我们生成环境的高分辨率地图，随后用于以厘米为单位的在线定位。现在，改进的感知和识别算法使Junior能够将障碍物追踪和分类为骑自行车者，行人和车辆;红绿灯也被检测到。一个新的计划系统使用这个输入数据来生成每秒数千个候选轨迹，动态地选择最佳路径。改进的控制器不断选择油门，刹车和转向驱动，从而最大限度地提高舒适性并最大限度地减少轨迹误差。所有这些算法都可以在阳光或雨中以及白天或黑夜中工作。通过这些系统的共同运作，Junior已经在各种现实条件下成功记录了数百英里的自主操作。</p>
</blockquote>
<p>7.<a href="http://xueshu.baidu.com/s?wd=paperuri:%285efb3bee0d5669b9cccf514725980b8f%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http://trid.trb.org/view/894431&amp;ie=utf-8&amp;sc_us=6302811145085811136" target="_blank" rel="external">US DoD. Global positioning system standard positioning service performance standard. Assistant secretary of defense for command, control, communications, and intelligence, 2001 </a>《全球定位系统标准定位服务性能标准 》</p>
<blockquote>
<p>摘要<br>美国全球定位系统（GPS）标准定位服务（SPS）由天文定位，导航和定时（PNT）信号组成，为全球和平的民用，商业和科学用途免费提供直接用户费用。 此SPS性能标准（SPS PS）根据广播信号参数和GPS星座设计来规定SPS性能的等级。 美国政府致力于达到并超越本SPS规定的最低服务水平，这一承诺已经编入美国法律（10U.S.C.2281（b））。</p>
</blockquote>
<p>8.<a href="https://www.researchgate.net/publication/280040097_A_Benchmark_Survey_of_Rigid_3D_Point_Cloud_Registration_Algorithms" target="_blank" rel="external">Ben Bellekens, Vincent Spruyt, Rafael Berkvens,Rudi Penne, and Maarten Weyn. A benchmark survey of rigid 3d point cloud registration algorithms</a>《刚性三维点云配准算法的基准研究 》</p>
<blockquote>
<p>摘要<br>先进的用户界面传感器能够使用特定的光学技术（如飞行时间，结构化光线或立体视觉）三维观察环境。由于现代传感器能够融合环境的深度和颜色信息的成功，出现了不同领域的新焦点。本调查研究了不同的最先进的配准算法，它们能够确定两个相应的三维点云之间的运动。本次调查从数学的角度出发，通过解释两种确定性的方法，即主成分分析（PCA）和奇异值分解（SVD），以及迭代最近点（ICP）及其变体等迭代方法。我们将不同算法的性能与基于真实世界数据集的精度和鲁棒性进行比较。这次调查的主要贡献包括基于现实世界数据集的性能基准，该数据集包括Microsoft Kinect相机的3D点云，以及不同匹配方法的数学概述，这些概念通常用于同时定位并绘制和3D扫描。我们的基准测试结果表明，ICP点对表面法是最精确的算法。除了精度，鲁棒性的结果，我们可以得出结论：在SVD方法之后应用ICP点对点方法的组合给出最小误差。</p>
</blockquote>
<p>9 . <a href="http://ieeexplore.ieee.org/document/5152473/?arnumber=5152473&amp;tag=1" target="_blank" rel="external">Radu Bogdan Rusu, Nico Blodow, and Michael Beetz.Fast point feature histograms (fpfh) for 3d registration.In Robotics and Automation, 2009. ICRA’09. IEEE International Conference on, pages 3212–3217. IEEE,2009</a>《快速点特征直方图（fpfh）三维配准 》</p>
<blockquote>
<p>摘要<br>在我们最近的工作<a href="http://ieeexplore.ieee.org/document/4795593/" target="_blank" rel="external">[1] </a><a href="http://ieeexplore.ieee.org/document/4650967/" target="_blank" rel="external">[2]</a>中，我们提出了点特征直方图（PFH）作为鲁棒的多维特征，描述三维点云数据集点p周围的局部几何。在本文中，我们修改了它们的数学表达式，并针对重叠点云视图的3D配准问题对其稳健性和复杂性进行了严格的分析。更具体地说，我们提出几个优化，通过缓存先前计算的值或修改其理论公式来大幅减少计算时间。后者导致了一种新型的局部特征，称为快速点特征直方图（FPFH），其保留了PFH的大部分区分能力。此外，我们提出了一个在线计算实时应用的FPFH特征的算法。为了验证我们的结果，我们证明了它们的3D注册效率，并提出了一个新的基于样本共识的方法，将两个数据集带入本地非线性优化器的收敛区域：SAC-IA（SAmple Consensus Initial Alignment）。</p>
</blockquote>
<p>10 .  <a href="https://www.researchgate.net/publication/221066028_Aligning_Point_Cloud_Views_using_Persistent_Feature_Histograms" target="_blank" rel="external">Radu Bogdan Rusu, Nico Blodow, Zoltan Csaba Marton, and Michael Beetz. Aligning point cloud views using persistent feature histograms. In 2008 IEEE/RSJ  International Conference on Intelligent Robots and Systems, pages 3384–3391. IEEE, 2008 </a><br>《使用持久特征直方图调整点云视图 》</p>
<blockquote>
<p>摘要<br>在本文中，我们研究了将点云数据视图对齐成一个一致的全局模型的持久点特征直方图的使用情况。 给定噪声点云的集合，我们的算法估计了一组强大的16D特征，它们描述了每个点在本地的几何形状。 通过分析不同尺度上的特征的持续性，我们提取了一个最佳的表征给定点云的最优集合。 所产生的持久性特征被用于初始对准算法中以估计近似登记输入数据集的刚性变换。 该算法通过将数据集转换为其收敛盆地为迭代配准算法（如ICP（迭代最近点））提供了良好的起点。 我们表明，我们的方法是不变的构成和采样密度，并能应付来自室内和室外激光扫描的嘈杂数据。</p>
</blockquote>
<p>11 .<a href="https://link.springer.com/chapter/10.1007/978-3-642-15558-1_26" target="_blank" rel="external">Federico Tombari, Samuele Salti, and Luigi Di Stefano.Unique signatures of histograms for local surface description. In European conference on computer vision, pages 356–369. Springer, 2010 </a>《局部曲面描述的直方图唯一签名 》</p>
<blockquote>
<p>摘要<br>本文涉及局部三维描述符的表面匹配。 首先，我们将现有的方法分为两类：签名和直方图。 然后，通过讨论和实验，指出了局部参照系唯一性和可重复性的关键问题。 基于这些观察，我们制定了一个新的表面表示的综合提案，其中包括一个新的独特和可重复的本地参考框架，以及一个新的三维描述符。 后者位于签名和直方图之间的交集处，以便在描述性和鲁棒性之间取得更好的平衡。 对公开可用数据集的实验以及使用Spacetime Stereo获得的范围扫描提供了对我们提议的全面验证。</p>
</blockquote>
<p>12 .  <a href="http://xueshu.baidu.com/s?wd=paperuri:%28d27927f10820b09c2b7fbb1d5fb7944c%29&amp;filter=sc_long_sign&amp;sc_ks_para=q=A%203-dimensional%20sift%20descriptor%20and%20its%20application%20to%20action%20recognition&amp;tn=SE_baiduxueshu_c1gjeupa&amp;ie=utf-8&amp;sc_us=5087117483461663566" target="_blank" rel="external">Paul Scovanner, Saad Ali, and Mubarak Shah. A 3-dimensional sift descriptor and its application to action recognition. In Proceedings of the 15th ACM international conference on Multimedia, pages 357–360. ACM, 2007. </a>《一种三维SIFT描述子及其在动作识别中的应用》</p>
<blockquote>
<p>摘要<br>在本文中，我们引入一个3维SIFT用于视频或3D图像（如MRI数据）的描述符。 我们还展示了这种新的描述符如何能够更好地表现视频数据在动作识别应用中的3D特性。 本文将展示3D SIFT如何以优雅和高效的方式超越以前使用的描述方法。 我们用一包词的方式来表示视频，并提出一种方法来发现时空词之间的关系，以便更好地描述视频数据。</p>
</blockquote>
<p>13 .  <a href="https://www.researchgate.net/publication/260320178_NARF_3D_Range_Image_Features_for_Object_Recognition" target="_blank" rel="external">Bastian Steder, Radu Bogdan Rusu, Kurt Konolige,and Wolfram Burgard. Narf: 3d range image features for object recognition. In Workshop on Deﬁning and Solving Realistic Perception Problems in Personal Robotics at the IEEE/RSJ Int. Conf. on Intelligent Robots and Systems (IROS), volume 44, 2010</a>《物体识别的三维距离图像特征》</p>
<blockquote>
<p>摘要<br>我们提出了一个新的方法：对于兴趣点检测和特征描述符计算三维范围数据，我们把它称为NARF（正常对齐径向特征）。 该方法明确地使用了对象边界信息，并试图提取表面稳定但附近有实质性变化的区域的特征。</p>
</blockquote>
<p>14 . <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks" target="_blank" rel="external">Alex Krizhevsky, Ilya Sutskever, and Geoffrey E Hinton. Imagenet classiﬁcation with deep convolutional neural networks. In Advances in neural information processing systems, pages 1097–1105, 2012</a>《基于深度卷积神经网络的图像分类》<a href="http://blog.csdn.net/motianchi/article/details/50851074" target="_blank" rel="external">『中文翻译』</a></p>
<blockquote>
<p>摘要<br>我们训练了一个大型深度卷积神经网络来将ImageNet LSVRC-2010数据集中的120万张高清图片分到1000个不同的类别中。在测试数据中，我们将Top-1错误（分配的第一个类错误）和Top-5错误（分配的前五个类全错）分别降到了37.5%和17.0%，这比之前的技术水平要好得多。这个神经网络拥有6千万的参数和65万个神经元，共有五个卷积层，其中一些卷积层后面跟着最大池化层，还有利用softmax函数进行1000类分类的最后三个全连接层。为了让训练速度更快，我们使用不饱和【？non-saturating】神经元，并利用高效的GPU实现卷积操作。为了减少全连接层的过拟合，我们采用了一种最近研发出来的正则化方法——“DROPOUT”，它被证明十分有效。我们也在比赛中加入了这一模型的一个变体，第二名的26.2%相比，我们通过将TOP-5错误降到了15.3%而获胜。</p>
</blockquote>
<p>15.<a href="https://www.nature.com/nature/journal/v521/n7553/full/nature14539.html" target="_blank" rel="external">Yann LeCun, Yoshua Bengio, and Geoffrey Hinton.Deep learning. Nature, 521(7553):436–444, 2015</a>《深度学习》</p>
<blockquote>
<p>摘要<br>深度学习允许由多个处理层组成的计算模型来学习具有多个抽象级别的数据表示。 这些方法极大地改进了语音识别，视觉对象识别，对象检测和诸如药物发现和基因组学等许多其他领域的最新技术。 深度学习通过使用反向传播算法来发现大型数据集中复杂的结构，以指示机器应如何改变其内部参数，以用于根据前一层的表示计算每层中的表示。 深卷积网络在处理图像，视频，语音和音频方面取得了突破性进展，而经常性网络则对文本和语音等连续数据指明了方向。</p>
</blockquote>
<p>16.<a href="http://www.cs.toronto.edu/~hinton/science.pdf" target="_blank" rel="external">Geoffrey E Hinton and Ruslan R Salakhutdinov. Reducing the dimensionality of data with neural networks. Science, 313(5786):504–507, 2006.</a>《用神经网络降低数据的维数》<a href="https://segmentfault.com/a/1190000007665145" target="_blank" rel="external">中文介绍</a></p>
<blockquote>
<p>摘要<br>通过训练具有小中心层的多层神经网络来重建高维输入向量，可将高维数据转换为低维码。 梯度下降可用于微调这种“自动编码器”网络中的权重，但只有在初始权重接近良好的解决方案时，才能正常工作。 我们描述了一个初始化权重的有效方法，允许深度自动编码器网络学习低于主要组件分析的低维代码作为降低数据维度的工具。</p>
</blockquote>
<p>17 .  <a href="https://www.researchgate.net/publication/303531275_Registration_of_Airborne_LiDAR_Point_Clouds_by_Matching_the_Linear_Plane_Features_of_Building_Roof_Facets" target="_blank" rel="external">Hangbin Wu and Hongchao Fan. Registration of airborne lidar point clouds by matching the linear plane features of building roof facets. Remote Sensing,8(6):447, 2016.</a>《基于线性平面有限元匹配的机载激光雷达点云配准》</p>
<blockquote>
<p>摘要<br>通过寻找和匹配相应的线性面特征，提出了一种新的机载LiDAR点云配准方法。线性平面特征是城市地区的一种常见特征，便于从点云中获取特征参数。利用这些线性特征参数，采用三维刚体协调变换模型，对不同轨迹的点云进行配准。该方法由三个步骤组成。在第一步中，应用OpenStreetMap辅助方法来选择简单结构的屋顶对作为匹配的相应屋顶面。在第二步中，计算所选屋顶小面的法向矢量并将其输入到一个超定的观测系统中，以估计配准参数。在第三步中，使用这些参数进行匹配。选择一个具有两个轨迹点云的案例数据集来验证所提出的方法。为了评估匹配后点云的准确性，手动选择了40个检查点;评估结果表明，一般精度为0.96米，约为点云分辨率的1.6倍。此外，选择两个重叠区域来测量两个轨迹之间的表面差异。根据分析结果，平均表面距离约为0.045-0.129米。</p>
</blockquote>
<p>[18] <a href="http://ieeexplore.ieee.org/document/121791/?arnumber=121791&amp;tag=1" target="_blank" rel="external">Paul J Besl and Neil D McKay. Method for registration of 3-d shapes. In Robotics-DL tentative, pages 586–606. International Society for Optics and Photonics, 1992.</a>《三维形状的配准方法 》</p>
<blockquote>
<p>摘要<br>作者描述了一种通用的，与表示无关的方法，用于准确计算包括自由曲线和曲面在内的三维形状的高效配准。该方法处理完整的六个自由度，并基于迭代最近点（ICP）算法，该算法仅需要一个过程来找到几何实体上到给定点的最近点。 ICP算法总是单调地收敛到均方距离度量的最近局部最小值，并且在最初的几次迭代期间收敛速度是快速的。因此，对于具有一定“形状复杂度”的特定类别的对象，给定适当的初始旋转和平移集合，可以通过测试每个初始配准来在全部六个自由度上全局最小化均方距离度量。这种方法的一个重要应用是在形状检查之前将来自未固定的刚性物体的感测数据与理想的几何模型进行配准。实验结果显示了配准算法在点集，曲线和曲面上的能力</p>
</blockquote>
<p>[19] <a href="http://ieeexplore.ieee.org/abstract/document/924423/" target="_blank" rel="external">Szymon Rusinkiewicz and Marc Levoy. Efﬁcient variants of the icp algorithm. In 3-D Digital Imaging and Modeling, 2001. Proceedings. Third International Conference on, pages 145–152. IEEE, 2001.</a>《ICP算法的有效变种 》</p>
<blockquote>
<p>摘要<br>当相对姿态的初始估计已知时，ICP（迭代最近点）算法被广泛用于三维模型的几何对准。 已经提出了ICP的许多变体，从点的选择和匹配到最小化策略影响算法的所有阶段。 我们列举和分类许多这些变体，并评估它们对达到正确对齐的速度的影响。 为了改善具有小特征的近平面网格（如刻写曲面）的收敛性，引入了一个基于法向空间均匀采样的新的变体。 最后，我们提出了针对高速优化的ICP变体的组合。 我们演示一个能够在几十毫秒内对齐两个距离图像的实现，假设一个好的初始猜测。 这种能力可用于实时三维模型采集和基于模型的跟踪。</p>
</blockquote>
<p>[20] <a href="http://xueshu.baidu.com/s?wd=paperuri:%28474b882d8a591cde1db98d7ff1f766b3%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1640899&amp;ie=utf-8&amp;sc_us=16791238355415665744" target="_blank" rel="external">Ameesh Makadia, Alexander Patterson, and Kostas Daniilidis.Fully automatic registration of 3d point clouds. In 2006 IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR’06), volume 1, pages 1297–1304. IEEE, 2006.</a>《三维点云的全自动配准》</p>
<blockquote>
<p>摘要<br>我们提出了一种三维点云匹配的新技术，这种技术做了很少的假设：我们避免任何手动粗略对齐或使用地标，位移可以任意大，两点集合可以有很少的重叠。 粗对准是通过估计来自两个扩展高斯图像的3D旋转来实现的，即使当引起它们的数据集具有部分重叠时也是如此。该技术基于傅立叶域中两个EGI的相关性，并利用球面和旋转谐波变换。对于具有低重叠的配对而言，不能进行关键的验证步骤，可以通过对齐由EGI生成的星座图像来获得旋转对准。 旋转对齐的组通过使用体积函数的傅里叶变换的相关性来匹配。 在最后一步中，通过只用很少的迭代运行迭代最接近的点来获得精确的对齐。</p>
</blockquote>
<p>[21] <a href="https://www.researchgate.net/publication/230991730_The_Density_of_Random_Close_Packing_of_Spheres" target="_blank" rel="external">GD Scott and DM Kilgour. The density of random close packing of spheres. Journal of Physics D: Applied Physics, 2(6):863, 1969.</a>《球体随机密堆积的密度》</p>
<blockquote>
<p>摘要<br>随机包装硬球的模型表现出简单液体性质的一些特征，例如， 包装密度和径向分布。 球体的最大填充密度的值可以由模型确定，如果注意确保边界表面的随机堆积和如果对边界处的体积误差进行校正的话。 随机松散密度和随机密集填充密度的实验报告是用有机玻璃，尼龙和钢球在空气中的八分之一，还有浸在油中的钢球。 已经用多达80 000个钢球并借助机械振动器进行了一系列随机密堆积密度的测量。 计算机对结果的分析允许一步，双参数外推到无限量。 如此获得的随机密堆积密度的数字是06366±00005，这表示精度比先前的结果提高了一个数量级。</p>
</blockquote>
<p> [22] <a href="http://xueshu.baidu.com/s?wd=paperuri:%28479376c9d4a3d372841ed9b2acbb0f8e%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=FFC68D55B6C24229FF3D33D0891ED180?doi=10.1.1.476.479&amp;rep=rep1&amp;type=pdf&amp;ie=utf-8&amp;sc_us=8907340944497699214" target="_blank" rel="external">Yann LeCun et al. Generalization and network design strategies. Connectionism in perspective, pages 143–155, 1989.</a>《通用化与网络设计策略 》</p>
<blockquote>
<p>摘要<br>连接系统的一个有趣的特性是他们从例子中学习的能力。尽管该领域最近的工作集中于减少学习时间，但是学习机的最重要的特征是它的泛化性能。人们通常认为，除非对任务有一些了解，否则就不能实现对现实世界问题的良好泛化性能。反向传播网络通过对网络的体系结构和权重施加约束来提供指定这种知识的方式。一般来说，这样的参数可以看作是参数空间的特定变换。建立一个图像识别的约束网络似乎是一个可行的任务。我们描述了一个小的手写数字识别问题，表明即使问题是线性可分的，单层网络也表现出较差的广义性能。在层次结构中使用移位不变特征检测器时，多层约束网络在此任务上表现得非常好。这些结果证实了最小化网络中的自由参数数量的观点增强了概括性。</p>
</blockquote>
<p>[23] <a href="https://www.researchgate.net/publication/222464584_Optimal_Unsupervised_Learning_in_a_Single-Layer_Linear_Feedforward_Neural_Network" target="_blank" rel="external">Terence D Sanger. Optimal unsupervised learning in a single-layer linear feedforward neural network. Neural networks, 2(6):459–473, 1989.</a>《在单层线性前馈神经网络最优的无监督学习 》</p>
<blockquote>
<p>摘要<br>讨论了单层线性前向神经网络中无监督学习的一种新方法。提出了一种基于保留输出单元中最大信息的最优性原则。介绍了一种基于Hebbian学习规则的无监督学习算法，实现了理想的最优性。该算法找到了输入相关矩阵的特征向量，证明了其以概率1收敛。描述了仅使用局部“突触”修改规则训练神经网络的实现。结果表明，该算法与统计学（因子分析和主成分分析）和神经网络（自监督反向传播，或“编码器”问题）中的算法密切相关。因此，它提供了对经典统计技术方面的某些神经网络行为的解释。提出了使用线性网络来解决图像编码和纹理分割问题的例子。此外，它表明，该算法可以用来找到“视觉接受领域”在性质上类似于在灵长类视网膜和视觉皮层中发现的。</p>
</blockquote>
<p>[24] <a href="https://dl.acm.org/citation.cfm?id=358692" target="_blank" rel="external">Martin A Fischler and Robert C Bolles.Random sample consensus: a paradigm for model ﬁtting with applications to image analysis and automated cartography. Communications of the ACM, 24(6):381–395,1981.</a>《随机样本一致性：模型与应用程序进行图像分析和自动绘图的范例》</p>
<blockquote>
<p>摘要<br>介绍了一个新的范例，即随机样本一致性（RANSAC），用于拟合实验数据模型。 RANSAC能够解释/平滑包含大量重大错误的数据，因此非常适合自动图像分析应用，其中解释基于易错特征检测器提供的数据。 本文的一个主要部分描述了RANSAC在位置确定问题（LDP）中的应用：给定描绘具有已知位置的一组地标的图像，确定获得图像的空间点。 为了响应RANSAC的要求，需要获得解决方案所需的最小标记数量的新结果，并给出算法以计算封闭形式的这些最小标志性解决方案。这些结果为在困难的观察和分析条件下能够解决LDP的自动化系统提供了基础。 还介绍了实现细节和计算示例。</p>
</blockquote>
<p>[25] <a href="http://xueshu.baidu.com/s?wd=paperuri:%282db80d9a80bd71417232d7c26c888f97%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http://dl.acm.org/citation.cfm?id=1409079&amp;ie=utf-8&amp;sc_us=1406914190655001141" target="_blank" rel="external">Kun Zhou, Qiming Hou, Rui Wang, and Baining Guo.Real-time kd-tree construction on graphics hardware.ACM Transactions on Graphics (TOG), 27(5):126,2008.</a>《基于图形硬件的实时KD树构造 》</p>
<blockquote>
<p>摘要<br>我们提出了一个在GPU上构建kd-tree的算法。该算法通过在kd树构造的各个阶段利用GPU的流式架构来实现实时性能。与以前的并行kd-tree算法不同，我们的方法完全以BFS（广度优先搜索）顺序构建树节点。我们还针对上级树的大型节点制定了一个特殊策略，以进一步利用GPU的细粒度并行性。对于这些节点，我们并行化所有几何基元的计算，而不是每个层次上的节点。最后，为了保持kd树质量，我们引入了新的方案来快速评估节点分裂成本。</p>
<p>据我们所知，我们是GPU上的第一个实时kd-tree算法。我们的算法构建的kd树与离线CPU算法构建的kd树质量相当。就速度而言，我们的算法明显快于优化的单核CPU算法，并且与多核CPU算法相比具有竞争性。我们的算法提供了处理GPU上动态场景的一般方法。我们证明了我们的算法在涉及动态场景的应用中的潜力，包括GPU射线追踪，交互式光子映射和点云建模。</p>
</blockquote>
<p>[26] <a href="http://xueshu.baidu.com/s?wd=paperuri:%283ce333febdb3c15020256f7c740c1c7b%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http://ieeexplore.ieee.org/document/6462927/&amp;ie=utf-8&amp;sc_us=3781435091169552354" target="_blank" rel="external">Donghwa Lee, Hyongjin Kim, and Hyun Myung.Gpu-based real-time rgb-d 3d slam. In Ubiquitous Robots and Ambient Intelligence (URAI), 2012 9th International Conference on, pages 46–48. IEEE, 2012.</a>《基于GPU的实时深度3D SLAM》</p>
<blockquote>
<p>摘要<br>本文提出了一种基于GPU（图形处理单元）的实时RGB-D（红 - 绿 - 蓝）深度的三维SLAM（同时定位和映射）系统。 RGB-D数据包含二维图像和每像素深度信息。 首先，通过具有图像特征的3D-RANSAC（三维随机采样共识）算法获得6自由度视觉测距。 而投影ICP（迭代最近点）算法给出了具有深度信息的精确的测距估计结果。 为了加速提取特征和ICP计算，执行基于GPU的并行计算。 在检测到闭环后，基于图的SLAM算法优化了传感器的轨迹和三维图。</p>
</blockquote>
<p>[27] <a href="https://www.researchgate.net/publication/221410064_GPU-Accelerated_Nearest_Neighbor_Search_for_3D_Registration" target="_blank" rel="external">Deyuan Qiu, Stefan May, and Andreas Nüchter.Gpu-accelerated nearest neighbor search for 3d registration.In International Conference on Computer Vision Systems, pages 194–203. Springer, 2009.</a>《GPU加速最近邻三维搜索 》</p>
<blockquote>
<p>摘要<br>最近邻搜索（NnS）被许多计算机视觉算法所采用。 计算复杂度很大，对实时性能构成挑战。 基本的问题是快速处理大量的数据，这通常是通过高度复杂的搜索方法和并行处理来解决的。 我们展示了像迭代最近点算法（ICP）那样的基于NNS的视觉算法可以实现实时能力，同时保持紧凑的尺寸和适中的能量消耗，因为它在机器人和许多其他领域中是需要的。 该方法利用图形处理单元（GPGPU）上的通用计算概念，并与CPU上的并行处理进行比较。 我们将这种方法应用于三维扫描注册问题，与顺序CPU实现相比，加速因子为88。</p>
</blockquote>
<p>[28] <a href="http://xueshu.baidu.com/s?wd=paperuri:%28d1cecbd6c9b21c9caf0355aebfa848db%29&amp;filter=sc_long_sign&amp;sc_ks_para=q=Challenging%20data%20sets%20for%20point%20cloud%20registration%20algorithms&amp;tn=SE_baiduxueshu_c1gjeupa&amp;ie=utf-8&amp;sc_us=6333769492514580415" target="_blank" rel="external">François Pomerleau, Ming Liu, Francis Colas, and Roland Siegwart. Challenging data sets for point cloud registration algorithms. The International Journal of Robotics Research, 31(14):1705–1711, 2012.</a>《用于点云配准算法的具有挑战性的数据集 》</p>
<blockquote>
<p>摘要<br>最近文献中匹配方案的数量已经开始出现。例如，迭代的最近点可以被认为是许多基于激光的定位和测绘系统的骨干。虽然它们被广泛使用，但在公平的基础上比较匹配解决方案是一个常见的挑战。主要限制是克服当前数据集中缺乏准确的基本事实，这些数据集通常涵盖仅在一个小范围的组织级别的环境。在计算机视觉领域，斯坦福三维扫描库通过提供高质量的扫描对象和精确定位，推动了点云配准算法和对象建模领域。我们的目标是为机器人和计算机视觉社区提供类似的高质量工作材料，但是以风景而不是物体。我们提出在现代机器人容易遇到的覆盖环境多样性的地点采集八个点云序列，从公寓内部到林地区域。数据集的核心由三维激光点云组成，每个姿态都提供支持数据（重力，磁北和GPS）。为了确保扫描仪的全球定位精度在毫米范围内，不受环境条件的影响，我们做了特别的努力。这将允许在映射具有挑战性的环境（例如在现实世界中发现的环境）时改进匹配算法的开发</p>
</blockquote>
<p>[29] <a href="http://ieeexplore.ieee.org/document/7789576/" target="_blank" rel="external">Yanxin Ma, Yulan Guo, Jian Zhao, Min Lu, Jun Zhang, and Jianwei Wan. Fast and accurate registration of structured point clouds with small overlaps.</a>《小重叠结构点云的快速准确配准 》</p>
<blockquote>
<p>摘要<br>为了进行大旋转，小重叠的结构化点云的配准，本文提出了一种基于密集点的方向角和投影信息的算法。 该算法充分利用了结构化环境的几何信息。 它由两部分组成：旋转估计和翻译估计。 对于旋转估计，为点云定义方向角，然后通过比较角度分布之间的差异来获得旋转矩阵。 对于平移估计，将点云投影到三个正交平面上，然后对投影图像执行相关运算以计算平移矢量。 已经对几个数据集进行了实验。 实验结果表明，该算法在精度和效率两方面都优于现有技术。</p>
</blockquote>
<p>[30] Elbit Systems Ltd. </p>
<blockquote>
<p>Elbit系统有限公司 是一家总部位于以色列的国际防务电子公司</p>
</blockquote>
<p>[^footnote].<br>  [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tack笔记]]></title>
      <url>/2017/11/13/%E9%9A%8F%E7%AC%94/tack%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-运动目标跟踪简介"><a href="#1-运动目标跟踪简介" class="headerlink" title="1.运动目标跟踪简介"></a>1.运动目标跟踪简介</h2><pre><code>运动目标跟踪在军事制导，视觉导航，机器人，智能交通，公共安全等领域有着广泛的应用。例如，在车辆违章抓拍系统中，车辆的跟踪就是必不可少的。在入侵检测中，人、动物、车辆等大型运动目标的检测与跟踪也是整个系统运行的关键所在。所以，在计算机视觉领域目标跟踪是一个很重要的分支。
</code></pre><p><strong>运动目标检测是运动目标跟踪的前提</strong>；运动目标检测，依据目标与摄像机之间的关系可以分为静态背景下的运动检测与动态背景下的运动检测。</p>
<h4 id="一，静态背景下的运动检测：整个监控过程中只有目标在运动；主要包括以下几种方法。"><a href="#一，静态背景下的运动检测：整个监控过程中只有目标在运动；主要包括以下几种方法。" class="headerlink" title="一，静态背景下的运动检测：整个监控过程中只有目标在运动；主要包括以下几种方法。"></a>一，静态背景下的运动检测：整个监控过程中只有目标在运动；主要包括以下几种方法。</h4><pre><code>1，背景差分法；整个监控过程中，需要不停地维护一个“纯背景”。对于任意一帧监控画面而言，将其与纯背景进行差分，从而得到出现在当前画面中的运动目标。该方法对光照变化、天气、背景变化比较敏感。而且，需要不停进行地依靠学习来维护一个纯背景画面。此外，背景的维护和更新，阴影去除等对运动目标的检测至关重要。

2，帧间差分法；通过相邻帧之间的差值计算，来获得运动目标的位置、形状等信息的方法。该方法对光照的适应能力很强，但由于运动目标像素上的相似性，从而不能完整地检测出运动目标。需要提醒的是，有研究人员将相邻帧间的差分进行改进，得到三帧差分方法。即，利用相邻三帧之间的差值计算，来进行运动目标的检测。该方法经很多研究人员和工程师的实际测试，证明了其在特定环境中优良的性能。

3，光流法；在空间中，运动可以用运动场描述；而在一个图像平面上，物体的运动往往是通过图像序列中图像灰度分布的不同来体现, 从而使空间中的运动场转移到图像上就表示为光流场。光流场反映了图像上每一点灰度的变化趋势。它可看成是带有灰度的像素点在图像平面上运动而产生的瞬时速度场,也是一种对真实运动场的近似估计。在比较理想的情况下，它能够检测独立运动的对象而不需要预先知道场景的任何信息, 可以很精确地计算出运动物体的速度，并且可用于动态场景的情况。但是大多数光流方法的计算相当复杂, 对硬件要求比较高, 不适于实时处理, 而且对噪声比较敏感,抗噪性差。
</code></pre><h4 id="二，动态背景下的运动检测：监控过程中，目标和背景都在发生运动或变化；在运动目标检测的应用环境中，动态背景相比而言更加复杂。根据相机的运动形式，可以分为以下两种："><a href="#二，动态背景下的运动检测：监控过程中，目标和背景都在发生运动或变化；在运动目标检测的应用环境中，动态背景相比而言更加复杂。根据相机的运动形式，可以分为以下两种：" class="headerlink" title="二，动态背景下的运动检测：监控过程中，目标和背景都在发生运动或变化；在运动目标检测的应用环境中，动态背景相比而言更加复杂。根据相机的运动形式，可以分为以下两种："></a>二，动态背景下的运动检测：监控过程中，目标和背景都在发生运动或变化；在运动目标检测的应用环境中，动态背景相比而言更加复杂。根据相机的运动形式，可以分为以下两种：</h4><p>1，相机支架固定；但相机可以随着云台的运动而发生旋转，倾斜等运动。另外，相机也可以根据远程计算机指令来控制镜头调焦，从而产生远景和近景缩放运动。</p>
<p>2，相机置于移动设备之上（例如，车载相机）；</p>
<p>对于以上两种相机运动形式的任意一种而言，在进行运动目标检测之前，都需要根据一定的方法进行全局运动估计与补偿。通常，可以利用块匹配法、特征点匹配法等进行运动量的估计。当然，也可以利用光流法建立光流场模型，利用光流方程求解图像像素点的运动速度。</p>
<p>运动目标跟踪就是在一个连续视频序列中，在每一帧监控画面中找到感兴趣的运动目标（例如，车辆，行人，动物等）。跟踪可以大致分为以下几个步骤：</p>
<p>（1）目标的有效描述；目标的跟踪过程跟目标检测一样，需要对其进行有效的描述，即，需要提取目标的特征，从而能够表达该目标；一般来说，我们可以通过图像的边缘、轮廓、形状、纹理、区域、直方图、矩特征、变换系数等来进行目标的特征描述；</p>
<p>（2）相似性度量计算；常用的方法有：欧式距离、马氏距离、棋盘距离、加权距离、相似系数、相关系数等；</p>
<p>（3）目标区域搜索匹配；如果对场景中出现的所有目标都进行特征提取、相似性计算，那么，系统运行所耗费的计算量是很大的。所以，我们通常采用一定的方式对运动目标可能出现的区域进行估计，从而减少冗余，加快目标跟踪的速度；常见的预测算法有：Kalman滤波、粒子滤波、均值漂移等；</p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c++笔记：（5）:C++ 重载运算符和重载函数]]></title>
      <url>/2017/11/13/c++%E7%AC%94%E8%AE%B0/c++%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%885%EF%BC%89C++%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h2 id="C-重载运算符和重载函数"><a href="#C-重载运算符和重载函数" class="headerlink" title="C++ 重载运算符和重载函数"></a>C++ 重载运算符和重载函数</h2><p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>
<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p>
<p>当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。</p>
<h2 id="C-中的函数重载"><a href="#C-中的函数重载" class="headerlink" title="C++ 中的函数重载"></a>C++ 中的函数重载</h2><p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。</p>
<p>下面的实例中，同名函数 print() 被用于输出不同的数据类型：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class printData </div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      void print(int i) &#123;</div><div class="line">        cout &lt;&lt; &quot;Printing int: &quot; &lt;&lt; i &lt;&lt; endl;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">      void print(double  f) &#123;</div><div class="line">        cout &lt;&lt; &quot;Printing float: &quot; &lt;&lt; f &lt;&lt; endl;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">      void print(char* c) &#123;</div><div class="line">        cout &lt;&lt; &quot;Printing character: &quot; &lt;&lt; c &lt;&lt; endl;</div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">   printData pd;</div><div class="line"> </div><div class="line">   // Call print to print integer</div><div class="line">   pd.print(5);</div><div class="line">   // Call print to print float</div><div class="line">   pd.print(500.263);</div><div class="line">   // Call print to print character</div><div class="line">   pd.print(&quot;Hello C++&quot;);</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Printing int: 5</div><div class="line">Printing float: 500.263</div><div class="line">Printing character: Hello C++</div></pre></td></tr></table></figure></p>
<h2 id="C-中的运算符重载"><a href="#C-中的运算符重载" class="headerlink" title="C++ 中的运算符重载"></a>C++ 中的运算符重载</h2><p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Box operator+(const Box&amp;);</div></pre></td></tr></table></figure></p>
<p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为<strong>普通的非成员函数</strong>或者被定义为<strong>类成员函数</strong>。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Box operator+(const Box&amp;, const Box&amp;);</div></pre></td></tr></table></figure></p>
<p>下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line"> </div><div class="line">      double getVolume(void)</div><div class="line">      &#123;</div><div class="line">         return length * breadth * height;</div><div class="line">      &#125;</div><div class="line">      void setLength( double len )</div><div class="line">      &#123;</div><div class="line">          length = len;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">      void setBreadth( double bre )</div><div class="line">      &#123;</div><div class="line">          breadth = bre;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">      void setHeight( double hei )</div><div class="line">      &#123;</div><div class="line">          height = hei;</div><div class="line">      &#125;</div><div class="line">      // 重载 + 运算符，用于把两个 Box 对象相加</div><div class="line">      Box operator+(const Box&amp; b)</div><div class="line">      &#123;</div><div class="line">         Box box;</div><div class="line">         box.length = this-&gt;length + b.length;</div><div class="line">         box.breadth = this-&gt;breadth + b.breadth;</div><div class="line">         box.height = this-&gt;height + b.height;</div><div class="line">         return box;</div><div class="line">      &#125;</div><div class="line">   private:</div><div class="line">      double length;      // 长度</div><div class="line">      double breadth;     // 宽度</div><div class="line">      double height;      // 高度</div><div class="line">&#125;;</div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Box Box1;                // 声明 Box1，类型为 Box</div><div class="line">   Box Box2;                // 声明 Box2，类型为 Box</div><div class="line">   Box Box3;                // 声明 Box3，类型为 Box</div><div class="line">   double volume = 0.0;     // 把体积存储在该变量中</div><div class="line"> </div><div class="line">   // Box1 详述</div><div class="line">   Box1.setLength(6.0); </div><div class="line">   Box1.setBreadth(7.0); </div><div class="line">   Box1.setHeight(5.0);</div><div class="line"> </div><div class="line">   // Box2 详述</div><div class="line">   Box2.setLength(12.0); </div><div class="line">   Box2.setBreadth(13.0); </div><div class="line">   Box2.setHeight(10.0);</div><div class="line"> </div><div class="line">   // Box1 的体积</div><div class="line">   volume = Box1.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Volume of Box1 : &quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line"> </div><div class="line">   // Box2 的体积</div><div class="line">   volume = Box2.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Volume of Box2 : &quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line"> </div><div class="line">   // 把两个对象相加，得到 Box3</div><div class="line">   Box3 = Box1 + Box2;</div><div class="line"> </div><div class="line">   // Box3 的体积</div><div class="line">   volume = Box3.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Volume of Box3 : &quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Volume of Box1 : 210</div><div class="line">Volume of Box2 : 1560</div><div class="line">Volume of Box3 : 5400</div></pre></td></tr></table></figure></p>
<h2 id="可重载运算符-不可重载运算符"><a href="#可重载运算符-不可重载运算符" class="headerlink" title="可重载运算符/不可重载运算符"></a>可重载运算符/不可重载运算符</h2><p>下面是可重载的运算符列表：<br>|双目算术运算符     |+ (加)，-(减)，<em>(乘)，/(除)，% (取模)|<br>|—|—|<br>|关系运算符     |==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)|<br>|逻辑运算符     |||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)|<br>|单目运算符     |+ (正)，-(负)，</em>(指针)，&amp;(取地址)|<br>|自增自减运算符     |++(自增)，–(自减)|<br>|位运算符 |    | (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)|<br>|赋值运算符|     =, +=, -=, <em>=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=|<br>|空间申请与释放     |new, delete, new[ ] , delete[]|<br>|其他运算符 |    ()(函数调用)，-&gt;(成员访问)，-&gt;</em>(成员指针访问)，,(逗号)，[](下标)|</p>
<p>下面是不可重载的运算符列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.：成员访问运算符</div><div class="line">.*, -&gt;*：成员指针访问运算符</div><div class="line">::：域运算符</div><div class="line">sizeof：长度运算符</div><div class="line">?:：条件运算符</div><div class="line">#： 预处理符号</div></pre></td></tr></table></figure></p>
<h2 id="运算符重载实例"><a href="#运算符重载实例" class="headerlink" title="运算符重载实例"></a>运算符重载实例</h2><p>下面提供了各种运算符重载的实例，帮助您更好地理解重载的概念。<br>序号    运算符和实例</p>
<blockquote>
<p>1    一元运算符重载<br>2    二元运算符重载<br>3    关系运算符重载<br>4    输入/输出运算符重载<br>5    ++ 和 – 运算符重载<br>6    赋值运算符重载<br>7    函数调用运算符 () 重载<br>8    下标运算符 [] 重载<br>9    类成员访问运算符 -&gt; 重载</p>
</blockquote>
<h3 id="1-C-一元运算符重载"><a href="#1-C-一元运算符重载" class="headerlink" title="1.C++ 一元运算符重载"></a>1.C++ 一元运算符重载</h3><p>一元运算符只对一个操作数进行操作，下面是一元运算符的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">递增运算符（ ++ ）和递减运算符（ -- ）</div><div class="line">一元减运算符，即负号（ - ）</div><div class="line">逻辑非运算符（ ! ）</div></pre></td></tr></table></figure></p>
<p>一元运算符通常出现在它们所操作的对象的左边，比如 <code>!obj</code>、<code>-obj</code> 和<code>++obj</code>，但有时它们也可以作为后缀，比如 <code>obj++</code> 或<code>obj--</code>。</p>
<p>下面的实例演示了如何重载一元减运算符（ - ）。<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Distance</div><div class="line">&#123;</div><div class="line">   private:</div><div class="line">      int feet;             // 0 到无穷</div><div class="line">      int inches;           // 0 到 12</div><div class="line">   public:</div><div class="line">      // 所需的构造函数</div><div class="line">      Distance()&#123;</div><div class="line">         feet = 0;</div><div class="line">         inches = 0;</div><div class="line">      &#125;</div><div class="line">      Distance(int f, int i)&#123;</div><div class="line">         feet = f;</div><div class="line">         inches = i;</div><div class="line">      &#125;</div><div class="line">      // 显示距离的方法</div><div class="line">      void displayDistance()</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt; &quot;F: &quot; &lt;&lt; feet &lt;&lt; &quot; I:&quot; &lt;&lt; inches &lt;&lt;endl;</div><div class="line">      &#125;</div><div class="line">      // 重载负运算符（ - ）</div><div class="line">      Distance operator- ()  </div><div class="line">      &#123;</div><div class="line">         feet = -feet;</div><div class="line">         inches = -inches;</div><div class="line">         return Distance(feet, inches);</div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   Distance D1(11, 10), D2(-5, 11);</div><div class="line"> </div><div class="line">   -D1;                     // 取相反数</div><div class="line">   D1.displayDistance();    // 距离 D1</div><div class="line"> </div><div class="line">   -D2;                     // 取相反数</div><div class="line">   D2.displayDistance();    // 距离 D2</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">F: -11 I:-10</div><div class="line">F: 5 I:-11</div></pre></td></tr></table></figure></p>
<h3 id="2-C-二元运算符重载"><a href="#2-C-二元运算符重载" class="headerlink" title="2.C++ 二元运算符重载"></a>2.C++ 二元运算符重载</h3><p>二元运算符需要两个参数，下面是二元运算符的实例。我们平常使用的加运算符（ + ）、减运算符（ - ）、乘运算符（ * ）和除运算符（ / ）都属于二元运算符。就像加(+)运算符。</p>
<p>下面的实例演示了如何重载加运算符（ + ）。类似地，您也可以尝试重载减运算符（ - ）和除运算符（ / ）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   double length;      // 长度</div><div class="line">   double breadth;     // 宽度</div><div class="line">   double height;      // 高度</div><div class="line">public:</div><div class="line"> </div><div class="line">   double getVolume(void)</div><div class="line">   &#123;</div><div class="line">      return length * breadth * height;</div><div class="line">   &#125;</div><div class="line">   void setLength( double len )</div><div class="line">   &#123;</div><div class="line">       length = len;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   void setBreadth( double bre )</div><div class="line">   &#123;</div><div class="line">       breadth = bre;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   void setHeight( double hei )</div><div class="line">   &#123;</div><div class="line">       height = hei;</div><div class="line">   &#125;</div><div class="line">   // 重载 + 运算符，用于把两个 Box 对象相加</div><div class="line">   Box operator+(const Box&amp; b)</div><div class="line">   &#123;</div><div class="line">      Box box;</div><div class="line">      box.length = this-&gt;length + b.length;</div><div class="line">      box.breadth = this-&gt;breadth + b.breadth;</div><div class="line">      box.height = this-&gt;height + b.height;</div><div class="line">      return box;</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Box Box1;                // 声明 Box1，类型为 Box</div><div class="line">   Box Box2;                // 声明 Box2，类型为 Box</div><div class="line">   Box Box3;                // 声明 Box3，类型为 Box</div><div class="line">   double volume = 0.0;     // 把体积存储在该变量中</div><div class="line"> </div><div class="line">   // Box1 详述</div><div class="line">   Box1.setLength(6.0); </div><div class="line">   Box1.setBreadth(7.0); </div><div class="line">   Box1.setHeight(5.0);</div><div class="line"> </div><div class="line">   // Box2 详述</div><div class="line">   Box2.setLength(12.0); </div><div class="line">   Box2.setBreadth(13.0); </div><div class="line">   Box2.setHeight(10.0);</div><div class="line"> </div><div class="line">   // Box1 的体积</div><div class="line">   volume = Box1.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Volume of Box1 : &quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line"> </div><div class="line">   // Box2 的体积</div><div class="line">   volume = Box2.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Volume of Box2 : &quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line"> </div><div class="line">   // 把两个对象相加，得到 Box3</div><div class="line">   Box3 = Box1 + Box2;</div><div class="line"> </div><div class="line">   // Box3 的体积</div><div class="line">   volume = Box3.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Volume of Box3 : &quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Volume of Box1 : 210</div><div class="line">Volume of Box2 : 1560</div><div class="line">Volume of Box3 : 5400</div></pre></td></tr></table></figure></p>
<h3 id="3-C-关系运算符重载"><a href="#3-C-关系运算符重载" class="headerlink" title="3.C++ 关系运算符重载"></a>3.C++ 关系运算符重载</h3><p>C++ 语言支持各种关系运算符<code>（ &lt; 、 &gt; 、 &lt;= 、 &gt;= 、 == 等等）</code>，它们可用于比较 C++ 内置的数据类型。</p>
<p>您可以重载任何一个关系运算符，重载后的关系运算符可用于比较类的对象。</p>
<p>下面的实例演示了如何重载 &lt; 运算符，类似地，您也可以尝试重载其他的关系运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Distance</div><div class="line">&#123;</div><div class="line">   private:</div><div class="line">      int feet;             // 0 到无穷</div><div class="line">      int inches;           // 0 到 12</div><div class="line">   public:</div><div class="line">      // 所需的构造函数</div><div class="line">      Distance()&#123;</div><div class="line">         feet = 0;</div><div class="line">         inches = 0;</div><div class="line">      &#125;</div><div class="line">      Distance(int f, int i)&#123;</div><div class="line">         feet = f;</div><div class="line">         inches = i;</div><div class="line">      &#125;</div><div class="line">      // 显示距离的方法</div><div class="line">      void displayDistance()</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt; &quot;F: &quot; &lt;&lt; feet &lt;&lt; &quot; I:&quot; &lt;&lt; inches &lt;&lt;endl;</div><div class="line">      &#125;</div><div class="line">      // 重载负运算符（ - ）</div><div class="line">      Distance operator- ()  </div><div class="line">      &#123;</div><div class="line">         feet = -feet;</div><div class="line">         inches = -inches;</div><div class="line">         return Distance(feet, inches);</div><div class="line">      &#125;</div><div class="line">      // 重载小于运算符（ &lt; ）</div><div class="line">      bool operator &lt;(const Distance&amp; d)</div><div class="line">      &#123;</div><div class="line">         if(feet &lt; d.feet)</div><div class="line">         &#123;</div><div class="line">            return true;</div><div class="line">         &#125;</div><div class="line">         if(feet == d.feet &amp;&amp; inches &lt; d.inches)</div><div class="line">         &#123;</div><div class="line">            return true;</div><div class="line">         &#125;</div><div class="line">         return false;</div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   Distance D1(11, 10), D2(5, 11);</div><div class="line"> </div><div class="line">   if( D1 &lt; D2 )</div><div class="line">   &#123;</div><div class="line">      cout &lt;&lt; &quot;D1 is less than D2 &quot; &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line">   else</div><div class="line">   &#123;</div><div class="line">      cout &lt;&lt; &quot;D2 is less than D1 &quot; &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D2 is less than D1</div></pre></td></tr></table></figure></p>
<h3 id="4-C-输入-输出运算符重载"><a href="#4-C-输入-输出运算符重载" class="headerlink" title="4.C++ 输入/输出运算符重载"></a>4.C++ 输入/输出运算符重载</h3><p>C++ 能够使用流提取运算符 <code>&gt;&gt;</code> 和流插入运算符 <code>&lt;&lt;</code> 来输入和输出内置的数据类型。您可以重载流提取运算符和流插入运算符来操作对象等用户自定义的数据类型。</p>
<p>在这里，有一点很重要，我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。</p>
<p>下面的实例演示了如何重载提取运算符 <code>&gt;&gt;</code> 和插入运算符 <code>&lt;&lt;</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Distance</div><div class="line">&#123;</div><div class="line">   private:</div><div class="line">      int feet;             // 0 到无穷</div><div class="line">      int inches;           // 0 到 12</div><div class="line">   public:</div><div class="line">      // 所需的构造函数</div><div class="line">      Distance()&#123;</div><div class="line">         feet = 0;</div><div class="line">         inches = 0;</div><div class="line">      &#125;</div><div class="line">      Distance(int f, int i)&#123;</div><div class="line">         feet = f;</div><div class="line">         inches = i;</div><div class="line">      &#125;</div><div class="line">      friend ostream &amp;operator&lt;&lt;( ostream &amp;output, </div><div class="line">                                       const Distance &amp;D )</div><div class="line">      &#123; </div><div class="line">         output &lt;&lt; &quot;F : &quot; &lt;&lt; D.feet &lt;&lt; &quot; I : &quot; &lt;&lt; D.inches;</div><div class="line">         return output;            </div><div class="line">      &#125;</div><div class="line"></div><div class="line">      friend istream &amp;operator&gt;&gt;( istream  &amp;input, Distance &amp;D )</div><div class="line">      &#123; </div><div class="line">         input &gt;&gt; D.feet &gt;&gt; D.inches;</div><div class="line">         return input;            </div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   Distance D1(11, 10), D2(5, 11), D3;</div><div class="line"></div><div class="line">   cout &lt;&lt; &quot;Enter the value of object : &quot; &lt;&lt; endl;</div><div class="line">   cin &gt;&gt; D3;</div><div class="line">   cout &lt;&lt; &quot;First Distance : &quot; &lt;&lt; D1 &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;Second Distance :&quot; &lt;&lt; D2 &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;Third Distance :&quot; &lt;&lt; D3 &lt;&lt; endl;</div><div class="line"></div><div class="line"></div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$./a.out</div><div class="line">Enter the value of object :</div><div class="line">70</div><div class="line">10</div><div class="line">First Distance : F : 11 I : 10</div><div class="line">Second Distance :F : 5 I : 11</div><div class="line">Third Distance :F : 70 I : 10</div></pre></td></tr></table></figure></p>
<h3 id="5-C-和-–-运算符重载"><a href="#5-C-和-–-运算符重载" class="headerlink" title="5.C++ ++ 和 – 运算符重载"></a>5.C++ ++ 和 – 运算符重载</h3><p>递增运算符（ ++ ）和递减运算符（ – ）是 C++ 语言中两个重要的一元运算符。</p>
<p>下面的实例演示了如何重载递增运算符（ ++ ），包括前缀和后缀两种用法。类似地，您也可以尝试重载递减运算符（ - - ）。<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Time</div><div class="line">&#123;</div><div class="line">   private:</div><div class="line">      int hours;             // 0 到 23</div><div class="line">      int minutes;           // 0 到 59</div><div class="line">   public:</div><div class="line">      // 所需的构造函数</div><div class="line">      Time()&#123;</div><div class="line">         hours = 0;</div><div class="line">         minutes = 0;</div><div class="line">      &#125;</div><div class="line">      Time(int h, int m)&#123;</div><div class="line">         hours = h;</div><div class="line">         minutes = m;</div><div class="line">      &#125;</div><div class="line">      // 显示时间的方法</div><div class="line">      void displayTime()</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt; &quot;H: &quot; &lt;&lt; hours &lt;&lt; &quot; M:&quot; &lt;&lt; minutes &lt;&lt;endl;</div><div class="line">      &#125;</div><div class="line">      // 重载前缀递增运算符（ ++ ）</div><div class="line">      Time operator++ ()  </div><div class="line">      &#123;</div><div class="line">         ++minutes;          // 对象加 1</div><div class="line">         if(minutes &gt;= 60)  </div><div class="line">         &#123;</div><div class="line">            ++hours;</div><div class="line">            minutes -= 60;</div><div class="line">         &#125;</div><div class="line">         return Time(hours, minutes);</div><div class="line">      &#125;</div><div class="line">      // 重载后缀递增运算符（ ++ ）</div><div class="line">      Time operator++( int )         </div><div class="line">      &#123;</div><div class="line">         // 保存原始值</div><div class="line">         Time T(hours, minutes);</div><div class="line">         // 对象加 1</div><div class="line">         ++minutes;                    </div><div class="line">         if(minutes &gt;= 60)</div><div class="line">         &#123;</div><div class="line">            ++hours;</div><div class="line">            minutes -= 60;</div><div class="line">         &#125;</div><div class="line">         // 返回旧的原始值</div><div class="line">         return T; </div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   Time T1(11, 59), T2(10,40);</div><div class="line"> </div><div class="line">   ++T1;                    // T1 加 1</div><div class="line">   T1.displayTime();        // 显示 T1</div><div class="line">   ++T1;                    // T1 再加 1</div><div class="line">   T1.displayTime();        // 显示 T1</div><div class="line"> </div><div class="line">   T2++;                    // T2 加 1</div><div class="line">   T2.displayTime();        // 显示 T2</div><div class="line">   T2++;                    // T2 再加 1</div><div class="line">   T2.displayTime();        // 显示 T2</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">H: 12 M:0</div><div class="line">H: 12 M:1</div><div class="line">H: 10 M:41</div><div class="line">H: 10 M:42</div></pre></td></tr></table></figure></p>
<h3 id="6-C-赋值运算符重载"><a href="#6-C-赋值运算符重载" class="headerlink" title="6.C++ 赋值运算符重载"></a>6.C++ 赋值运算符重载</h3><p>就像其他运算符一样，您可以重载赋值运算符（ = ），用于创建一个对象，比如拷贝构造函数。</p>
<p>下面的实例演示了如何重载赋值运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Distance</div><div class="line">&#123;</div><div class="line">   private:</div><div class="line">      int feet;             // 0 到无穷</div><div class="line">      int inches;           // 0 到 12</div><div class="line">   public:</div><div class="line">      // 所需的构造函数</div><div class="line">      Distance()&#123;</div><div class="line">         feet = 0;</div><div class="line">         inches = 0;</div><div class="line">      &#125;</div><div class="line">      Distance(int f, int i)&#123;</div><div class="line">         feet = f;</div><div class="line">         inches = i;</div><div class="line">      &#125;</div><div class="line">      void operator=(const Distance &amp;D )</div><div class="line">      &#123; </div><div class="line">         feet = D.feet;</div><div class="line">         inches = D.inches;</div><div class="line">      &#125;</div><div class="line">      // 显示距离的方法</div><div class="line">      void displayDistance()</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt; &quot;F: &quot; &lt;&lt; feet &lt;&lt;  &quot; I:&quot; &lt;&lt;  inches &lt;&lt; endl;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   Distance D1(11, 10), D2(5, 11);</div><div class="line"></div><div class="line">   cout &lt;&lt; &quot;First Distance : &quot;; </div><div class="line">   D1.displayDistance();</div><div class="line">   cout &lt;&lt; &quot;Second Distance :&quot;; </div><div class="line">   D2.displayDistance();</div><div class="line"></div><div class="line">   // 使用赋值运算符</div><div class="line">   D1 = D2;</div><div class="line">   cout &lt;&lt; &quot;First Distance :&quot;; </div><div class="line">   D1.displayDistance();</div><div class="line"></div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">First Distance : F: 11 I:10</div><div class="line">Second Distance :F: 5 I:11</div><div class="line">First Distance :F: 5 I:11</div></pre></td></tr></table></figure></p>
<h3 id="7-C-函数调用运算符-重载"><a href="#7-C-函数调用运算符-重载" class="headerlink" title="7.C++ 函数调用运算符 () 重载"></a>7.C++ 函数调用运算符 () 重载</h3><p>函数调用运算符 () 可以被重载用于类的对象。当重载 () 时，您不是创造了一种新的调用函数的方式，相反地，这是创建一个可以传递任意数目参数的运算符函数。</p>
<p>下面的实例演示了如何重载函数调用运算符 ()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Distance</div><div class="line">&#123;</div><div class="line">   private:</div><div class="line">      int feet;             // 0 到无穷</div><div class="line">      int inches;           // 0 到 12</div><div class="line">   public:</div><div class="line">      // 所需的构造函数</div><div class="line">      Distance()&#123;</div><div class="line">         feet = 0;</div><div class="line">         inches = 0;</div><div class="line">      &#125;</div><div class="line">      Distance(int f, int i)&#123;</div><div class="line">         feet = f;</div><div class="line">         inches = i;</div><div class="line">      &#125;</div><div class="line">      // 重载函数调用运算符</div><div class="line">      Distance operator()(int a, int b, int c)</div><div class="line">      &#123;</div><div class="line">         Distance D;</div><div class="line">         // 进行随机计算</div><div class="line">         D.feet = a + c + 10;</div><div class="line">         D.inches = b + c + 100 ;</div><div class="line">         return D;</div><div class="line">      &#125;</div><div class="line">      // 显示距离的方法</div><div class="line">      void displayDistance()</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt; &quot;F: &quot; &lt;&lt; feet &lt;&lt;  &quot; I:&quot; &lt;&lt;  inches &lt;&lt; endl;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   Distance D1(11, 10), D2;</div><div class="line"></div><div class="line">   cout &lt;&lt; &quot;First Distance : &quot;; </div><div class="line">   D1.displayDistance();</div><div class="line"></div><div class="line">   D2 = D1(10, 10, 10); // invoke operator()</div><div class="line">   cout &lt;&lt; &quot;Second Distance :&quot;; </div><div class="line">   D2.displayDistance();</div><div class="line"></div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">First Distance : F: 11 I:10</div><div class="line">Second Distance :F: 30 I:120</div></pre></td></tr></table></figure></p>
<h3 id="8-C-下标运算符-重载"><a href="#8-C-下标运算符-重载" class="headerlink" title="8.C++ 下标运算符 [] 重载"></a>8.C++ 下标运算符 [] 重载</h3><p>下标操作符 [] 通常用于访问数组元素。重载该运算符用于增强操作 C++ 数组的功能。</p>
<p>下面的实例演示了如何重载下标运算符 []。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">const int SIZE = 10;</div><div class="line"></div><div class="line">class safearay</div><div class="line">&#123;</div><div class="line">   private:</div><div class="line">      int arr[SIZE];</div><div class="line">   public:</div><div class="line">      safearay() </div><div class="line">      &#123;</div><div class="line">         register int i;</div><div class="line">         for(i = 0; i &lt; SIZE; i++)</div><div class="line">         &#123;</div><div class="line">           arr[i] = i;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      int&amp; operator[](int i)</div><div class="line">      &#123;</div><div class="line">          if( i &gt; SIZE )</div><div class="line">          &#123;</div><div class="line">              cout &lt;&lt; &quot;索引超过最大值&quot; &lt;&lt;endl; </div><div class="line">              // 返回第一个元素</div><div class="line">              return arr[0];</div><div class="line">          &#125;</div><div class="line">          return arr[i];</div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   safearay A;</div><div class="line"></div><div class="line">   cout &lt;&lt; &quot;A[2] 的值为 : &quot; &lt;&lt; A[2] &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;A[5] 的值为 : &quot; &lt;&lt; A[5]&lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;A[12] 的值为 : &quot; &lt;&lt; A[12]&lt;&lt;endl;</div><div class="line"></div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ g++ -o test test.cpp</div><div class="line">$ ./test </div><div class="line">A[2] 的值为 : 2</div><div class="line">A[5] 的值为 : 5</div><div class="line">A[12] 的值为 : 索引超过最大值</div><div class="line">0</div></pre></td></tr></table></figure></p>
<h3 id="9-C-类成员访问运算符-gt-重载"><a href="#9-C-类成员访问运算符-gt-重载" class="headerlink" title="9.C++ 类成员访问运算符 -&gt; 重载"></a>9.C++ 类成员访问运算符 -&gt; 重载</h3><p>类成员访问运算符（ -&gt; ）可以被重载，但它较为麻烦。它被定义用于为一个类赋予”指针”行为。运算符 -&gt; 必须是一个成员函数。如果使用了 -&gt; 运算符，返回类型必须是指针或者是类的对象。</p>
<p>运算符 -&gt; 通常与指针引用运算符 * 结合使用，用于实现”智能指针”的功能。这些指针是行为与正常指针相似的对象，唯一不同的是，当您通过指针访问对象时，它们会执行其他的任务。比如，当指针销毁时，或者当指针指向另一个对象时，会自动删除对象。</p>
<p>间接引用运算符 -&gt; 可被定义为一个一元后缀运算符。也就是说，给出一个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Ptr&#123;</div><div class="line">   //...</div><div class="line">   X * operator-&gt;();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">类 Ptr 的对象可用于访问类 X 的成员，使用方式与指针的用法十分相似。例如：</div><div class="line"></div><div class="line">void f(Ptr p )</div><div class="line">&#123;</div><div class="line">   p-&gt;m = 10 ; // (p.operator-&gt;())-&gt;m = 10</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>语句<code>p-&gt;m</code>被解释为 <code>(p.operator-&gt;())-&gt;m</code>。同样地，下面的实例演示了如何重载类成员访问运算符 <code>-&gt;</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">// 假设一个实际的类</div><div class="line">class Obj &#123;</div><div class="line">   static int i, j;</div><div class="line">public:</div><div class="line">   void f() const &#123; cout &lt;&lt; i++ &lt;&lt; endl; &#125;</div><div class="line">   void g() const &#123; cout &lt;&lt; j++ &lt;&lt; endl; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 静态成员定义</div><div class="line">int Obj::i = 10;</div><div class="line">int Obj::j = 12;</div><div class="line"></div><div class="line">// 为上面的类实现一个容器</div><div class="line">class ObjContainer &#123;</div><div class="line">   vector&lt;Obj*&gt; a;</div><div class="line">public:</div><div class="line">   void add(Obj* obj)</div><div class="line">   &#123; </div><div class="line">      a.push_back(obj);  // 调用向量的标准方法</div><div class="line">   &#125;</div><div class="line">   friend class SmartPointer;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 实现智能指针，用于访问类 Obj 的成员</div><div class="line">class SmartPointer &#123;</div><div class="line">   ObjContainer oc;</div><div class="line">   int index;</div><div class="line">public:</div><div class="line">   SmartPointer(ObjContainer&amp; objc)</div><div class="line">   &#123; </div><div class="line">       oc = objc;</div><div class="line">       index = 0;</div><div class="line">   &#125;</div><div class="line">   // 返回值表示列表结束</div><div class="line">   bool operator++() // 前缀版本</div><div class="line">   &#123; </div><div class="line">     if(index &gt;= oc.a.size()) return false;</div><div class="line">     if(oc.a[++index] == 0) return false;</div><div class="line">     return true;</div><div class="line">   &#125;</div><div class="line">   bool operator++(int) // 后缀版本</div><div class="line">   &#123; </div><div class="line">      return operator++();</div><div class="line">   &#125;</div><div class="line">   // 重载运算符 -&gt;</div><div class="line">   Obj* operator-&gt;() const </div><div class="line">   &#123;</div><div class="line">     if(!oc.a[index])</div><div class="line">     &#123;</div><div class="line">        cout &lt;&lt; &quot;Zero value&quot;;</div><div class="line">        return (Obj*)0;</div><div class="line">     &#125;</div><div class="line">     return oc.a[index];</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">   const int sz = 10;</div><div class="line">   Obj o[sz];</div><div class="line">   ObjContainer oc;</div><div class="line">   for(int i = 0; i &lt; sz; i++)</div><div class="line">   &#123;</div><div class="line">       oc.add(&amp;o[i]);</div><div class="line">   &#125;</div><div class="line">   SmartPointer sp(oc); // 创建一个迭代器</div><div class="line">   do &#123;</div><div class="line">      sp-&gt;f(); // 智能指针调用</div><div class="line">      sp-&gt;g();</div><div class="line">   &#125; while(sp++);</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">12</div><div class="line">11</div><div class="line">13</div><div class="line">12</div><div class="line">14</div><div class="line">13</div><div class="line">15</div><div class="line">14</div><div class="line">16</div><div class="line">15</div><div class="line">17</div><div class="line">16</div><div class="line">18</div><div class="line">17</div><div class="line">19</div><div class="line">18</div><div class="line">20</div><div class="line">19</div><div class="line">21</div></pre></td></tr></table></figure></p>
<p>转自：<a href="http://www.runoob.com/cplusplus/cpp-overloading.html" target="_blank" rel="external">C++ 重载运算符和重载函数</a></p>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c++笔记：（4）:C++ 继承]]></title>
      <url>/2017/11/13/c++%E7%AC%94%E8%AE%B0/c++%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%884%EF%BC%89C++%20%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<h2 id="C-继承"><a href="#C-继承" class="headerlink" title="C++ 继承"></a>C++ 继承</h2><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。</p>
<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。</p>
<p>继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。</p>
<h2 id="基类-amp-派生类"><a href="#基类-amp-派生类" class="headerlink" title="基类 &amp; 派生类"></a>基类 &amp; 派生类</h2><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class derived-class: access-specifier base-class</div></pre></td></tr></table></figure></p>
<p>其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>
<p>假设有一个基类 Shape，Rectangle 是它的派生类，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 基类</div><div class="line">class Shape </div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      void setWidth(int w)</div><div class="line">      &#123;</div><div class="line">         width = w;</div><div class="line">      &#125;</div><div class="line">      void setHeight(int h)</div><div class="line">      &#123;</div><div class="line">         height = h;</div><div class="line">      &#125;</div><div class="line">   protected:</div><div class="line">      int width;</div><div class="line">      int height;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 派生类</div><div class="line">class Rectangle: public Shape</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      int getArea()</div><div class="line">      &#123; </div><div class="line">         return (width * height); </div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">   Rectangle Rect;</div><div class="line"> </div><div class="line">   Rect.setWidth(5);</div><div class="line">   Rect.setHeight(7);</div><div class="line"> </div><div class="line">   // 输出对象的面积</div><div class="line">   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Total area: 35</div></pre></td></tr></table></figure></p>
<h2 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h2><p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>
<p>我们可以根据访问权限总结出不同的访问类型，如下所示：<br>|访问    |public|    protected|    private|<br>|- - -|- - -|- - -|<br>|同一个类|    yes    |yes|    yes|<br>|派生类    |yes    |yes    |no|<br>|外部的类|    yes|    no|    no|</p>
<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>
<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
<h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><p>当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>
<p>我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则：</p>
<blockquote>
<p>   <strong>公有继承（public）</strong>：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</p>
<p>   <strong>私有继承（private）</strong>：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。</p>
</blockquote>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>
<p>C++ 类可以从多个类继承成员，语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…</div><div class="line">&#123;</div><div class="line">&lt;派生类类体&gt;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 基类 Shape</div><div class="line">class Shape </div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      void setWidth(int w)</div><div class="line">      &#123;</div><div class="line">         width = w;</div><div class="line">      &#125;</div><div class="line">      void setHeight(int h)</div><div class="line">      &#123;</div><div class="line">         height = h;</div><div class="line">      &#125;</div><div class="line">   protected:</div><div class="line">      int width;</div><div class="line">      int height;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 基类 PaintCost</div><div class="line">class PaintCost </div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      int getCost(int area)</div><div class="line">      &#123;</div><div class="line">         return area * 70;</div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 派生类</div><div class="line">class Rectangle: public Shape, public PaintCost</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      int getArea()</div><div class="line">      &#123; </div><div class="line">         return (width * height); </div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">   Rectangle Rect;</div><div class="line">   int area;</div><div class="line"> </div><div class="line">   Rect.setWidth(5);</div><div class="line">   Rect.setHeight(7);</div><div class="line"> </div><div class="line">   area = Rect.getArea();</div><div class="line">   </div><div class="line">   // 输出对象的面积</div><div class="line">   cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;</div><div class="line"> </div><div class="line">   // 输出总花费</div><div class="line">   cout &lt;&lt; &quot;Total paint cost: $&quot; &lt;&lt; Rect.getCost(area) &lt;&lt; endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Total area: 35</div><div class="line">Total paint cost: $2450</div></pre></td></tr></table></figure></p>
<p>转自：<a href="http://www.runoob.com/cplusplus/cpp-inheritance.html" target="_blank" rel="external">c++继承|菜鸟教程</a></p>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c++笔记：（3）:C++ 类 & 对象]]></title>
      <url>/2017/11/13/c++%E7%AC%94%E8%AE%B0/c++%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%883%EF%BC%89C++%20%E7%B1%BB%20&amp;%20%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h1 id="1-C-类-amp-对象"><a href="#1-C-类-amp-对象" class="headerlink" title="1.C++ 类 &amp; 对象"></a>1.C++ 类 &amp; 对象</h1><p>C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。</p>
<p>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。</p>
<h2 id="C-类定义"><a href="#C-类定义" class="headerlink" title="C++ 类定义"></a>C++ 类定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      double length;   // 盒子的长度</div><div class="line">      double breadth;  // 盒子的宽度</div><div class="line">      double height;   // 盒子的高度</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="定义-C-对象"><a href="#定义-C-对象" class="headerlink" title="定义 C++ 对象"></a>定义 C++ 对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Box Box1;          // 声明 Box1，类型为 Box</div><div class="line">Box Box2;          // 声明 Box2，类型为 Box</div></pre></td></tr></table></figure>
<h2 id="访问数据成员"><a href="#访问数据成员" class="headerlink" title="访问数据成员"></a>访问数据成员</h2><p>类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。为了更好地理解这些概念，让我们尝试一下下面的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">     public :</div><div class="line">       double length;    //长度</div><div class="line">       double breadth;  //宽度</div><div class="line">       double height;     //高度</div><div class="line">  </div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  Box Box1;     //声明 Box1 ,类型为 Box</div><div class="line">  Box Box2;     //声明 Box2 ,类型为 Box </div><div class="line">  double volume = 0.0;		//用于存储体积</div><div class="line">  </div><div class="line">  // Box1 赋值</div><div class="line">  Box1.height = 5.0;</div><div class="line">  Box1.length = 6.0;</div><div class="line">  Box1.breadth = 7.0;</div><div class="line">  </div><div class="line">  //Box2 赋值</div><div class="line">  Box2.height = 10.0;</div><div class="line">  Box2.length = 12.0;</div><div class="line">  Box2.breadth = 13.0;</div><div class="line">  </div><div class="line">  //Box1 的体积</div><div class="line">  volume = Box1.height * Box1.length * Box1.breadth;</div><div class="line">  cout &lt;&lt;  &quot;Box1 的体积：&quot; &lt;&lt; volume &lt;&lt; endl ;</div><div class="line">  </div><div class="line">  //Box2 的体积</div><div class="line">  volume = Box2.height * Box2.length * Box2.breadth;</div><div class="line">  cout &lt;&lt; &quot;Box2 的体积：&quot; &lt;&lt; volume &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">Box1 的体积：<span class="number">210</span></div><div class="line">Box2 的体积：<span class="number">1560</span></div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure></p>
<h2 id="1-1C-类成员函数"><a href="#1-1C-类成员函数" class="headerlink" title="1.1C++ 类成员函数"></a>1.1C++ 类成员函数</h2><p><code>类的成员函数</code>是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。</p>
<p>让我们看看之前定义的类 Box，现在我们要使用成员函数来访问类的成员，而不是直接访问这些类的成员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      double length;         // 长度</div><div class="line">      double breadth;        // 宽度</div><div class="line">      double height;         // 高度</div><div class="line">      double getVolume(void);// 返回体积</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>成员函数可以定义在类定义内部，或者单独使用范围解析运算符<code>::</code> 来定义。在类定义中定义的成员函数把函数声明为内联的，即便没有使用 <code>inline</code> 标识符。所以您可以按照如下方式定义 <code>Volume()</code>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      double length;      // 长度</div><div class="line">      double breadth;     // 宽度</div><div class="line">      double height;      // 高度</div><div class="line">   </div><div class="line">      double getVolume(void)</div><div class="line">      &#123;</div><div class="line">         return length * breadth * height;</div><div class="line">      &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>您也可以在类的外部使用范围解析运算符<code>::</code> 定义该函数，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">double Box::getVolume(void)</div><div class="line">&#123;</div><div class="line">    return length * breadth * height;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，需要强调一点，在 <code>::</code> 运算符之前必须使用类名。调用成员函数是在对象上使用点运算符（.），这样它就能操作与该对象相关的数据，如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Box myBox;          <span class="comment">// 创建一个对象</span></div><div class="line"></div><div class="line">myBox.getVolume();  <span class="comment">// 调用该对象的成员函数</span></div></pre></td></tr></table></figure></p>
<p>让我们使用上面提到的概念来设置和获取类中不同的成员的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      double length;         // 长度</div><div class="line">      double breadth;        // 宽度</div><div class="line">      double height;         // 高度</div><div class="line"></div><div class="line">      // 成员函数声明</div><div class="line">      double getVolume(void);</div><div class="line">      void setLength( double len );</div><div class="line">      void setBreadth( double bre );</div><div class="line">      void setHeight( double hei );</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 成员函数定义</div><div class="line">double Box::getVolume(void)</div><div class="line">&#123;</div><div class="line">    return length * breadth * height;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Box::setLength( double len )</div><div class="line">&#123;</div><div class="line">    length = len;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Box::setBreadth( double bre )</div><div class="line">&#123;</div><div class="line">    breadth = bre;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Box::setHeight( double hei )</div><div class="line">&#123;</div><div class="line">    height = hei;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Box Box1;                // 声明 Box1，类型为 Box</div><div class="line">   Box Box2;                // 声明 Box2，类型为 Box</div><div class="line">   double volume = 0.0;     // 用于存储体积</div><div class="line"> </div><div class="line">   // box 1 详述</div><div class="line">   Box1.setLength(6.0); </div><div class="line">   Box1.setBreadth(7.0); </div><div class="line">   Box1.setHeight(5.0);</div><div class="line"></div><div class="line">   // box 2 详述</div><div class="line">   Box2.setLength(12.0); </div><div class="line">   Box2.setBreadth(13.0); </div><div class="line">   Box2.setHeight(10.0);</div><div class="line"></div><div class="line">   // box 1 的体积</div><div class="line">   volume = Box1.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Box1 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line"></div><div class="line">   // box 2 的体积</div><div class="line">   volume = Box2.getVolume();</div><div class="line">   cout &lt;&lt; &quot;Box2 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Box1 的体积： 210</div><div class="line">Box2 的体积： 1560</div></pre></td></tr></table></figure></p>
<h2 id="1-2C-类访问修饰符"><a href="#1-2C-类访问修饰符" class="headerlink" title="1.2C++ 类访问修饰符"></a>1.2C++ 类访问修饰符</h2><p><strong>数据封装</strong>是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。关键字 public、private、protected 称为<strong>访问修饰符</strong>。</p>
<p>一个类可以有多个 public、protected 或 private 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。<strong>成员和类的默认访问修饰符是 private。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Base &#123;</div><div class="line"> </div><div class="line">   public:</div><div class="line"> </div><div class="line">  // 公有成员</div><div class="line"> </div><div class="line">   protected:</div><div class="line"> </div><div class="line">  // 受保护成员</div><div class="line"> </div><div class="line">   private:</div><div class="line"> </div><div class="line">  // 私有成员</div><div class="line"> </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="公有（public）成员"><a href="#公有（public）成员" class="headerlink" title="公有（public）成员"></a>公有（public）成员</h3><p>公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Line</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      double length;</div><div class="line">      void setLength( double len );</div><div class="line">      double getLength( void );</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 成员函数定义</div><div class="line">double Line::getLength(void)</div><div class="line">&#123;</div><div class="line">    return length ;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void Line::setLength( double len )</div><div class="line">&#123;</div><div class="line">    length = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Line line;</div><div class="line"> </div><div class="line">   // 设置长度</div><div class="line">   line.setLength(6.0); </div><div class="line">   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;</div><div class="line"> </div><div class="line">   // 不使用成员函数设置长度</div><div class="line">   line.length = 10.0; // OK: 因为 length 是公有的</div><div class="line">   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.length &lt;&lt;endl;</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Length of line : 6</div><div class="line">Length of line : 10</div></pre></td></tr></table></figure></p>
<h3 id="私有（private）成员"><a href="#私有（private）成员" class="headerlink" title="私有（private）成员"></a>私有（private）成员</h3><p>私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。</p>
<p><strong>默认情况下，类的所有成员都是私有的。</strong>例如在下面的类中，width 是一个私有成员，这意味着，如果您没有使用任何访问修饰符，类的成员将被假定为私有成员：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   double width;    //默认情况下，类的所有成员都是私有的。</div><div class="line">   public:</div><div class="line">      double length;</div><div class="line">      void setWidth( double wid );</div><div class="line">      double getWidth( void );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>实际操作中，我们一般会在私有区域定义数据，在公有区域定义相关的函数，以便在类的外部也可以调用这些函数，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      double length;</div><div class="line">      void setWidth( double wid );</div><div class="line">      double getWidth( void );</div><div class="line"> </div><div class="line">   private:</div><div class="line">      double width;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 成员函数定义</div><div class="line">double Box::getWidth(void)</div><div class="line">&#123;</div><div class="line">    return width ;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void Box::setWidth( double wid )</div><div class="line">&#123;</div><div class="line">    width = wid;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Box box;</div><div class="line"> </div><div class="line">   // 不使用成员函数设置长度</div><div class="line">   box.length = 10.0; // OK: 因为 length 是公有的</div><div class="line">   cout &lt;&lt; &quot;Length of box : &quot; &lt;&lt; box.length &lt;&lt;endl;</div><div class="line"> </div><div class="line">   // 不使用成员函数设置宽度</div><div class="line">   // box.width = 10.0; // Error: 因为 width 是私有的</div><div class="line">   box.setWidth(10.0);  // 使用成员函数设置宽度</div><div class="line">   cout &lt;&lt; &quot;Width of box : &quot; &lt;&lt; box.getWidth() &lt;&lt;endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Length of box : 10</div><div class="line">Width of box : 10</div></pre></td></tr></table></figure></p>
<h3 id="保护（protected）成员"><a href="#保护（protected）成员" class="headerlink" title="保护（protected）成员"></a>保护（protected）成员</h3><p>保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。</p>
<p>在下一个章节中，您将学习到派生类和继承的知识。现在您可以看到下面的实例中，我们从父类 Box 派生了一个子类 smallBox。</p>
<p>下面的实例与前面的实例类似，在这里 width 成员可被派生类 smallBox 的任何成员函数访问。<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   protected:</div><div class="line">      double width;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">class SmallBox:Box // SmallBox 是派生类</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      void setSmallWidth( double wid );</div><div class="line">      double getSmallWidth( void );</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 子类的成员函数</div><div class="line">double SmallBox::getSmallWidth(void)</div><div class="line">&#123;</div><div class="line">    return width ;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void SmallBox::setSmallWidth( double wid )</div><div class="line">&#123;</div><div class="line">    width = wid;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   SmallBox box;</div><div class="line"> </div><div class="line">   // 使用成员函数设置宽度</div><div class="line">   box.setSmallWidth(5.0);</div><div class="line">   cout &lt;&lt; &quot;Width of box : &quot;&lt;&lt; box.getSmallWidth() &lt;&lt; endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Width of box : 5</div></pre></td></tr></table></figure></p>
<h3 id="继承中的特点"><a href="#继承中的特点" class="headerlink" title="继承中的特点"></a>继承中的特点</h3><p>有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。</p>
<blockquote>
<p>   1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</p>
<p>   2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</p>
<p>   3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</p>
</blockquote>
<p>但无论哪种继承方式，上面两点都没有改变：</p>
<blockquote>
<p>   1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；</p>
<p>  2.protected 成员可以被派生类访问。</p>
</blockquote>
<h3 id="public-继承"><a href="#public-继承" class="headerlink" title="public 继承"></a>public 继承</h3><p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;assert.h&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class A&#123;</div><div class="line">public:</div><div class="line">  int a;</div><div class="line">  A()&#123;</div><div class="line">    a1 = 1;</div><div class="line">    a2 = 2;</div><div class="line">    a3 = 3;</div><div class="line">    a = 4;</div><div class="line">  &#125;</div><div class="line">  void fun()&#123;</div><div class="line">    cout &lt;&lt; a &lt;&lt; endl;    //正确</div><div class="line">    cout &lt;&lt; a1 &lt;&lt; endl;   //正确</div><div class="line">    cout &lt;&lt; a2 &lt;&lt; endl;   //正确</div><div class="line">    cout &lt;&lt; a3 &lt;&lt; endl;   //正确</div><div class="line">  &#125;</div><div class="line">public:</div><div class="line">  int a1;</div><div class="line">protected:</div><div class="line">  int a2;</div><div class="line">private:</div><div class="line">  int a3;</div><div class="line">&#125;;</div><div class="line">class B : public A&#123;</div><div class="line">public:</div><div class="line">  int a;</div><div class="line">  B(int i)&#123;</div><div class="line">    A();</div><div class="line">    a = i;</div><div class="line">  &#125;</div><div class="line">  void fun()&#123;</div><div class="line">    cout &lt;&lt; a &lt;&lt; endl;       //正确，public成员</div><div class="line">    cout &lt;&lt; a1 &lt;&lt; endl;       //正确，基类的public成员，在派生类中仍是public成员。</div><div class="line">    cout &lt;&lt; a2 &lt;&lt; endl;       //正确，基类的protected成员，在派生类中仍是protected可以被派生类访问。</div><div class="line">    cout &lt;&lt; a3 &lt;&lt; endl;       //错误，基类的private成员不能被派生类访问。</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">int main()&#123;</div><div class="line">  B b(10);</div><div class="line">  cout &lt;&lt; b.a &lt;&lt; endl;</div><div class="line">  cout &lt;&lt; b.a1 &lt;&lt; endl;   //正确</div><div class="line">  cout &lt;&lt; b.a2 &lt;&lt; endl;   //错误，类外不能访问protected成员</div><div class="line">  cout &lt;&lt; b.a3 &lt;&lt; endl;   //错误，类外不能访问private成员</div><div class="line">  system(&quot;pause&quot;);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="protected-继承"><a href="#protected-继承" class="headerlink" title="protected 继承"></a>protected 继承</h3><p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;assert.h&gt;</div><div class="line">using namespace std;</div><div class="line">class A&#123;</div><div class="line">public:</div><div class="line">  int a;</div><div class="line">  A()&#123;</div><div class="line">    a1 = 1;</div><div class="line">    a2 = 2;</div><div class="line">    a3 = 3;</div><div class="line">    a = 4;</div><div class="line">  &#125;</div><div class="line">  void fun()&#123;</div><div class="line">    cout &lt;&lt; a &lt;&lt; endl;    //正确</div><div class="line">    cout &lt;&lt; a1 &lt;&lt; endl;   //正确</div><div class="line">    cout &lt;&lt; a2 &lt;&lt; endl;   //正确</div><div class="line">    cout &lt;&lt; a3 &lt;&lt; endl;   //正确</div><div class="line">  &#125;</div><div class="line">public:</div><div class="line">  int a1;</div><div class="line">protected:</div><div class="line">  int a2;</div><div class="line">private:</div><div class="line">  int a3;</div><div class="line">&#125;;</div><div class="line">class B : protected A&#123;</div><div class="line">public:</div><div class="line">  int a;</div><div class="line">  B(int i)&#123;</div><div class="line">    A();</div><div class="line">    a = i;</div><div class="line">  &#125;</div><div class="line">  void fun()&#123;</div><div class="line">    cout &lt;&lt; a &lt;&lt; endl;       //正确，public成员。</div><div class="line">    cout &lt;&lt; a1 &lt;&lt; endl;       //正确，基类的public成员，在派生类中变成了protected，可以被派生类访问。</div><div class="line">    cout &lt;&lt; a2 &lt;&lt; endl;       //正确，基类的protected成员，在派生类中还是protected，可以被派生类访问。</div><div class="line">    cout &lt;&lt; a3 &lt;&lt; endl;       //错误，基类的private成员不能被派生类访问。</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">int main()&#123;</div><div class="line">  B b(10);</div><div class="line">  cout &lt;&lt; b.a &lt;&lt; endl;       //正确。public成员</div><div class="line">  cout &lt;&lt; b.a1 &lt;&lt; endl;      //错误，protected成员不能在类外访问。</div><div class="line">  cout &lt;&lt; b.a2 &lt;&lt; endl;      //错误，protected成员不能在类外访问。</div><div class="line">  cout &lt;&lt; b.a3 &lt;&lt; endl;      //错误，private成员不能在类外访问。</div><div class="line">  system(&quot;pause&quot;);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="private-继承"><a href="#private-继承" class="headerlink" title="private 继承"></a>private 继承</h3><p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;assert.h&gt;</div><div class="line">using namespace std;</div><div class="line">class A&#123;</div><div class="line">public:</div><div class="line">  int a;</div><div class="line">  A()&#123;</div><div class="line">    a1 = 1;</div><div class="line">    a2 = 2;</div><div class="line">    a3 = 3;</div><div class="line">    a = 4;</div><div class="line">  &#125;</div><div class="line">  void fun()&#123;</div><div class="line">    cout &lt;&lt; a &lt;&lt; endl;    //正确</div><div class="line">    cout &lt;&lt; a1 &lt;&lt; endl;   //正确</div><div class="line">    cout &lt;&lt; a2 &lt;&lt; endl;   //正确</div><div class="line">    cout &lt;&lt; a3 &lt;&lt; endl;   //正确</div><div class="line">  &#125;</div><div class="line">public:</div><div class="line">  int a1;</div><div class="line">protected:</div><div class="line">  int a2;</div><div class="line">private:</div><div class="line">  int a3;</div><div class="line">&#125;;</div><div class="line">class B : private A&#123;</div><div class="line">public:</div><div class="line">  int a;</div><div class="line">  B(int i)&#123;</div><div class="line">    A();</div><div class="line">    a = i;</div><div class="line">  &#125;</div><div class="line">  void fun()&#123;</div><div class="line">    cout &lt;&lt; a &lt;&lt; endl;       //正确，public成员。</div><div class="line">    cout &lt;&lt; a1 &lt;&lt; endl;       //正确，基类public成员,在派生类中变成了private,可以被派生类访问。</div><div class="line">    cout &lt;&lt; a2 &lt;&lt; endl;       //正确，基类的protected成员，在派生类中变成了private,可以被派生类访问。</div><div class="line">    cout &lt;&lt; a3 &lt;&lt; endl;       //错误，基类的private成员不能被派生类访问。</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">int main()&#123;</div><div class="line">  B b(10);</div><div class="line">  cout &lt;&lt; b.a &lt;&lt; endl;       //正确。public成员</div><div class="line">  cout &lt;&lt; b.a1 &lt;&lt; endl;      //错误，private成员不能在类外访问。</div><div class="line">  cout &lt;&lt; b.a2 &lt;&lt; endl;      //错误, private成员不能在类外访问。</div><div class="line">  cout &lt;&lt; b.a3 &lt;&lt; endl;      //错误，private成员不能在类外访问。</div><div class="line">  system(&quot;pause&quot;);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="1-3C-类构造函数-amp-析构函数"><a href="#1-3C-类构造函数-amp-析构函数" class="headerlink" title="1.3C++ 类构造函数 &amp; 析构函数"></a>1.3C++ 类构造函数 &amp; 析构函数</h2><h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><p><strong>类的构造函数</strong>是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。</p>
<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>
<p>下面的实例有助于更好地理解构造函数的概念：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Line</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      void setLength( double len );</div><div class="line">      double getLength( void );</div><div class="line">      Line();  // 这是构造函数</div><div class="line"> </div><div class="line">   private:</div><div class="line">      double length;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 成员函数定义，包括构造函数</div><div class="line">Line::Line(void)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void Line::setLength( double len )</div><div class="line">&#123;</div><div class="line">    length = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">double Line::getLength( void )</div><div class="line">&#123;</div><div class="line">    return length;</div><div class="line">&#125;</div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Line line;</div><div class="line"> </div><div class="line">   // 设置长度</div><div class="line">   line.setLength(6.0); </div><div class="line">   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object is being created</div><div class="line">Length of line : 6</div></pre></td></tr></table></figure></p>
<h3 id="带参数的构造函数"><a href="#带参数的构造函数" class="headerlink" title="带参数的构造函数"></a>带参数的构造函数</h3><p>默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值，如下面的例子所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Line</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      void setLength( double len );</div><div class="line">      double getLength( void );</div><div class="line">      Line(double len);  // 这是构造函数</div><div class="line"> </div><div class="line">   private:</div><div class="line">      double length;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 成员函数定义，包括构造函数</div><div class="line">Line::Line( double len)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl;</div><div class="line">    length = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void Line::setLength( double len )</div><div class="line">&#123;</div><div class="line">    length = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">double Line::getLength( void )</div><div class="line">&#123;</div><div class="line">    return length;</div><div class="line">&#125;</div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Line line(10.0);</div><div class="line"> </div><div class="line">   // 获取默认设置的长度</div><div class="line">   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;</div><div class="line">   // 再次设置长度</div><div class="line">   line.setLength(6.0); </div><div class="line">   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object is being created, length = 10</div><div class="line">Length of line : 10</div><div class="line">Length of line : 6</div></pre></td></tr></table></figure></p>
<h3 id="使用初始化列表来初始化字段"><a href="#使用初始化列表来初始化字段" class="headerlink" title="使用初始化列表来初始化字段"></a>使用初始化列表来初始化字段</h3><p>使用初始化列表来初始化字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Line::Line( double len): length(len)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的语法等同于如下语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Line::Line( double len)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;Object is being created, length = &quot; &lt;&lt; len &lt;&lt; endl;</div><div class="line">    length = len;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">C::C( double a, double b, double c): X(a), Y(b), Z(c)</div><div class="line">&#123;</div><div class="line">  ....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="类的析构函数"><a href="#类的析构函数" class="headerlink" title="类的析构函数"></a>类的析构函数</h3><p>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p>
<p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</p>
<p>下面的实例有助于更好地理解析构函数的概念：<br>实例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span>;</div><div class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</div><div class="line">      Line();   <span class="comment">// 这是构造函数声明</span></div><div class="line">      ~Line();  <span class="comment">// 这是析构函数声明</span></div><div class="line"> </div><div class="line">   <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">double</span> length;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// 成员函数定义，包括构造函数</span></div><div class="line">Line::Line(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">Line::~Line(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being deleted"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">void</span> Line::setLength( <span class="keyword">double</span> len )</div><div class="line">&#123;</div><div class="line">    length = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">double</span> Line::getLength( <span class="keyword">void</span> )</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> length;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 程序的主函数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></div><div class="line">&#123;</div><div class="line">   Line line;</div><div class="line"> </div><div class="line">   <span class="comment">// 设置长度</span></div><div class="line">   line.setLength(<span class="number">6.0</span>); </div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Length of line : "</span> &lt;&lt; line.getLength() &lt;&lt;<span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object is being created</div><div class="line">Length of line : 6</div><div class="line">Object is being deleted</div></pre></td></tr></table></figure></p>
<h2 id="1-4-C-拷贝构造函数"><a href="#1-4-C-拷贝构造函数" class="headerlink" title="1.4.C++ 拷贝构造函数"></a>1.4.C++ 拷贝构造函数</h2><p><strong>拷贝构造函数</strong>是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p>
<pre><code>通过使用另一个同类型的对象来初始化新创建的对象。

复制对象把它作为参数传递给函数。

复制对象，并从函数返回这个对象。
</code></pre><p><strong>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。</strong><br><strong>如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。</strong><br>拷贝构造函数的最常见形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">classname (const classname &amp;obj) &#123;</div><div class="line">   // 构造函数的主体</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，obj 是一个对象引用，该对象是用于初始化另一个对象的。<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Line</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      int getLength( void );</div><div class="line">      Line( int len );             // 简单的构造函数</div><div class="line">      Line( const Line &amp;obj);      // 拷贝构造函数</div><div class="line">      ~Line();                     // 析构函数</div><div class="line"> </div><div class="line">   private:</div><div class="line">      int *ptr;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 成员函数定义，包括构造函数</div><div class="line">Line::Line(int len)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;调用构造函数&quot; &lt;&lt; endl;</div><div class="line">    // 为指针分配内存</div><div class="line">    ptr = new int;</div><div class="line">    *ptr = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Line::Line(const Line &amp;obj)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;调用拷贝构造函数并为指针 ptr 分配内存&quot; &lt;&lt; endl;</div><div class="line">    ptr = new int;</div><div class="line">    *ptr = *obj.ptr; // 拷贝值</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Line::~Line(void)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;释放内存&quot; &lt;&lt; endl;</div><div class="line">    delete ptr;</div><div class="line">&#125;</div><div class="line">int Line::getLength( void )</div><div class="line">&#123;</div><div class="line">    return *ptr;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void display(Line obj)</div><div class="line">&#123;</div><div class="line">   cout &lt;&lt; &quot;line 大小 : &quot; &lt;&lt; obj.getLength() &lt;&lt;endl;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Line line(10);</div><div class="line"> </div><div class="line">   display(line);</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">调用构造函数</div><div class="line">调用拷贝构造函数并为指针 ptr 分配内存</div><div class="line">line 大小 : 10</div><div class="line">释放内存</div><div class="line">释放内存</div></pre></td></tr></table></figure></p>
<p>下面的实例对上面的实例稍作修改，通过使用已有的同类型的对象来初始化新创建的对象：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Line</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      int getLength( void );</div><div class="line">      Line( int len );             // 简单的构造函数</div><div class="line">      Line( const Line &amp;obj);      // 拷贝构造函数</div><div class="line">      ~Line();                     // 析构函数</div><div class="line"> </div><div class="line">   private:</div><div class="line">      int *ptr;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 成员函数定义，包括构造函数</div><div class="line">Line::Line(int len)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;调用构造函数&quot; &lt;&lt; endl;</div><div class="line">    // 为指针分配内存</div><div class="line">    ptr = new int;</div><div class="line">    *ptr = len;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Line::Line(const Line &amp;obj)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;调用拷贝构造函数并为指针 ptr 分配内存&quot; &lt;&lt; endl;</div><div class="line">    ptr = new int;</div><div class="line">    *ptr = *obj.ptr; // 拷贝值</div><div class="line">&#125;</div><div class="line"> </div><div class="line">Line::~Line(void)</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; &quot;释放内存&quot; &lt;&lt; endl;</div><div class="line">    delete ptr;</div><div class="line">&#125;</div><div class="line">int Line::getLength( void )</div><div class="line">&#123;</div><div class="line">    return *ptr;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void display(Line obj)</div><div class="line">&#123;</div><div class="line">   cout &lt;&lt; &quot;line 大小 : &quot; &lt;&lt; obj.getLength() &lt;&lt;endl;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Line line1(10);</div><div class="line"> </div><div class="line">   Line line2 = line1; // 这里也调用了拷贝构造函数</div><div class="line"> </div><div class="line">   display(line1);</div><div class="line">   display(line2);</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">调用构造函数</div><div class="line">调用拷贝构造函数并为指针 ptr 分配内存</div><div class="line">调用拷贝构造函数并为指针 ptr 分配内存</div><div class="line">line 大小 : 10</div><div class="line">释放内存</div><div class="line">调用拷贝构造函数并为指针 ptr 分配内存</div><div class="line">line 大小 : 10</div><div class="line">释放内存</div><div class="line">释放内存</div><div class="line">释放内存</div></pre></td></tr></table></figure></p>
<h2 id="1-5-C-友元函数"><a href="#1-5-C-友元函数" class="headerlink" title="1.5.C++ 友元函数"></a>1.5.C++ 友元函数</h2><p><strong>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。</strong>尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p>
<p>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。</p>
<p>如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   double width;</div><div class="line">public:</div><div class="line">   double length;</div><div class="line">   friend void printWidth( Box box );</div><div class="line">   void setWidth( double wid );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>声明类 ClassTwo 的所有成员函数作为类 ClassOne 的友元，需要在类 ClassOne 的定义中放置如下声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">friend class ClassTwo;</div></pre></td></tr></table></figure></p>
<p>请看下面的程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   double width;</div><div class="line">public:</div><div class="line">   friend void printWidth( Box box );</div><div class="line">   void setWidth( double wid );</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 成员函数定义</div><div class="line">void Box::setWidth( double wid )</div><div class="line">&#123;</div><div class="line">    width = wid;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 请注意：printWidth() 不是任何类的成员函数</div><div class="line">void printWidth( Box box )</div><div class="line">&#123;</div><div class="line">   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */</div><div class="line">   cout &lt;&lt; &quot;Width of box : &quot; &lt;&lt; box.width &lt;&lt;endl;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Box box;</div><div class="line"> </div><div class="line">   // 使用成员函数设置宽度</div><div class="line">   box.setWidth(10.0);</div><div class="line">   </div><div class="line">   // 使用友元函数输出宽度</div><div class="line">   printWidth( box );</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Width of box : 10</div></pre></td></tr></table></figure></p>
<h2 id="1-6-C-内联函数"><a href="#1-6-C-内联函数" class="headerlink" title="1.6.C++ 内联函数"></a>1.6.C++ 内联函数</h2><p>C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。</p>
<p>对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。</p>
<p><strong>如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。</strong>如果已定义的函数多于一行，编译器会忽略 inline 限定符。</p>
<p><strong>在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。</strong></p>
<p>下面是一个实例，使用内联函数来返回两个数中的最大值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">inline int Max(int x, int y)</div><div class="line">&#123;</div><div class="line">   return (x &gt; y)? x : y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 程序的主函数</div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line"></div><div class="line">   cout &lt;&lt; &quot;Max (20,10): &quot; &lt;&lt; Max(20,10) &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;Max (0,200): &quot; &lt;&lt; Max(0,200) &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;Max (100,1010): &quot; &lt;&lt; Max(100,1010) &lt;&lt; endl;</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Max (20,10): 20</div><div class="line">Max (0,200): 200</div><div class="line">Max (100,1010): 1010</div></pre></td></tr></table></figure></p>
<h2 id="1-7-C-this-指针"><a href="#1-7-C-this-指针" class="headerlink" title="1.7.C++ this 指针"></a>1.7.C++ this 指针</h2><p>在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p>
<p>友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。</p>
<p>下面的实例有助于更好地理解 this 指针的概念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      // 构造函数定义</div><div class="line">      Box(double l=2.0, double b=2.0, double h=2.0)</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt;&quot;Constructor called.&quot; &lt;&lt; endl;</div><div class="line">         length = l;</div><div class="line">         breadth = b;</div><div class="line">         height = h;</div><div class="line">      &#125;</div><div class="line">      double Volume()</div><div class="line">      &#123;</div><div class="line">         return length * breadth * height;</div><div class="line">      &#125;</div><div class="line">      int compare(Box box)</div><div class="line">      &#123;</div><div class="line">         return this-&gt;Volume() &gt; box.Volume();</div><div class="line">      &#125;</div><div class="line">   private:</div><div class="line">      double length;     // Length of a box</div><div class="line">      double breadth;    // Breadth of a box</div><div class="line">      double height;     // Height of a box</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">   Box Box1(3.3, 1.2, 1.5);    // Declare box1</div><div class="line">   Box Box2(8.5, 6.0, 2.0);    // Declare box2</div><div class="line"></div><div class="line">   if(Box1.compare(Box2))</div><div class="line">   &#123;</div><div class="line">      cout &lt;&lt; &quot;Box2 is smaller than Box1&quot; &lt;&lt;endl;</div><div class="line">   &#125;</div><div class="line">   else</div><div class="line">   &#123;</div><div class="line">      cout &lt;&lt; &quot;Box2 is equal to or larger than Box1&quot; &lt;&lt;endl;</div><div class="line">   &#125;</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Constructor called.</div><div class="line">Constructor called.</div><div class="line">Box2 is equal to or larger than Box1</div></pre></td></tr></table></figure></p>
<h2 id="1-8-C-指向类的指针"><a href="#1-8-C-指向类的指针" class="headerlink" title="1.8.C++ 指向类的指针"></a>1.8.C++ 指向类的指针</h2><p>一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符<code>-&gt;</code>，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。</p>
<p>下面的实例有助于更好地理解指向类的指针的概念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      // 构造函数定义</div><div class="line">      Box(double l=2.0, double b=2.0, double h=2.0)</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt;&quot;Constructor called.&quot; &lt;&lt; endl;</div><div class="line">         length = l;</div><div class="line">         breadth = b;</div><div class="line">         height = h;</div><div class="line">      &#125;</div><div class="line">      double Volume()</div><div class="line">      &#123;</div><div class="line">         return length * breadth * height;</div><div class="line">      &#125;</div><div class="line">   private:</div><div class="line">      double length;     // Length of a box</div><div class="line">      double breadth;    // Breadth of a box</div><div class="line">      double height;     // Height of a box</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">   Box Box1(3.3, 1.2, 1.5);    // Declare box1</div><div class="line">   Box Box2(8.5, 6.0, 2.0);    // Declare box2</div><div class="line">   Box *ptrBox;                // Declare pointer to a class.</div><div class="line"></div><div class="line">   // 保存第一个对象的地址</div><div class="line">   ptrBox = &amp;Box1;</div><div class="line"></div><div class="line">   // 现在尝试使用成员访问运算符来访问成员</div><div class="line">   cout &lt;&lt; &quot;Volume of Box1: &quot; &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; endl;</div><div class="line"></div><div class="line">   // 保存第二个对象的地址</div><div class="line">   ptrBox = &amp;Box2;</div><div class="line"></div><div class="line">   // 现在尝试使用成员访问运算符来访问成员</div><div class="line">   cout &lt;&lt; &quot;Volume of Box2: &quot; &lt;&lt; ptrBox-&gt;Volume() &lt;&lt; endl;</div><div class="line">  </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Constructor called.</div><div class="line">Constructor called.</div><div class="line">Volume of Box1: 5.94</div><div class="line">Volume of Box2: 102</div></pre></td></tr></table></figure></p>
<h2 id="1-9-C-类的静态成员"><a href="#1-9-C-类的静态成员" class="headerlink" title="1.9.C++ 类的静态成员"></a>1.9.C++ 类的静态成员</h2><p>我们可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。</p>
<p>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化，如下面的实例所示。</p>
<p>下面的实例有助于更好地理解静成员态数据的概念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      static int objectCount;</div><div class="line">      // 构造函数定义</div><div class="line">      Box(double l=2.0, double b=2.0, double h=2.0)</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt;&quot;Constructor called.&quot; &lt;&lt; endl;</div><div class="line">         length = l;</div><div class="line">         breadth = b;</div><div class="line">         height = h;</div><div class="line">         // 每次创建对象时增加 1</div><div class="line">         objectCount++;</div><div class="line">      &#125;</div><div class="line">      double Volume()</div><div class="line">      &#123;</div><div class="line">         return length * breadth * height;</div><div class="line">      &#125;</div><div class="line">   private:</div><div class="line">      double length;     // 长度</div><div class="line">      double breadth;    // 宽度</div><div class="line">      double height;     // 高度</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 初始化类 Box 的静态成员</div><div class="line">int Box::objectCount = 0;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">   Box Box1(3.3, 1.2, 1.5);    // 声明 box1</div><div class="line">   Box Box2(8.5, 6.0, 2.0);    // 声明 box2</div><div class="line"></div><div class="line">   // 输出对象的总数</div><div class="line">   cout &lt;&lt; &quot;Total objects: &quot; &lt;&lt; Box::objectCount &lt;&lt; endl;</div><div class="line"></div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Constructor called.</div><div class="line">Constructor called.</div><div class="line">Total objects: 2</div></pre></td></tr></table></figure></p>
<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><p>如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符<code>::</code> 就可以访问。</p>
<p>静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。</p>
<p>静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。</p>
<blockquote>
<p>   静态成员函数与普通成员函数的区别：</p>
<pre><code>静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。

普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。
</code></pre></blockquote>
<p>下面的实例有助于更好地理解静态成员函数的概念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Box</div><div class="line">&#123;</div><div class="line">   public:</div><div class="line">      static int objectCount;</div><div class="line">      // 构造函数定义</div><div class="line">      Box(double l=2.0, double b=2.0, double h=2.0)</div><div class="line">      &#123;</div><div class="line">         cout &lt;&lt;&quot;Constructor called.&quot; &lt;&lt; endl;</div><div class="line">         length = l;</div><div class="line">         breadth = b;</div><div class="line">         height = h;</div><div class="line">         // 每次创建对象时增加 1</div><div class="line">         objectCount++;</div><div class="line">      &#125;</div><div class="line">      double Volume()</div><div class="line">      &#123;</div><div class="line">         return length * breadth * height;</div><div class="line">      &#125;</div><div class="line">      static int getCount()</div><div class="line">      &#123;</div><div class="line">         return objectCount;</div><div class="line">      &#125;</div><div class="line">   private:</div><div class="line">      double length;     // 长度</div><div class="line">      double breadth;    // 宽度</div><div class="line">      double height;     // 高度</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 初始化类 Box 的静态成员</div><div class="line">int Box::objectCount = 0;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">  </div><div class="line">   // 在创建对象之前输出对象的总数</div><div class="line">   cout &lt;&lt; &quot;Inital Stage Count: &quot; &lt;&lt; Box::getCount() &lt;&lt; endl;</div><div class="line"></div><div class="line">   Box Box1(3.3, 1.2, 1.5);    // 声明 box1</div><div class="line">   Box Box2(8.5, 6.0, 2.0);    // 声明 box2</div><div class="line"></div><div class="line">   // 在创建对象之后输出对象的总数</div><div class="line">   cout &lt;&lt; &quot;Final Stage Count: &quot; &lt;&lt; Box::getCount() &lt;&lt; endl;</div><div class="line"></div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Inital Stage Count: 0</div><div class="line">Constructor called.</div><div class="line">Constructor called.</div><div class="line">Final Stage Count: 2</div></pre></td></tr></table></figure></p>
<p>转自：<a href="http://www.runoob.com/cplusplus/cpp-classes-objects.html" target="_blank" rel="external">c++类&amp;对象|菜鸟教程</a></p>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c++笔记：（2）]]></title>
      <url>/2017/11/13/c++%E7%AC%94%E8%AE%B0/c++%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="1-C-指针"><a href="#1-C-指针" class="headerlink" title="1.C++ 指针"></a>1.C++ 指针</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   int  var = 20;   // 实际变量的声明</div><div class="line">   int  *ip;        // 指针变量的声明</div><div class="line"> </div><div class="line">   ip = &amp;var;       // 在指针变量中存储 var 的地址</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;Value of var variable: &quot;;</div><div class="line">   cout &lt;&lt; var &lt;&lt; endl;</div><div class="line"> </div><div class="line">   // 输出在指针变量中存储的地址</div><div class="line">   cout &lt;&lt; &quot;Address stored in ip variable: &quot;;</div><div class="line">   cout &lt;&lt; ip &lt;&lt; endl;</div><div class="line"> </div><div class="line">   // 访问指针中地址的值</div><div class="line">   cout &lt;&lt; &quot;Value of *ip variable: &quot;;</div><div class="line">   cout &lt;&lt; *ip &lt;&lt; endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">Value of var variable: 20</div><div class="line">Address stored in ip variable: 0x7ffd7a7a7fd4</div><div class="line">Value of *ip variable: 20</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure>
<h1 id="2-C-传递指针给函数"><a href="#2-C-传递指针给函数" class="headerlink" title="2.C++ 传递指针给函数"></a>2.C++ 传递指针给函数</h1><p>c++指针传递给函数时，可以在函数中改变指针所指变量的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">// 函数声明</div><div class="line"></div><div class="line">double getAverage(int *arr, int size);</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">int main ()</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">   // 带有 5 个元素的整型数组</div><div class="line"></div><div class="line">   int balance[5] = &#123;1000, 2, 3, 17, 50&#125;;</div><div class="line"></div><div class="line">   double avg;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">   // 传递一个指向数组的指针作为参数</div><div class="line"></div><div class="line">   avg = getAverage( balance, 5 ) ;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">   // 输出返回值</div><div class="line"></div><div class="line">   cout &lt;&lt; &quot;Average value is: &quot; &lt;&lt; avg &lt;&lt; endl;</div><div class="line"></div><div class="line">    cout &lt;&lt; &quot;Average value is: &quot; &lt;&lt; balance[0] &lt;&lt; endl;</div><div class="line"></div><div class="line">     cout &lt;&lt; &quot;Average value is: &quot; &lt;&lt; balance[1] &lt;&lt; endl;</div><div class="line"></div><div class="line">      cout &lt;&lt; &quot;Average value is: &quot; &lt;&lt; balance[2]&lt;&lt; endl;</div><div class="line"></div><div class="line">       cout &lt;&lt; &quot;Average value is: &quot; &lt;&lt; balance[3] &lt;&lt; endl;</div><div class="line"></div><div class="line">        cout &lt;&lt; &quot;Average value is: &quot; &lt;&lt; balance[4] &lt;&lt; endl;</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">   return 0;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">double getAverage(int *arr, int size)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">  int    i, sum = 0;       </div><div class="line"></div><div class="line">  double avg;          </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">  for (i = 0; i &lt; size; ++i)</div><div class="line"></div><div class="line">  &#123;</div><div class="line"></div><div class="line">    sum += arr[i];</div><div class="line"></div><div class="line">    arr[i] =arr[i]+1;</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">  avg = double(sum) / size;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">  return avg;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line"></div><div class="line">Average value is: 214.4</div><div class="line"></div><div class="line">Average value is: 1001</div><div class="line"></div><div class="line">Average value is: 3</div><div class="line"></div><div class="line">Average value is: 4</div><div class="line"></div><div class="line">Average value is: 18</div><div class="line"></div><div class="line">Average value is: 51</div><div class="line"></div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure>
<h1 id="3-C-从函数返回指针"><a href="#3-C-从函数返回指针" class="headerlink" title="3.C++ 从函数返回指针"></a>3.C++ 从函数返回指针</h1><p>另外，C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。</p>
<p>现在，让我们来看下面的函数，它会生成 10 个随机数，并使用表示指针的数组名（即第一个数组元素的地址）来返回它们，具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;ctime&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 要生成和返回随机数的函数</div><div class="line">int * getRandom( )</div><div class="line">&#123;</div><div class="line">  static int  r[10];</div><div class="line"> </div><div class="line">  // 设置种子</div><div class="line">  srand( (unsigned)time( NULL ) );</div><div class="line">  for (int i = 0; i &lt; 10; ++i)</div><div class="line">  &#123;</div><div class="line">    r[i] = rand();</div><div class="line">    cout &lt;&lt; r[i] &lt;&lt; endl;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  return r;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 要调用上面定义函数的主函数</div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   // 一个指向整数的指针</div><div class="line">   int *p;</div><div class="line"> </div><div class="line">   p = getRandom();</div><div class="line">   for ( int i = 0; i &lt; 10; i++ )</div><div class="line">   &#123;</div><div class="line">       cout &lt;&lt; &quot;*(p + &quot; &lt;&lt; i &lt;&lt; &quot;) : &quot;;</div><div class="line">       cout &lt;&lt; *(p + i) &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">624723190</div><div class="line">1468735695</div><div class="line">807113585</div><div class="line">976495677</div><div class="line">613357504</div><div class="line">1377296355</div><div class="line">1530315259</div><div class="line">1778906708</div><div class="line">1820354158</div><div class="line">667126415</div><div class="line">*(p + 0) : 624723190</div><div class="line">*(p + 1) : 1468735695</div><div class="line">*(p + 2) : 807113585</div><div class="line">*(p + 3) : 976495677</div><div class="line">*(p + 4) : 613357504</div><div class="line">*(p + 5) : 1377296355</div><div class="line">*(p + 6) : 1530315259</div><div class="line">*(p + 7) : 1778906708</div><div class="line">*(p + 8) : 1820354158</div><div class="line">*(p + 9) : 667126415</div></pre></td></tr></table></figure></p>
<h1 id="4-C-引用"><a href="#4-C-引用" class="headerlink" title="4.C++ 引用"></a>4.C++ 引用</h1><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。<br>C++ 引用 vs 指针</p>
<h4 id="引用很容易与指针混淆，它们之间有三个主要的不同："><a href="#引用很容易与指针混淆，它们之间有三个主要的不同：" class="headerlink" title="引用很容易与指针混淆，它们之间有三个主要的不同："></a>引用很容易与指针混淆，它们之间有三个主要的不同：</h4><blockquote>
<ul>
<li>不存在空引用。引用必须连接到一块合法的内存。</li>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li>
<li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li>
</ul>
</blockquote>
<h4 id="C-中创建引用"><a href="#C-中创建引用" class="headerlink" title="C++ 中创建引用"></a>C++ 中创建引用</h4><p>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int i = 17;</div></pre></td></tr></table></figure></p>
<p>我们可以为 i 声明引用变量，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int&amp;    r = i;</div></pre></td></tr></table></figure></p>
<p>在这些声明中，&amp; 读作引用。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   // 声明简单的变量</div><div class="line">   int    i;</div><div class="line">   double d;</div><div class="line"> </div><div class="line">   // 声明引用变量</div><div class="line">   int&amp;    r = i;</div><div class="line">   double&amp; s = d;</div><div class="line">   </div><div class="line">   i = 5;</div><div class="line">   cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r  &lt;&lt; endl;</div><div class="line"> </div><div class="line">   d = 11.7;</div><div class="line">   cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s  &lt;&lt; endl;</div><div class="line">   </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Value of i : 5</div><div class="line">Value of i reference : 5</div><div class="line">Value of d : 11.7</div><div class="line">Value of d reference : 11.7</div></pre></td></tr></table></figure></p>
<p>引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：<br>|概念    | 描述 |<br>|—|:—:|<br>| 4.1 把引用作为参数    | C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。|<br>|4.2 把引用作为返回值 |    可以从 C++ 函数中返回引用，就像返回其他数据类型一样。|</p>
<h1 id="4-1C-把引用作为参数"><a href="#4-1C-把引用作为参数" class="headerlink" title="4.1C++ 把引用作为参数"></a>4.1C++ 把引用作为参数</h1><p>我们已经讨论了如何使用指针来实现引用调用函数。下面的实例使用了引用来实现引用调用函数。<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 函数声明</div><div class="line">void swap(int&amp; x, int&amp; y);</div><div class="line"> </div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   // 局部变量声明</div><div class="line">   int a = 100;</div><div class="line">   int b = 200;</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;交换前，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;交换前，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;</div><div class="line"> </div><div class="line">   /* 调用函数来交换值 */</div><div class="line">   swap(a, b);</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;交换后，a 的值：&quot; &lt;&lt; a &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;交换后，b 的值：&quot; &lt;&lt; b &lt;&lt; endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 函数定义</div><div class="line">void swap(int&amp; x, int&amp; y)</div><div class="line">&#123;</div><div class="line">   int temp;</div><div class="line">   temp = x; /* 保存地址 x 的值 */</div><div class="line">   x = y;    /* 把 y 赋值给 x */</div><div class="line">   y = temp; /* 把 x 赋值给 y  */</div><div class="line">  </div><div class="line">   return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">交换前，a 的值： 100</div><div class="line">交换前，b 的值： 200</div><div class="line">交换后，a 的值： 200</div><div class="line">交换后，b 的值： 100</div></pre></td></tr></table></figure></p>
<h2 id="4-2-C-把引用作为返回值"><a href="#4-2-C-把引用作为返回值" class="headerlink" title="4.2 C++ 把引用作为返回值"></a>4.2 C++ 把引用作为返回值</h2><p>通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护。C++ 函数可以返回一个引用，方式与返回一个指针类似。</p>
<p>当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。例如，请看下面这个简单的程序：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">double vals[] = &#123;10.1, 12.6, 33.1, 24.1, 50.0&#125;;</div><div class="line"> </div><div class="line">double&amp; setValues( int i )</div><div class="line">&#123;</div><div class="line">  return vals[i];   // 返回第 i 个元素的引用</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 要调用上面定义函数的主函数</div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;改变前的值&quot; &lt;&lt; endl;</div><div class="line">   for ( int i = 0; i &lt; 5; i++ )</div><div class="line">   &#123;</div><div class="line">       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;</div><div class="line">       cout &lt;&lt; vals[i] &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   setValues(1) = 20.23; // 改变第 2 个元素</div><div class="line">   setValues(3) = 70.8;  // 改变第 4 个元素</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;改变后的值&quot; &lt;&lt; endl;</div><div class="line">   for ( int i = 0; i &lt; 5; i++ )</div><div class="line">   &#123;</div><div class="line">       cout &lt;&lt; &quot;vals[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot;;</div><div class="line">       cout &lt;&lt; vals[i] &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">改变前的值</div><div class="line">vals[0] = 10.1</div><div class="line">vals[1] = 12.6</div><div class="line">vals[2] = 33.1</div><div class="line">vals[3] = 24.1</div><div class="line">vals[4] = 50</div><div class="line">改变后的值</div><div class="line">vals[0] = 10.1</div><div class="line">vals[1] = 20.23</div><div class="line">vals[2] = 33.1</div><div class="line">vals[3] = 70.8</div><div class="line">vals[4] = 50</div></pre></td></tr></table></figure></p>
<p>当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int&amp; func() &#123;</div><div class="line">   int q;</div><div class="line">   //! return q; // 在编译时发生错误</div><div class="line">   static int x;</div><div class="line">   return x;     // 安全，x 在函数作用域外依然是有效的</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="5-C-日期-amp-时间"><a href="#5-C-日期-amp-时间" class="headerlink" title="5.C++ 日期 &amp; 时间"></a>5.C++ 日期 &amp; 时间</h1><p>C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。</ctime></p>
<p>有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。</p>
<p>结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct tm &#123;</div><div class="line">  int tm_sec;   // 秒，正常范围从 0 到 59，但允许至 61</div><div class="line">  int tm_min;   // 分，范围从 0 到 59</div><div class="line">  int tm_hour;  // 小时，范围从 0 到 23</div><div class="line">  int tm_mday;  // 一月中的第几天，范围从 1 到 31</div><div class="line">  int tm_mon;   // 月，范围从 0 到 11</div><div class="line">  int tm_year;  // 自 1900 年起的年数</div><div class="line">  int tm_wday;  // 一周中的第几天，范围从 0 到 6，从星期日算起</div><div class="line">  int tm_yday;  // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起</div><div class="line">  int tm_isdst; // 夏令时</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用结构-tm-格式化时间"><a href="#使用结构-tm-格式化时间" class="headerlink" title="使用结构 tm 格式化时间"></a>使用结构 tm 格式化时间</h3><p>tm 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。</p>
<p>在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -&gt; 运算符来访问结构成员。<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;ctime&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   // 基于当前系统的当前日期/时间</div><div class="line">   time_t now = time(0);</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;1970 到目前经过秒数:&quot; &lt;&lt; now &lt;&lt; endl;</div><div class="line"> </div><div class="line">   tm *ltm = localtime(&amp;now);</div><div class="line"> </div><div class="line">   // 输出 tm 结构的各个组成部分</div><div class="line">   cout &lt;&lt; &quot;年: &quot;&lt;&lt; 1900 + ltm-&gt;tm_year &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;月: &quot;&lt;&lt; 1 + ltm-&gt;tm_mon&lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;日: &quot;&lt;&lt;  ltm-&gt;tm_mday &lt;&lt; endl;</div><div class="line">   cout &lt;&lt; &quot;时间: &quot;&lt;&lt; ltm-&gt;tm_hour &lt;&lt; &quot;:&quot;;</div><div class="line">   cout &lt;&lt; ltm-&gt;tm_min &lt;&lt; &quot;:&quot;;</div><div class="line">   cout &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1970 到目前时间:1503564157</div><div class="line">年: 2017</div><div class="line">月: 8</div><div class="line">日: 24</div><div class="line">时间: 16:42:37</div></pre></td></tr></table></figure></p>
<h1 id="6-C-基本的输入输出"><a href="#6-C-基本的输入输出" class="headerlink" title="6.C++ 基本的输入输出"></a>6.C++ 基本的输入输出</h1><p>C++ 标准库提供了一组丰富的输入/输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。</p>
<blockquote>
<ul>
<li>如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。</li>
<li>如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。<br>I/O 库头文件</li>
</ul>
</blockquote>
<p>下列的头文件在 C++ 编程中很重要。<br>|头文件    |函数和描述|<br>|—|—|<br>| &lt; iostream &gt;     |该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。|<br>| &lt; iomanip &gt;    |该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。|<br>| &lt; fstream &gt;    | 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。|</p>
<h3 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a>标准输出流（cout）</h3><p>预定义的对象 cout 是 ostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符<code>&lt;&lt;</code>结合使用的，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   char str[] = &quot;Hello C++&quot;;</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;Value of str is : &quot; &lt;&lt; str &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Value of str is : Hello C++</div></pre></td></tr></table></figure></p>
<p>C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。<code>&lt;&lt;</code>运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。</p>
<p>流插入运算符<code>&lt;&lt;</code>在一个语句中可以多次使用，如上面实例中所示，<code>endl</code> 用于在行末添加一个换行符。</p>
<h3 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a>标准输入流（cin）</h3><p>预定义的对象<code>cin</code> 是 istream 类的一个实例。<code>cin</code>对象附属到标准输入设备，通常是键盘。<code>cin</code>是与流提取运算符 <code>&gt;&gt;</code>结合使用的，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   char name[50];</div><div class="line"> </div><div class="line">   cout &lt;&lt; &quot;请输入您的名称： &quot;;</div><div class="line">   cin &gt;&gt; name;</div><div class="line">   cout &lt;&lt; &quot;您的名称是： &quot; &lt;&lt; name &lt;&lt; endl;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会提示用户输入名称。当用户输入一个值，并按回车键，就会看到下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">请输入您的名称： cplusplus</div><div class="line">您的名称是： cplusplus</div></pre></td></tr></table></figure></p>
<p>C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。</p>
<p>流提取运算符 <code>&gt;&gt;</code>在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cin &gt;&gt; name &gt;&gt; age;</div></pre></td></tr></table></figure></p>
<p>这相当于下面两个语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cin &gt;&gt; name;</div><div class="line">cin &gt;&gt; age;</div></pre></td></tr></table></figure></p>
<h3 id="标准错误流（cerr）"><a href="#标准错误流（cerr）" class="headerlink" title="标准错误流（cerr）"></a>标准错误流（cerr）</h3><p>预定义的对象 cerr 是 ostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p>
<p>cerr 也是与流插入运算符<code>&lt;&lt;</code> 结合使用的，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   char str[] = &quot;Unable to read....&quot;;</div><div class="line"> </div><div class="line">   cerr &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error message : Unable to read....</div></pre></td></tr></table></figure></p>
<h3 id="标准日志流（clog）"><a href="#标准日志流（clog）" class="headerlink" title="标准日志流（clog）"></a>标准日志流（clog）</h3><p>预定义的对象 clog 是 ostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。</p>
<p>clog 也是与流插入运算符 <code>&lt;&lt;</code>结合使用的，如下所示：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   char str[] = &quot;Unable to read....&quot;;</div><div class="line"> </div><div class="line">   clog &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error message : Unable to read....</div></pre></td></tr></table></figure></p>
<p>通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</p>
<h1 id="7-C-数据结构"><a href="#7-C-数据结构" class="headerlink" title="7.C++ 数据结构"></a>7.C++ 数据结构</h1><p>C/C++ 数组允许定义可存储相同类型数据项的变量，但是结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
<p>结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Title ：标题</div><div class="line">Author ：作者</div><div class="line">Subject ：类目</div><div class="line">Book ID ：书的 ID</div></pre></td></tr></table></figure></p>
<h3 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h3><p>为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct type_name &#123;</div><div class="line">member_type1 member_name1;</div><div class="line">member_type2 member_name2;</div><div class="line">member_type3 member_name3;</div><div class="line">.</div><div class="line">.</div><div class="line">&#125; object_names;</div></pre></td></tr></table></figure></p>
<p>type_name 是结构体类型的名称，member_type1 member_name1 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 Books，变量为 book：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct Books</div><div class="line">&#123;</div><div class="line">   char  title[50];</div><div class="line">   char  author[50];</div><div class="line">   char  subject[100];</div><div class="line">   int   book_id;</div><div class="line">&#125; book;</div></pre></td></tr></table></figure></p>
<h3 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h3><p>为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。</p>
<p>下面的实例演示了结构的用法：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 声明一个结构体类型 Books </div><div class="line">struct Books</div><div class="line">&#123;</div><div class="line">   char  title[50];</div><div class="line">   char  author[50];</div><div class="line">   char  subject[100];</div><div class="line">   int   book_id;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Books Book1;        // 定义结构体类型 Books 的变量 Book1</div><div class="line">   Books Book2;        // 定义结构体类型 Books 的变量 Book2</div><div class="line"> </div><div class="line">   // Book1 详述</div><div class="line">   strcpy( Book1.title, &quot;C++ 教程&quot;);</div><div class="line">   strcpy( Book1.author, &quot;Runoob&quot;); </div><div class="line">   strcpy( Book1.subject, &quot;编程语言&quot;);</div><div class="line">   Book1.book_id = 12345;</div><div class="line"> </div><div class="line">   // Book2 详述</div><div class="line">   strcpy( Book2.title, &quot;CSS 教程&quot;);</div><div class="line">   strcpy( Book2.author, &quot;Runoob&quot;);</div><div class="line">   strcpy( Book2.subject, &quot;前端技术&quot;);</div><div class="line">   Book2.book_id = 12346;</div><div class="line"> </div><div class="line">   // 输出 Book1 信息</div><div class="line">   cout &lt;&lt; &quot;第一本书标题 : &quot; &lt;&lt; Book1.title &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;第一本书作者 : &quot; &lt;&lt; Book1.author &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;第一本书类目 : &quot; &lt;&lt; Book1.subject &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;第一本书 ID : &quot; &lt;&lt; Book1.book_id &lt;&lt;endl;</div><div class="line"> </div><div class="line">   // 输出 Book2 信息</div><div class="line">   cout &lt;&lt; &quot;第二本书标题 : &quot; &lt;&lt; Book2.title &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;第二本书作者 : &quot; &lt;&lt; Book2.author &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;第二本书类目 : &quot; &lt;&lt; Book2.subject &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;第二本书 ID : &quot; &lt;&lt; Book2.book_id &lt;&lt;endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实例中定义了结构体类似 Books 及其两个变量 Book1 和 Book2。当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">第一本书标题 : C++ 教程</div><div class="line">第一本书作者 : Runoob</div><div class="line">第一本书类目 : 编程语言</div><div class="line">第一本书 ID : 12345</div><div class="line">第二本书标题 : CSS 教程</div><div class="line">第二本书作者 : Runoob</div><div class="line">第二本书类目 : 前端技术</div><div class="line">第二本书 ID : 12346</div></pre></td></tr></table></figure></p>
<h3 id="结构作为函数参数"><a href="#结构作为函数参数" class="headerlink" title="结构作为函数参数"></a>结构作为函数参数</h3><p>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line">void printBook( struct Books book );</div><div class="line"> </div><div class="line">// 声明一个结构体类型 Books </div><div class="line">struct Books</div><div class="line">&#123;</div><div class="line">   char  title[50];</div><div class="line">   char  author[50];</div><div class="line">   char  subject[100];</div><div class="line">   int   book_id;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Books Book1;        // 定义结构体类型 Books 的变量 Book1</div><div class="line">   Books Book2;        // 定义结构体类型 Books 的变量 Book2</div><div class="line"> </div><div class="line">    // Book1 详述</div><div class="line">   strcpy( Book1.title, &quot;C++ 教程&quot;);</div><div class="line">   strcpy( Book1.author, &quot;Runoob&quot;); </div><div class="line">   strcpy( Book1.subject, &quot;编程语言&quot;);</div><div class="line">   Book1.book_id = 12345;</div><div class="line"> </div><div class="line">   // Book2 详述</div><div class="line">   strcpy( Book2.title, &quot;CSS 教程&quot;);</div><div class="line">   strcpy( Book2.author, &quot;Runoob&quot;);</div><div class="line">   strcpy( Book2.subject, &quot;前端技术&quot;);</div><div class="line">   Book2.book_id = 12346;</div><div class="line"> </div><div class="line">   // 输出 Book1 信息</div><div class="line">   printBook( Book1 );</div><div class="line"> </div><div class="line">   // 输出 Book2 信息</div><div class="line">   printBook( Book2 );</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div><div class="line">void printBook( struct Books book )</div><div class="line">&#123;</div><div class="line">   cout &lt;&lt; &quot;书标题 : &quot; &lt;&lt; book.title &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;书作者 : &quot; &lt;&lt; book.author &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;书类目 : &quot; &lt;&lt; book.subject &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;书 ID : &quot; &lt;&lt; book.book_id &lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">书标题 : C++ 教程</div><div class="line">书作者 : Runoob</div><div class="line">书类目 : 编程语言</div><div class="line">书 ID : 12345</div><div class="line">书标题 : CSS 教程</div><div class="line">书作者 : Runoob</div><div class="line">书类目 : 前端技术</div><div class="line">书 ID : 12346</div></pre></td></tr></table></figure></p>
<h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct Books *struct_pointer;</div></pre></td></tr></table></figure></p>
<p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct_pointer = &amp;Book1;</div></pre></td></tr></table></figure></p>
<p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct_pointer-&gt;title;</div></pre></td></tr></table></figure></p>
<p>让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：<br>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line">void printBook( struct Books *book );</div><div class="line"> </div><div class="line">struct Books</div><div class="line">&#123;</div><div class="line">   char  title[50];</div><div class="line">   char  author[50];</div><div class="line">   char  subject[100];</div><div class="line">   int   book_id;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main( )</div><div class="line">&#123;</div><div class="line">   Books Book1;        // 定义结构体类型 Books 的变量 Book1</div><div class="line">   Books Book2;        // 定义结构体类型 Books 的变量 Book2</div><div class="line"> </div><div class="line">    // Book1 详述</div><div class="line">   strcpy( Book1.title, &quot;C++ 教程&quot;);</div><div class="line">   strcpy( Book1.author, &quot;Runoob&quot;); </div><div class="line">   strcpy( Book1.subject, &quot;编程语言&quot;);</div><div class="line">   Book1.book_id = 12345;</div><div class="line"> </div><div class="line">   // Book2 详述</div><div class="line">   strcpy( Book2.title, &quot;CSS 教程&quot;);</div><div class="line">   strcpy( Book2.author, &quot;Runoob&quot;);</div><div class="line">   strcpy( Book2.subject, &quot;前端技术&quot;);</div><div class="line">   Book2.book_id = 12346;</div><div class="line"> </div><div class="line">   // 通过传 Book1 的地址来输出 Book1 信息</div><div class="line">   printBook( &amp;Book1 );</div><div class="line"> </div><div class="line">   // 通过传 Book2 的地址来输出 Book2 信息</div><div class="line">   printBook( &amp;Book2 );</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div><div class="line">// 该函数以结构指针作为参数</div><div class="line">void printBook( struct Books *book )</div><div class="line">&#123;</div><div class="line">   cout &lt;&lt; &quot;书标题  : &quot; &lt;&lt; book-&gt;title &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;书作者 : &quot; &lt;&lt; book-&gt;author &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;书类目 : &quot; &lt;&lt; book-&gt;subject &lt;&lt;endl;</div><div class="line">   cout &lt;&lt; &quot;书 ID : &quot; &lt;&lt; book-&gt;book_id &lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">书标题  : C++ 教程</div><div class="line">书作者 : Runoob</div><div class="line">书类目 : 编程语言</div><div class="line">书 ID : 12345</div><div class="line">书标题  : CSS 教程</div><div class="line">书作者 : Runoob</div><div class="line">书类目 : 前端技术</div><div class="line">书 ID : 12346</div></pre></td></tr></table></figure></p>
<p>###typedef 关键字</p>
<p>下面是一种更简单的定义结构的方式，您可以为创建的类型取一个”别名”。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct</div><div class="line">&#123;</div><div class="line">   char  title[50];</div><div class="line">   char  author[50];</div><div class="line">   char  subject[100];</div><div class="line">   int   book_id;</div><div class="line">&#125;Books;</div></pre></td></tr></table></figure></p>
<p>现在，您可以直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字。下面是实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Books Book1, Book2;</div></pre></td></tr></table></figure></p>
<p>您可以使用 typedef 关键字来定义非结构类型，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef long int *pint32;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pint32 x, y, z;</div></pre></td></tr></table></figure>
<p>x, y 和 z 都是指向长整型 long int 的指针。</p>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c++笔记：（1）]]></title>
      <url>/2017/11/13/c++%E7%AC%94%E8%AE%B0/c++%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="1-C-指针运算符（-amp-和-）"><a href="#1-C-指针运算符（-amp-和-）" class="headerlink" title="1.C++ 指针运算符（&amp; 和 *）"></a>1.C++ 指针运算符（&amp; 和 *）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">int</span>  var;</div><div class="line">   <span class="keyword">int</span>  *ptr;</div><div class="line">   <span class="keyword">int</span>  val;</div><div class="line"></div><div class="line">   var = <span class="number">3000</span>;</div><div class="line"></div><div class="line">   <span class="comment">// 获取 var 的地址</span></div><div class="line">   ptr = &amp;var;</div><div class="line"></div><div class="line">   <span class="comment">// 获取 ptr 的值</span></div><div class="line">   val = *ptr;</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of var :"</span> &lt;&lt; var &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of ptr :"</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Value of val :"</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Value of var :<span class="number">3000</span></div><div class="line">Value of ptr :<span class="number">0xbff64494</span></div><div class="line">Value of val :<span class="number">3000</span></div></pre></td></tr></table></figure></p>
<h1 id="2-无限循环"><a href="#2-无限循环" class="headerlink" title="2.无限循环"></a>2.无限循环</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line"> </div><div class="line">   for( ; ; )</div><div class="line">   &#123;</div><div class="line">      printf(&quot;This loop will run forever.\n&quot;);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：您可以按 Ctrl + C 键终止一个无限循环。</p>
<h1 id="3-C-随机数"><a href="#3-C-随机数" class="headerlink" title="3.C++ 随机数"></a>3.C++ 随机数</h1><p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 rand()，该函数只返回一个伪随机数。生成随机数之前必须先调用 srand() 函数。</p>
<p>下面是一个关于生成随机数的简单实例。实例中使用了 time() 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：<br>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;time.h&gt; /*用到了time函数，所以要有这个头文件*/</div><div class="line">#define MAX 10</div><div class="line"> </div><div class="line">int main( void)</div><div class="line">&#123;</div><div class="line">    int number[MAX] = &#123;0&#125;;</div><div class="line">    int i;</div><div class="line">    srand((unsigned) time(NULL)); /*播种子*/</div><div class="line">    for(i = 0; i &lt; MAX; i++)</div><div class="line">    &#123;</div><div class="line">        number[i] = rand() % 100; /*产生100以内的随机整数*/</div><div class="line">        printf(&quot;%d &quot;, number[i]);</div><div class="line">    &#125;</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">36 32 0 2 45 89 48 73 93 79 </div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure>
<h1 id="4-关于“using-namespace-std”"><a href="#4-关于“using-namespace-std”" class="headerlink" title="4.关于“using namespace std”"></a>4.关于“using namespace std”</h1><p>　对于一个存在着标准输入输出的C++控制台程序，一般会在#include <iostream>的下一行发现一句话，using namespace std。这句话其实就表示了所有的标准库函数都在标准命名空间std中进行了定义。其作用就在于避免发生重命名的问题。<br>　　1. 关于namespace<br>　　C++引入了命名空间namespace主要解决了多个程序员在编写同一个项目中可能出现的函数等重名的现象。解决方法就是加上自己的命名空间。比如下面的例子：</iostream></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">namespace ZhangSan</div><div class="line">&#123;</div><div class="line">    int a=10; //张三把10赋值给了变量a</div><div class="line">&#125;</div><div class="line">namespace LiSi</div><div class="line">&#123;</div><div class="line">    int a=5; //李四把10赋值给了变量a</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">    int a=1;</div><div class="line">    cout&lt;&lt;&quot;张三定义的a=&quot;&lt;&lt;ZhangSan::a&lt;&lt;endl;</div><div class="line">    cout&lt;&lt;&quot;李四定义的a=&quot;&lt;&lt;LiSi::a&lt;&lt;endl;</div><div class="line">    cout&lt;&lt;&quot;主函数定义的a=&quot;&lt;&lt;a&lt;&lt;endl;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">张三定义的a=10</div><div class="line">李四定义的a=5</div><div class="line">主函数定义的a=1</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure></p>
<p>　　上例中的“ZhangSan::a”和“LiSi::a”分别表示了调用张三命名空间中的a变量和李四命名空间中的a变量。这样的好处显而易见，那就是虽然张三和李四这两个程序员都定义了一个变量a，但是并不会出现重名的危险。</p>
<h1 id="5-include-lt-iostream-gt-和-include-lt-iostream-h-gt-的区别"><a href="#5-include-lt-iostream-gt-和-include-lt-iostream-h-gt-的区别" class="headerlink" title="5.#include&lt;iostream&gt;和#include&lt;iostream.h&gt;的区别"></a>5.<code>#include&lt;iostream&gt;</code>和<code>#include&lt;iostream.h&gt;</code>的区别</h1><p>　　区别在于：如果用了isotream则一定要引入命名空间，即”using namespace std;<br>　　<br>    　　如果用了iostream.h，则不能引入命名空间，否则会引起编译错误，提示找不到命名空间. </p>
<p>例程如下：</p>
<p>情况一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//情况一：使用&lt;iostream&gt;和命名空间 </div><div class="line"> #include  &lt;iostream&gt; </div><div class="line"> using  namespace  std; </div><div class="line"> int main() </div><div class="line"> &#123; </div><div class="line">    cout&lt;&lt;&quot;&lt;iostream&gt;  need  to  use  namespace  std!\n&quot;; </div><div class="line">    return  0; </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;iostream&gt;  need  to  use  namespace  std! </div><div class="line"> Press  any  key  to  continue</div></pre></td></tr></table></figure></p>
<p>情况二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//情况二：使用&lt;iostream.h&gt;，不引入命名空间 </div><div class="line">  #include  &lt;iostream.h&gt; </div><div class="line">  //using  namespace  std; </div><div class="line">  int  main() </div><div class="line">  &#123; </div><div class="line">      cout&lt;&lt;&quot;&lt;iostream&gt;  need  to  use  namespace  std!\n&quot;; </div><div class="line">      return  0; </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;iostream&gt;  need  to  use  namespace  std! </div><div class="line"> Press  any  key  to  continue</div></pre></td></tr></table></figure></p>
<p>情况三：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//情况三：使用&lt;iostream.h&gt;，引入命名空间，这时候编译出错 </div><div class="line">#include  &lt;iostream.h&gt; </div><div class="line">using  namespace  std; </div><div class="line">int  main() </div><div class="line">&#123; </div><div class="line">   cout&lt;&lt;&quot;&lt;iostream&gt;  need  to  use  namespace  std!\n&quot;; </div><div class="line">   return  0; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  error  C2871:  &apos;std&apos;  :  does  not  exist  or  is  not  a  namespace </div><div class="line">```    　　</div><div class="line"></div><div class="line">　　转自：http://blog.csdn.net/jzjwonderful/article/details/47866773</div><div class="line">　　</div><div class="line"></div><div class="line"></div><div class="line"># 6.C++ 数组</div><div class="line"></div><div class="line"></div><div class="line">C++ 支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</div></pre></td></tr></table></figure>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>#include <iomanip><br>/<em>主要是对cin,cout之类的一些操纵运算子，比如setfill,setw,setbase,setprecision等等。它是I/O流控制头文</em>/</iomanip></p>
<p>using std::setw;    /<em> setw(n) 设域宽为n个字符 </em>/</p>
<p>int main ()<br>{<br>   int n[ 10 ]; // n 是一个包含 10 个整数的数组</p>
<p>   // 初始化数组元素<br>   for ( int i = 0; i &lt; 10; i++ )<br>   {<br>      n[ i ] = i + 100; // 设置元素 i 为 i + 100<br>   }<br>   cout &lt;&lt; “Element” &lt;&lt; setw( 13 ) &lt;&lt; “Value” &lt;&lt; endl;</p>
<p>   // 输出数组中每个元素的值<br>   for ( int j = 0; j &lt; 10; j++ )<br>   {<br>      cout &lt;&lt; setw( 7 )&lt;&lt; j &lt;&lt; setw( 13 ) &lt;&lt; n[ j ] &lt;&lt; endl;<br>   }</p>
<p>   return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出：</div></pre></td></tr></table></figure></p>
<p>正在启动：/home/kuo/projects/test/build/test<br>Element        Value<br>      0          100<br>      1          101<br>      2          102<br>      3          103<br>      4          104<br>      5          105<br>      6          106<br>      7          107<br>      8          108<br>      9          109<br><strong><em> 正常退出 </em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## ６.1 C++ 多维数组</div></pre></td></tr></table></figure></p>
<p>#include <iostream><br>using namespace std;</iostream></p>
<p>int main ()<br>{<br>   // 一个带有 5 行 2 列的数组<br>   int a[5][2] = { {0,0}, {1,2}, {2,4}, {3,6},{4,8}};</p>
<p>   // 输出数组中每个元素的值<br>   for ( int i = 0; i &lt; 5; i++ )<br>      for ( int j = 0; j &lt; 2; j++ )<br>      {<br>         cout &lt;&lt; “a[“ &lt;&lt; i &lt;&lt; “][“ &lt;&lt; j &lt;&lt; “]: “;<br>         cout &lt;&lt; a[i][j]&lt;&lt; endl;<br>      }</p>
<p>   return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">输出：</div><div class="line">```c++</div><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">a[0][0]: 0</div><div class="line">a[0][1]: 0</div><div class="line">a[1][0]: 1</div><div class="line">a[1][1]: 2</div><div class="line">a[2][0]: 2</div><div class="line">a[2][1]: 4</div><div class="line">a[3][0]: 3</div><div class="line">a[3][1]: 6</div><div class="line">a[4][0]: 4</div><div class="line">a[4][1]: 8</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure></p>
<h2 id="6-2-C-指向数组的指针"><a href="#6-2-C-指向数组的指针" class="headerlink" title="6.2 C++ 指向数组的指针"></a>6.2 C++ 指向数组的指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   // 带有 5 个元素的整型数组</div><div class="line">   double balance[5] = &#123;1000.0, 2.0, 3.4, 17.0, 50.0&#125;;</div><div class="line">   double *p;  /*double *[p] 的意思是定义双精度指针变量p */</div><div class="line"></div><div class="line">   p = balance;    /*因为balance既是数组变量，也是指向数组第0个元素的指针变量*/</div><div class="line"> </div><div class="line">   // 输出数组中每个元素的值</div><div class="line">   cout &lt;&lt; &quot;使用指针的数组值 &quot; &lt;&lt; endl; </div><div class="line">   for ( int i = 0; i &lt; 5; i++ )</div><div class="line">   &#123;</div><div class="line">       cout &lt;&lt; &quot;*(p + &quot; &lt;&lt; i &lt;&lt; &quot;) : &quot;;</div><div class="line">       cout &lt;&lt; *(p + i) &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   cout &lt;&lt; &quot;使用 balance 作为地址的数组值 &quot; &lt;&lt; endl;</div><div class="line">   for ( int i = 0; i &lt; 5; i++ )</div><div class="line">   &#123;</div><div class="line">       cout &lt;&lt; &quot;*(balance + &quot; &lt;&lt; i &lt;&lt; &quot;) : &quot;;</div><div class="line">       cout &lt;&lt; *(balance + i) &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">使用指针的数组值 </div><div class="line">*(p + 0) : 1000</div><div class="line">*(p + 1) : 2</div><div class="line">*(p + 2) : 3.4</div><div class="line">*(p + 3) : 17</div><div class="line">*(p + 4) : 50</div><div class="line">使用 balance 作为地址的数组值 </div><div class="line">*(balance + 0) : 1000</div><div class="line">*(balance + 1) : 2</div><div class="line">*(balance + 2) : 3.4</div><div class="line">*(balance + 3) : 17</div><div class="line">*(balance + 4) : 50</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure></p>
<h2 id="6-3-C-传递数组给函数"><a href="#6-3-C-传递数组给函数" class="headerlink" title="6.3 C++ 传递数组给函数"></a>6.3 C++ 传递数组给函数</h2><p>C++ 不允许向函数传递一个完整的数组作为参数，但是，您可以通过指定不带索引的数组名来传递一个指向数组的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 函数声明</div><div class="line">double getAverage(int arr[], int size);</div><div class="line"></div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   // 带有 5 个元素的整型数组</div><div class="line">   int balance[5] = &#123;1000, 2, 3, 17, 50&#125;;</div><div class="line">   double avg;</div><div class="line"></div><div class="line">   // 传递一个指向数组的指针作为参数</div><div class="line">   avg = getAverage( balance, 5 ) ;</div><div class="line"> </div><div class="line">   // 输出返回值</div><div class="line">   cout &lt;&lt; &quot;平均值是：&quot; &lt;&lt; avg &lt;&lt; endl; </div><div class="line">    </div><div class="line">   return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//子函数：应用于求数组的指定元素的平均值；</div><div class="line">double getAverage(int arr[], int size)	//传递数组的首地址和个数</div><div class="line">//还可以以这样的形式：void myFunction(int *param)</div><div class="line">&#123;</div><div class="line">  int    i, sum = 0;       </div><div class="line">  double avg;          </div><div class="line"></div><div class="line">  for (i = 0; i &lt; size; ++i)</div><div class="line">  &#123;</div><div class="line">    sum += arr[i];</div><div class="line">   &#125;</div><div class="line"></div><div class="line">  avg = double(sum) / size;</div><div class="line"></div><div class="line">  return avg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">平均值是：214.4</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure></p>
<h2 id="6-4-C-从函数返回数组"><a href="#6-4-C-从函数返回数组" class="headerlink" title="6.4 C++ 从函数返回数组"></a>6.4 C++ 从函数返回数组</h2><p>C++ 不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。</p>
<p>如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int * myFunction()</div><div class="line">&#123;</div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。</p>
<p>现在，让我们来看下面的函数，它会生成 10 个随机数，并使用数组来返回它们，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;ctime&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">// 要生成和返回随机数的函数</div><div class="line">int * getRandom( )/*如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数*/</div><div class="line">&#123;</div><div class="line">  static int  r[10];/*C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。*/</div><div class="line"> </div><div class="line">  // 设置种子</div><div class="line">  srand( (unsigned)time( NULL ) );</div><div class="line">  for (int i = 0; i &lt; 10; ++i)</div><div class="line">  &#123;</div><div class="line">    r[i] = rand();</div><div class="line">    cout &lt;&lt; r[i] &lt;&lt; endl;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  return r;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 要调用上面定义函数的主函数</div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   // 一个指向整数的指针</div><div class="line">   int *p;</div><div class="line"> </div><div class="line">   p = getRandom();</div><div class="line">   for ( int i = 0; i &lt; 10; i++ )</div><div class="line">   &#123;</div><div class="line">       cout &lt;&lt; &quot;*(p + &quot; &lt;&lt; i &lt;&lt; &quot;) : &quot;;</div><div class="line">       cout &lt;&lt; *(p + i) &lt;&lt; endl;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">1643684660</div><div class="line">555897083</div><div class="line">1283025333</div><div class="line">67400210</div><div class="line">154404676</div><div class="line">2092591326</div><div class="line">1876825200</div><div class="line">1608593253</div><div class="line">1393148894</div><div class="line">621522198</div><div class="line">*(p + 0) : 1643684660</div><div class="line">*(p + 1) : 555897083</div><div class="line">*(p + 2) : 1283025333</div><div class="line">*(p + 3) : 67400210</div><div class="line">*(p + 4) : 154404676</div><div class="line">*(p + 5) : 2092591326</div><div class="line">*(p + 6) : 1876825200</div><div class="line">*(p + 7) : 1608593253</div><div class="line">*(p + 8) : 1393148894</div><div class="line">*(p + 9) : 621522198</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure></p>
<h1 id="7-C-字符串"><a href="#7-C-字符串" class="headerlink" title="7.C++ 字符串"></a>7.C++ 字符串</h1><p>C++ 提供了以下两种类型的字符串表示形式：</p>
<pre><code>C 风格字符串
C++ 引入的 string 类类型
</code></pre><h2 id="7-1-C-风格字符串"><a href="#7-1-C-风格字符串" class="headerlink" title="7.1 C 风格字符串"></a>7.1 C 风格字符串</h2><p>C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line"> </div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">   char str1[11] = &quot;Hello&quot;;</div><div class="line">   char str2[11] = &quot;World&quot;;</div><div class="line">   char str3[11];</div><div class="line">   int  len ;</div><div class="line"> </div><div class="line">   // 复制 str1 到 str3</div><div class="line">   strcpy( str3, str1);</div><div class="line">   cout &lt;&lt; &quot;strcpy( str3, str1) : &quot; &lt;&lt; str3 &lt;&lt; endl;</div><div class="line"> </div><div class="line">   // 连接 str1 和 str2</div><div class="line">   strcat( str1, str2);</div><div class="line">   cout &lt;&lt; &quot;strcat( str1, str2): &quot; &lt;&lt; str1 &lt;&lt; endl;</div><div class="line"> </div><div class="line">   // 连接后，str1 的总长度</div><div class="line">   len = strlen(str1);</div><div class="line">   cout &lt;&lt; &quot;strlen(str1) : &quot; &lt;&lt; len &lt;&lt; endl;</div><div class="line"> </div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">strcpy( str3, str1) : Hello</div><div class="line">strcat( str1, str2): HelloWorld</div><div class="line">strlen(str1) : 10</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure>
<p>其他：<br>|—|—|—|<br>| - - -  |  : - - - : |  - - -  |<br>| 4    | strcmp(s1,s2); |如果 s1 和 s2 是相同的，则返回 0；如果 s1 &lt; s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。 |<br>| 5     | strchr(s1, ch); | 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |<br>|6    | strstr(s1, s2); |返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。|</p>
<h2 id="7-2-C-中的-String-类"><a href="#7-2-C-中的-String-类" class="headerlink" title="7.2 C++ 中的 String 类"></a>7.2 C++ 中的 String 类</h2><p>C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    //定义一个string类对象</div><div class="line">    string http = &quot;www.runoob.com&quot;;</div><div class="line"></div><div class="line">   //打印字符串长度</div><div class="line">   cout&lt;&lt;http.length()&lt;&lt;endl;</div><div class="line"></div><div class="line">    //拼接</div><div class="line">    http.append(&quot;/C++&quot;);</div><div class="line">    cout&lt;&lt;http&lt;&lt;endl; //打印结果为：www.runoob.com/C++</div><div class="line"></div><div class="line">    //删除</div><div class="line">    int pos = http.find(&quot;/C++&quot;); //查找&quot;C++&quot;在字符串中的位置</div><div class="line">    cout&lt;&lt;pos&lt;&lt;endl;</div><div class="line">    http.replace(pos, 4, &quot;&quot;);   //从位置pos开始，之后的4个字符替换为空，即删除</div><div class="line">    cout&lt;&lt;http&lt;&lt;endl;</div><div class="line"></div><div class="line">    //找子串runoob</div><div class="line">    int first = http.find_first_of(&quot;.&quot;); //从头开始寻找字符&apos;.&apos;的位置</div><div class="line">    int last = http.find_last_of(&quot;.&quot;);   //从尾开始寻找字符&apos;.&apos;的位置</div><div class="line">    cout&lt;&lt;http.substr(first+1, last-first-1)&lt;&lt;endl; //提取&quot;runoob&quot;子串并打印</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">正在启动：/home/kuo/projects/test/build/test</div><div class="line">14</div><div class="line">www.runoob.com/C++</div><div class="line">14</div><div class="line">www.runoob.com</div><div class="line">runoob</div><div class="line">*** 正常退出 ***</div></pre></td></tr></table></figure>
<p>转自：<a href="http://www.runoob.com/cplusplus/cpp-strings.html" target="_blank" rel="external">http://www.runoob.com/cplusplus/cpp-strings.html</a></p>
]]></content>
      
        <categories>
            
            <category> c++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[rosb笔记：bug时间：环境变量设置问题——“解决 roscd beginner_tutorials 没有此文件的问题”]]></title>
      <url>/2017/11/13/ros/rosb%E7%AC%94%E8%AE%B0%EF%BC%9Abug%E6%97%B6%E9%97%B4%EF%BC%9A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E2%80%9C%E8%A7%A3%E5%86%B3%20roscd%20beginner_tutorials%20%E6%B2%A1%E6%9C%89%E6%AD%A4%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98%E2%80%9D/</url>
      <content type="html"><![CDATA[<h2 id="bug时间：环境变量设置问题"><a href="#bug时间：环境变量设置问题" class="headerlink" title="bug时间：环境变量设置问题"></a>bug时间：环境变量设置问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">. ~/catkin_ws/devel/setup.bash</div></pre></td></tr></table></figure>
<p>解决 roscd beginner_tutorials 没有此文件的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ roscd beginner_tutorials</div><div class="line">roscd: No such package/stack &apos;beginner_tutorials&apos;</div><div class="line">kuo@kuo-Inspiron-7420:~$ . ~/catkin_ws/devel/setup.bash</div><div class="line">kuo@kuo-Inspiron-7420:~$ roscd beginner_tutorials</div><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/src/beginner_tutorials$</div></pre></td></tr></table></figure></p>
<h1 id="2-解决："><a href="#2-解决：" class="headerlink" title="2.解决："></a>2.解决：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ERROR] [1508416151.165397241]: [registerPublisher] Failed to contact master at [localhost:11311].  Retrying...</div></pre></td></tr></table></figure>
<p>问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">uo@kuo-Inspiron-7420:~$ rosrun beginner_tutorials add_two_ints_server</div><div class="line">[rospack] Error: package &apos;beginner_tutorials&apos; not found</div><div class="line">kuo@kuo-Inspiron-7420:~$ . ~/catkin_ws/devel/setup.bash</div><div class="line">kuo@kuo-Inspiron-7420:~$ rosrun beginner_tutorials add_two_ints_server</div><div class="line">[ERROR] [1508416151.165397241]: [registerPublisher] Failed to contact master at [localhost:11311].  Retrying...</div></pre></td></tr></table></figure></p>
<p>请检查 roscore 是否正常打开。</p>
]]></content>
      
        <categories>
            
            <category> ros </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ros </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ROS笔记：（7）其他]]></title>
      <url>/2017/11/13/ros/ROS%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%887%EF%BC%89%E5%85%B6%E4%BB%96/</url>
      <content type="html"><![CDATA[<h2 id="7-编写简单的消息发布器和订阅器-C"><a href="#7-编写简单的消息发布器和订阅器-C" class="headerlink" title="7.编写简单的消息发布器和订阅器 (C++)"></a>7.<a href="http://wiki.ros.org/cn/ROS/Tutorials/WritingPublisherSubscriber%28c++%29" target="_blank" rel="external">编写简单的消息发布器和订阅器 (C++)</a></h2><p>本教程将介绍如何用 C++ 编写发布器节点和订阅器节点。</p>
<h2 id="8-写一个简单的消息发布器和订阅器-Python"><a href="#8-写一个简单的消息发布器和订阅器-Python" class="headerlink" title="8.写一个简单的消息发布器和订阅器 (Python)"></a>8.<a href="http://wiki.ros.org/cn/ROS/Tutorials/WritingPublisherSubscriber%28python%29" target="_blank" rel="external">写一个简单的消息发布器和订阅器 (Python)</a></h2><p>本教程将通过Python编写一个发布器节点和订阅器节点。</p>
<h2 id="9-测试消息发布器和订阅器"><a href="#9-测试消息发布器和订阅器" class="headerlink" title="9.测试消息发布器和订阅器"></a>9.<a href="http://wiki.ros.org/cn/ROS/Tutorials/ExaminingPublisherSubscriber" target="_blank" rel="external">测试消息发布器和订阅器</a></h2><p>本教程将测试上一教程所写的消息发布器和订阅器。</p>
<h2 id="10-编写简单的服务器和客户端-C"><a href="#10-编写简单的服务器和客户端-C" class="headerlink" title="10.编写简单的服务器和客户端 (C++)"></a>10.<a href="http://wiki.ros.org/cn/ROS/Tutorials/WritingServiceClient%28c++%29" target="_blank" rel="external">编写简单的服务器和客户端 (C++)</a></h2><p>本教程介绍如何用 C++ 编写服务器 Service 和客户端 Client 节点。</p>
<h2 id="11-编写简单的Service和Client-Python"><a href="#11-编写简单的Service和Client-Python" class="headerlink" title="11.编写简单的Service和Client (Python)"></a>11.<a href="http://wiki.ros.org/cn/ROS/Tutorials/WritingServiceClient%28python%29" target="_blank" rel="external">编写简单的Service和Client (Python)</a></h2><p>本教程介绍如何用Python编写Service和Client节点。</p>
<h2 id="12-测试简单的Service和Client"><a href="#12-测试简单的Service和Client" class="headerlink" title="12.测试简单的Service和Client"></a>12.<a href="http://wiki.ros.org/cn/ROS/Tutorials/ExaminingServiceClient" target="_blank" rel="external">测试简单的Service和Client</a></h2><p>本教程将测试之前所写的Service和Client。</p>
<h2 id="13-录制与回放数据"><a href="#13-录制与回放数据" class="headerlink" title="13.录制与回放数据"></a>13.<a href="http://wiki.ros.org/cn/ROS/Tutorials/Recording%20and%20playing%20back%20data" target="_blank" rel="external">录制与回放数据</a></h2><p>本教程将教你如何将ROS系统运行过程中的数据录制到一个.bag文件中，然后通过回放数据来重现相似的运行过程。</p>
<h2 id="14-roswtf入门"><a href="#14-roswtf入门" class="headerlink" title="14.roswtf入门"></a>14.<a href="http://wiki.ros.org/cn/ROS/Tutorials/Getting%20started%20with%20roswtf" target="_blank" rel="external">roswtf入门</a></h2><p>本教程介绍了roswtf工具的基本使用方法。</p>
<h2 id="15-探索ROS维基"><a href="#15-探索ROS维基" class="headerlink" title="15.探索ROS维基"></a>15.<a href="http://wiki.ros.org/cn/ROS/Tutorials/NavigatingTheWiki" target="_blank" rel="external">探索ROS维基</a></h2><p>本教程介绍了ROS维基(wiki.ros.org)的组织结构以及使用方法。同时讲解了如何才能从ROS维基中找到你需要的信息。</p>
<h2 id="16-接下来做什么？"><a href="#16-接下来做什么？" class="headerlink" title="16.接下来做什么？"></a>16.<a href="http://wiki.ros.org/cn/ROS/Tutorials/WhereNext" target="_blank" rel="external">接下来做什么？</a></h2><p>本教程将讨论获取更多知识的途径，以帮助你更好地使用ROS搭建真实或虚拟机器人。 </p>
]]></content>
      
        <categories>
            
            <category> ros </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ros </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ros笔记：（6）使用rosed编辑ROS中的文件]]></title>
      <url>/2017/11/13/ros/ros%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%886%EF%BC%89%E4%BD%BF%E7%94%A8rosed%E7%BC%96%E8%BE%91ROS%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>Description: 本教程将展示如何使用rosed来简化编辑过程。</p>
<h2 id="使用-rosed"><a href="#使用-rosed" class="headerlink" title="使用 rosed"></a>使用 rosed</h2><p>rosed 是 rosbash 的一部分。利用它可以直接通过package名来获取到待编辑的文件而无需指定该文件的存储路径了。</p>
<p>使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosed [package_name] [filename]</div></pre></td></tr></table></figure></p>
<p>例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosed roscpp Logger.msg</div></pre></td></tr></table></figure></p>
<p>这个实例展示了如何编辑roscpp package里的Logger.msg文件。</p>
<p>如果该实例没有运行成功，那么很有可能是你没有安装vim编辑器。请参考编辑器部分进行设置。</p>
<p>如果文件名在package里不是唯一的，那么会呈现出一个列表，让你选择编辑哪一个文件。</p>
<h2 id="使用Tab键补全文件名"><a href="#使用Tab键补全文件名" class="headerlink" title="使用Tab键补全文件名"></a>使用Tab键补全文件名</h2><p>使用这个方法，在不知道准确文件名的情况下，你也可以看到并选择你所要编辑的文件。</p>
<p>使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosed [package_name] &lt;tab&gt;</div></pre></td></tr></table></figure></p>
<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p>rosed默认的编辑器是vim。如果想要将其他的编辑器设置成默认的，你需要修改你的 ~/.bashrc 文件，增加如下语句:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export EDITOR=&apos;gedit&apos;</div></pre></td></tr></table></figure></p>
<p>这将gedit设置成为默认编辑器。</p>
<p>注意: .bashrc文件的改变，只会在新的终端才有效。已经打开的终端不受环境变量的影响。</p>
<p>打开一个新的终端，看看那是否定义了EDITOR:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ echo $EDITOR</div><div class="line"></div><div class="line">    emacs -nw</div></pre></td></tr></table></figure></p>
<p>现在你已经成功设置并使用了rosed，接下来我们将学习创建ROS消息和ROS服务. </p>
<p>转自：<a href="http://wiki.ros.org/cn/ROS/Tutorials/UsingRosEd#Editor" target="_blank" rel="external">http://wiki.ros.org/cn/ROS/Tutorials/UsingRosEd#Editor</a></p>
]]></content>
      
        <categories>
            
            <category> ros </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ros </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ros笔记：（5）使用 rqt_console 和 roslaunch]]></title>
      <url>/2017/11/13/ros/ros%E7%AC%94%E8%AE%B0%EF%BC%9A%EF%BC%885%EF%BC%89%E4%BD%BF%E7%94%A8%20rqt_console%20%E5%92%8C%20roslaunch/</url>
      <content type="html"><![CDATA[<p>Description: 本教程介绍如何使用rqt_console和rqt_logger_level进行调试，以及如何使用roslaunch同时运行多个节点。</p>
<h2 id="预先安装rqt和turtlesim程序包"><a href="#预先安装rqt和turtlesim程序包" class="headerlink" title="预先安装rqt和turtlesim程序包"></a>预先安装rqt和turtlesim程序包</h2><p>本教程会用到rqt 和 turtlesim这两个程序包，如果你没有安装，请先安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install ros-&lt;distro&gt;-rqt ros-&lt;distro&gt;-rqt-common-plugins ros-&lt;distro&gt;-turtlesim</div></pre></td></tr></table></figure></p>
<p>请使用ROS发行版名称(比如 electric、fuerte、groovy、hydro或最新的indigo)替换掉<distro>。</distro></p>
<p>注意： 你可能已经在之前的某篇教程中编译过rqt和turtlesim，如果你不确定的话重新编译一次也没事。</p>
<h2 id="使用rqt-console和rqt-logger-level"><a href="#使用rqt-console和rqt-logger-level" class="headerlink" title="使用rqt_console和rqt_logger_level"></a>使用rqt_console和rqt_logger_level</h2><p>rqt_console属于ROS日志框架(logging framework)的一部分，用来显示节点的输出信息。rqt_logger_level允许我们修改节点运行时输出信息的日志等级（logger levels）（包括 DEBUG、WARN、INFO和ERROR）。</p>
<p>现在让我们来看一下turtlesim在rqt_console中的输出信息，同时在rqt_logger_level中修改日志等级。在启动turtlesim之前先在另外两个新终端中运行rqt_console和rqt_logger_level：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun rqt_console rqt_console</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun rqt_logger_level rqt_logger_level</div></pre></td></tr></table></figure>
<p>你会看到弹出两个窗口：</p>
<p><img src="http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch?action=AttachFile&amp;do=get&amp;target=rqt_console%28start%29.png" alt="这里写图片描述"></p>
<p><img src="http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch?action=AttachFile&amp;do=get&amp;target=rqt_logger_level.png" alt="这里写图片描述"></p>
<p>现在让我们在一个新终端中启动turtlesim：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun turtlesim turtlesim_node</div></pre></td></tr></table></figure></p>
<p>因为默认日志等级是INFO，所以你会看到turtlesim启动后输出的所有信息，如下图所示：</p>
<p><img src="http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch?action=AttachFile&amp;do=get&amp;target=rqt_console%28turtlesimstart%29.png" alt="这里写图片描述"></p>
<p>现在让我们刷新一下rqt_logger_level窗口并选择Warn将日志等级修改为WARN，如下图所示：</p>
<p><img src="http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch?action=AttachFile&amp;do=get&amp;target=rqt_logger_level%28error%29.png" alt="这里写图片描述"></p>
<p>现在我们让turtle动起来并观察rqt_console中的输出<br>hydro版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- &apos;[2.0, 0.0, 0.0]&apos; &apos;[0.0, 0.0, 0.0]&apos;</div></pre></td></tr></table></figure></p>
<p><img src="http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch?action=AttachFile&amp;do=get&amp;target=rqt_console%28turtlesimerror%29.png" alt="这里写图片描述"></p>
<h3 id="日志等级说明"><a href="#日志等级说明" class="headerlink" title="日志等级说明"></a>日志等级说明</h3><p>日志等级按以下优先顺序排列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Fatal</div><div class="line">Error</div><div class="line">Warn</div><div class="line">Info</div><div class="line">Debug</div></pre></td></tr></table></figure></p>
<p>Fatal是最高优先级，Debug是最低优先级。通过设置日志等级你可以获取该等级及其以上优先等级的所有日志消息。比如，将日志等级设为Warn时，你会得到Warn、Error和Fatal这三个等级的所有日志消息。</p>
<p>现在让我们按Ctrl-C退出turtlesim节点，接下来我们将使用roslaunch来启动多个turtlesim节点和一个模仿节点以让一个turtlesim节点来模仿另一个turtlesim节点。</p>
<h3 id="使用roslaunch"><a href="#使用roslaunch" class="headerlink" title="使用roslaunch"></a>使用roslaunch</h3><p>roslaunch可以用来启动定义在launch文件中的多个节点。</p>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ roslaunch [package] [filename.launch]</div></pre></td></tr></table></figure></p>
<p>先切换到beginner_tutorials程序包目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ roscd beginner_tutorials</div></pre></td></tr></table></figure></p>
<p>如果roscd执行失败了，记得设置你当前终端下的ROS_PACKAGE_PATH环境变量，设置方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ export ROS_PACKAGE_PATH=~/&lt;distro&gt;_workspace/sandbox:$ROS_PACKAGE_PATH</div><div class="line">$ roscd beginner_tutorials</div></pre></td></tr></table></figure></p>
<p>如果你仍然无法找到beginner_tutorials程序包，说明该程序包还没有创建，那么请返回到ROS/Tutorials/CreatingPackage教程，并按照创建程序包的操作方法创建一个beginner_tutorials程序包。</p>
<p>然后创建一个launch文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir launch</div><div class="line">$ cd launch</div></pre></td></tr></table></figure></p>
<h3 id="Launch-文件"><a href="#Launch-文件" class="headerlink" title="Launch 文件"></a>Launch 文件</h3><p>现在我们来创建一个名为turtlemimic.launch的launch文件并复制粘贴以下内容到该文件里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;launch&gt;</div><div class="line"></div><div class="line">  &lt;group ns=&quot;turtlesim1&quot;&gt;</div><div class="line">    &lt;node pkg=&quot;turtlesim&quot; name=&quot;sim&quot; type=&quot;turtlesim_node&quot;/&gt;</div><div class="line">  &lt;/group&gt;</div><div class="line"></div><div class="line">  &lt;group ns=&quot;turtlesim2&quot;&gt;</div><div class="line">    &lt;node pkg=&quot;turtlesim&quot; name=&quot;sim&quot; type=&quot;turtlesim_node&quot;/&gt;</div><div class="line">  &lt;/group&gt;</div><div class="line"></div><div class="line">  &lt;node pkg=&quot;turtlesim&quot; name=&quot;mimic&quot; type=&quot;mimic&quot;&gt;</div><div class="line">    &lt;remap from=&quot;input&quot; to=&quot;turtlesim1/turtle1&quot;/&gt;</div><div class="line">    &lt;remap from=&quot;output&quot; to=&quot;turtlesim2/turtle1&quot;/&gt;</div><div class="line">  &lt;/node&gt;</div><div class="line"></div><div class="line">&lt;/launch&gt;</div></pre></td></tr></table></figure>
<h3 id="Launch-文件解析"><a href="#Launch-文件解析" class="headerlink" title="Launch 文件解析"></a>Launch 文件解析</h3><p>现在我们开始逐句解析launch xml文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;launch&gt;</div></pre></td></tr></table></figure>
<p>在这里我们以launch标签开头以表明这是一个launch文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3   &lt;group ns=&quot;turtlesim1&quot;&gt;</div><div class="line">4     &lt;node pkg=&quot;turtlesim&quot; name=&quot;sim&quot; type=&quot;turtlesim_node&quot;/&gt;</div><div class="line">5   &lt;/group&gt;</div><div class="line">6 </div><div class="line">7   &lt;group ns=&quot;turtlesim2&quot;&gt;</div><div class="line">8     &lt;node pkg=&quot;turtlesim&quot; name=&quot;sim&quot; type=&quot;turtlesim_node&quot;/&gt;</div><div class="line">9   &lt;/group&gt;</div></pre></td></tr></table></figure>
<p>在这里我们创建了两个节点分组并以’命名空间（namespace)’标签来区分，其中一个名为turtulesim1，另一个名为turtlesim2，两个组里面都使用相同的turtlesim节点并命名为’sim’。这样可以让我们同时启动两个turtlesim模拟器而不会产生命名冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">11   &lt;node pkg=&quot;turtlesim&quot; name=&quot;mimic&quot; type=&quot;mimic&quot;&gt;</div><div class="line">12     &lt;remap from=&quot;input&quot; to=&quot;turtlesim1/turtle1&quot;/&gt;</div><div class="line">13     &lt;remap from=&quot;output&quot; to=&quot;turtlesim2/turtle1&quot;/&gt;</div><div class="line">14   &lt;/node&gt;</div></pre></td></tr></table></figure>
<p>在这里我们启动模仿节点，并将所有话题的输入和输出分别重命名为turtlesim1和turtlesim2，这样就会使turtlesim2模仿turtlesim1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">16 &lt;/launch&gt;</div></pre></td></tr></table></figure>
<p>这个是launch文件的结束标签。</p>
<h3 id="roslaunching"><a href="#roslaunching" class="headerlink" title="roslaunching"></a>roslaunching</h3><p>现在让我们通过roslaunch命令来启动launch文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ roslaunch beginner_tutorials turtlemimic.launch</div></pre></td></tr></table></figure></p>
<p>现在将会有两个turtlesims被启动，然后我们在一个新终端中使用rostopic命令发送速度设定消息：</p>
<p>hydro版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic pub /turtlesim1/turtle1/cmd_vel geometry_msgs/Twist -r 1 -- &apos;[2.0, 0.0, 0.0]&apos; &apos;[0.0, 0.0, -1.8]&apos;</div></pre></td></tr></table></figure></p>
<p>你会看到两个turtlesims会同时开始移动，虽然发布命令只是给turtlesim1发送了速度设定消息。</p>
<p><img src="http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch?action=AttachFile&amp;do=get&amp;target=mimic.png" alt="这里写图片描述"></p>
<p>我们也可以通过rqt_graph来更好的理解在launch文件中所做的事情。运行rqt并在主窗口中选择rqt_graph：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rqt</div></pre></td></tr></table></figure></p>
<p>或者直接运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rqt_graph</div></pre></td></tr></table></figure></p>
<p><img src="http://wiki.ros.org/ROS/Tutorials/UsingRqtconsoleRoslaunch?action=AttachFile&amp;do=get&amp;target=mimiclaunch.jpg" alt="这里写图片描述"></p>
<p>到此，我们算是已经学会了rqt_console和roslaunch命令的使用，接下来我们开始学习使用rosed——ROS中的编辑器。现在你可以按Ctrl-C退出所有turtlesims节点了，因为在下一篇教程中你不会再用到它们。 </p>
<p>转自：<a href="http://wiki.ros.org/cn/ROS/Tutorials/UsingRqtconsoleRoslaunch" target="_blank" rel="external">http://wiki.ros.org/cn/ROS/Tutorials/UsingRqtconsoleRoslaunch</a></p>
]]></content>
      
        <categories>
            
            <category> ros </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ros </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ros：（4）理解ROS服务和参数]]></title>
      <url>/2017/11/13/ros/ros%EF%BC%9A%EF%BC%884%EF%BC%89%E7%90%86%E8%A7%A3ROS%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%8F%82%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>Description: 本教程介绍了ROS 服务和参数的知识，以及命令行工具rosservice 和 rosparam的使用方法。</p>
<p>本教程假设从前一教程启动的turtlesim_node仍在运行，现在我们来看看turtlesim提供了什么服务：</p>
<h2 id="ROS-Services"><a href="#ROS-Services" class="headerlink" title="ROS Services"></a>ROS Services</h2><p>服务（services）是节点之间通讯的另一种方式。服务允许节点发送请求（request） 并获得一个响应（response）</p>
<h2 id="使用rosservice"><a href="#使用rosservice" class="headerlink" title="使用rosservice"></a>使用rosservice</h2><p>rosservice可以很轻松的使用 ROS 客户端/服务器框架提供的服务。rosservice提供了很多可以在topic上使用的命令，如下所示：</p>
<p>使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">rosservice list         输出可用服务的信息</div><div class="line">rosservice call         调用带参数的服务</div><div class="line">rosservice type         输出服务类型</div><div class="line">rosservice find         依据类型寻找服务find services by service type</div><div class="line">rosservice uri          输出服务的ROSRPC uri</div></pre></td></tr></table></figure></p>
<h3 id="rosservice-list"><a href="#rosservice-list" class="headerlink" title="rosservice list"></a>rosservice list</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosservice list</div></pre></td></tr></table></figure>
<p>list 命令显示turtlesim节点提供了9个服务：重置（reset）, 清除（clear）, 再生（spawn）, 终止（kill）, turtle1/set_pen, /turtle1/teleport_absolute, /turtle1/teleport_relative, turtlesim/get_loggers, and turtlesim/set_logger_level. 同时还有另外两个rosout节点提供的服务: /rosout/get_loggers and /rosout/set_logger_level.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/clear</div><div class="line">/kill</div><div class="line">/reset</div><div class="line">/rosout/get_loggers</div><div class="line">/rosout/set_logger_level</div><div class="line">/spawn</div><div class="line">/teleop_turtle/get_loggers</div><div class="line">/teleop_turtle/set_logger_level</div><div class="line">/turtle1/set_pen</div><div class="line">/turtle1/teleport_absolute</div><div class="line">/turtle1/teleport_relative</div><div class="line">/turtlesim/get_loggers</div><div class="line">/turtlesim/set_logger_level</div></pre></td></tr></table></figure></p>
<p>我们使用rosservice type命令更进一步查看clear服务:</p>
<h3 id="rosservice-type"><a href="#rosservice-type" class="headerlink" title="rosservice type"></a>rosservice type</h3><p>使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rosservice type [service]</div></pre></td></tr></table></figure></p>
<p>我们来看看clear服务的类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rosservice type clear</div><div class="line"></div><div class="line">std_srvs/Empty</div></pre></td></tr></table></figure></p>
<p>服务的类型为空（empty),这表明在调用这个服务是不需要参数（比如，请求不需要发送数据，响应也没有数据）。下面我们使用rosservice call命令调用服务：</p>
<h3 id="rosservice-call"><a href="#rosservice-call" class="headerlink" title="rosservice call"></a>rosservice call</h3><p>使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rosservice call [service] [args]</div></pre></td></tr></table></figure></p>
<p>因为服务类型是空，所以进行无参数调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosservice call clear</div></pre></td></tr></table></figure></p>
<p>正如我们所期待的，服务清除了turtlesim_node的背景上的轨迹。</p>
<p><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingServicesParams?action=AttachFile&amp;do=get&amp;target=turtlesim.png" alt="这里写图片描述"></p>
<p>通过查看再生（spawn）服务的信息，我们来了解带参数的服务:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ rosservice type spawn| rossrv show</div><div class="line"></div><div class="line">    float32 x</div><div class="line">    float32 y</div><div class="line">    float32 theta</div><div class="line">    string name</div><div class="line">    ---</div><div class="line">    string name</div></pre></td></tr></table></figure></p>
<p>这个服务使得我们可以在给定的位置和角度生成一只新的乌龟。名字参数是可选的，这里我们不设具体的名字，让turtlesim自动创建一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosservice call spawn 2 2 0.2 &quot;&quot;</div></pre></td></tr></table></figure></p>
<p>服务返回了新产生的乌龟的名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name: turtle2</div></pre></td></tr></table></figure></p>
<p>现在我们的乌龟看起来应该是像这样的：</p>
<p><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingServicesParams?action=AttachFile&amp;do=get&amp;target=turtle%28service%29.png" alt="这里写图片描述"></p>
<h2 id="Using-rosparam"><a href="#Using-rosparam" class="headerlink" title="Using rosparam"></a>Using rosparam</h2><p>rosparam使得我们能够存储并操作ROS 参数服务器（Parameter Server）上的数据。参数服务器能够存储整型、浮点、布尔、字符串、字典和列表等数据类型。rosparam使用YAML标记语言的语法。一般而言，YAML的表述很自然：1 是整型, 1.0 是浮点型, one是字符串, true是布尔, [1, 2, 3]是整型列表, {a: b, c: d}是字典. rosparam有很多指令可以用来操作参数，如下所示:</p>
<p>使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">rosparam set            设置参数</div><div class="line">rosparam get            获取参数</div><div class="line">rosparam load           从文件读取参数</div><div class="line">rosparam dump           向文件中写入参数</div><div class="line">rosparam delete         删除参数</div><div class="line">rosparam list           列出参数名</div></pre></td></tr></table></figure></p>
<p>我们来看看现在参数服务器上都有哪些参数：</p>
<h3 id="rosparam-list"><a href="#rosparam-list" class="headerlink" title="rosparam list"></a>rosparam list</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosparam list</div></pre></td></tr></table></figure>
<p>我们可以看到turtlesim节点在参数服务器上有3个参数用于设定背景颜色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/background_b</div><div class="line">/background_g</div><div class="line">/background_r</div><div class="line">/roslaunch/uris/aqy:51932</div><div class="line">/run_id</div></pre></td></tr></table></figure></p>
<p>Let’s change one of the parameter values using rosparam set:</p>
<h3 id="rosparam-set-and-rosparam-get"><a href="#rosparam-set-and-rosparam-get" class="headerlink" title="rosparam set and rosparam get"></a>rosparam set and rosparam get</h3><p>Usage:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rosparam set [param_name]</div><div class="line">rosparam get [param_name]</div></pre></td></tr></table></figure></p>
<p>现在我们修改背景颜色的红色通道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosparam set background_r 150</div></pre></td></tr></table></figure></p>
<p>上述指令修改了参数的值，现在我们调用清除服务使得修改后的参数生效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosservice call clear</div></pre></td></tr></table></figure></p>
<p>现在 我们的小乌龟看起来应该是像这样：</p>
<p><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingServicesParams?action=AttachFile&amp;do=get&amp;target=turtle%28param%29.png" alt="这里写图片描述"></p>
<p>现在我们来查看参数服务器上的参数值——获取背景的绿色通道的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ rosparam get background_g </div><div class="line"></div><div class="line">    86</div></pre></td></tr></table></figure></p>
<p>我们可以使用rosparam get /来显示参数服务器上的所有内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ rosparam get /</div><div class="line"></div><div class="line">    background_b: 255</div><div class="line">    background_g: 86</div><div class="line">    background_r: 150</div><div class="line">    roslaunch:</div><div class="line">      uris: &#123;&apos;aqy:51932&apos;: &apos;http://aqy:51932/&apos;&#125;</div><div class="line">    run_id: e07ea71e-98df-11de-8875-001b21201aa8</div></pre></td></tr></table></figure></p>
<p>你可能希望存储这些信息以备今后重新读取。这通过rosparam很容易就可以实现:</p>
<h3 id="rosparam-dump-and-rosparam-load"><a href="#rosparam-dump-and-rosparam-load" class="headerlink" title="rosparam dump and rosparam load"></a>rosparam dump and rosparam load</h3><p>使用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rosparam dump [file_name]</div><div class="line">rosparam load [file_name] [namespace]</div></pre></td></tr></table></figure></p>
<p>现在我们将所有的参数写入params.yaml文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosparam dump params.yaml</div></pre></td></tr></table></figure></p>
<p>你甚至可以将yaml文件重载入新的命名空间，比如说copy空间:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ rosparam load params.yaml copy</div><div class="line">$ rosparam get copy/background_b</div><div class="line"></div><div class="line">    255</div></pre></td></tr></table></figure></p>
<p>至此，我们已经了解了ROS服务和参数服务器的使用，接下来，我们一同试试使用 rqt_console 和 roslaunch</p>
<p>转自：<a href="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingServicesParams" target="_blank" rel="external">http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingServicesParams</a></p>
]]></content>
      
        <categories>
            
            <category> ros </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ros </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ros：（3）ROS话题_『ROS Topics』『rqt_graph』『ROS Messages』『rqt_plot』]]></title>
      <url>/2017/11/13/ros/ros%EF%BC%9A%EF%BC%883%EF%BC%89ROS%E8%AF%9D%E9%A2%98_%E3%80%8EROS%20Topics%E3%80%8F%E3%80%8Erqt_graph%E3%80%8F%E3%80%8EROS%20Messages%E3%80%8F%E3%80%8Erqt_plot%E3%80%8F/</url>
      <content type="html"><![CDATA[<h1 id="1-开始"><a href="#1-开始" class="headerlink" title="1.开始"></a>1.开始</h1><h2 id="1-1-roscore"><a href="#1-1-roscore" class="headerlink" title="1.1 roscore"></a>1.1 roscore</h2><p>首先确保roscore已经运行, 打开一个新的终端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ roscore</div></pre></td></tr></table></figure></p>
<h2 id="1-2turtlesim"><a href="#1-2turtlesim" class="headerlink" title="1.2turtlesim"></a>1.2turtlesim</h2><p>在本教程中我们也会使用到turtlesim，请在一个新的终端中运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun turtlesim turtlesim_node</div></pre></td></tr></table></figure></p>
<h2 id="1-3通过键盘远程控制turtle"><a href="#1-3通过键盘远程控制turtle" class="headerlink" title="1.3通过键盘远程控制turtle"></a>1.3通过键盘远程控制turtle</h2><p>我们也需要通过键盘来控制turtle的运动，请在一个新的终端中运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun turtlesim turtle_teleop_key</div></pre></td></tr></table></figure></p>
<h2 id="1-4使用-rqt-graph"><a href="#1-4使用-rqt-graph" class="headerlink" title="1.4使用 rqt_graph"></a>1.4使用 rqt_graph</h2><p>rqt_graph能够创建一个显示当前系统运行情况的动态图形。rqt_graph是rqt程序包中的一部分。如果你没有安装，请通过以下命令来安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install ros-indigo-rqt</div><div class="line">$ sudo apt-get install ros-indigo-rqt-common-plugins</div></pre></td></tr></table></figure></p>
<p>在一个新终端中运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun rqt_graph rqt_graph</div></pre></td></tr></table></figure></p>
<p>就会弹出<code>rqt_graph</code>窗口</p>
<p><img src="http://img.blog.csdn.net/20170927222157598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="2-『ROS-Topics』"><a href="#2-『ROS-Topics』" class="headerlink" title="2.『ROS Topics』"></a>2.『ROS Topics』</h1><p>如上图所示：<br>turtlesim_node节点和turtle_teleop_key节点之间是通过一个ROS话题来互相通信的。turtle_teleop_key在一个话题上发布按键输入消息，而turtlesim（这里是my_turtle）则订阅该话题以接收该消息。</p>
<h2 id="2-1-rostopic介绍"><a href="#2-1-rostopic介绍" class="headerlink" title="2.1.rostopic介绍"></a>2.1.rostopic介绍</h2><p>rostopic命令工具能让你获取有关ROS话题的信息。 </p>
<h3 id="2-1-1你可以使用帮助选项查看rostopic的子命令："><a href="#2-1-1你可以使用帮助选项查看rostopic的子命令：" class="headerlink" title="2.1.1你可以使用帮助选项查看rostopic的子命令："></a>2.1.1你可以使用帮助选项查看rostopic的子命令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic -h</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">rostopic bw     display bandwidth used by topic</div><div class="line">rostopic echo   print messages to screen</div><div class="line">rostopic hz     display publishing rate of topic</div><div class="line">rostopic list   print information about active topics</div><div class="line">rostopic pub    publish data to topic</div><div class="line">rostopic type   print topic type</div></pre></td></tr></table></figure>
<h3 id="2-1-2rostopic-echo可以显示在某个话题上发布的数据"><a href="#2-1-2rostopic-echo可以显示在某个话题上发布的数据" class="headerlink" title="2.1.2rostopic echo可以显示在某个话题上发布的数据"></a>2.1.2rostopic echo可以显示在某个话题上发布的数据</h3><p>让我们在一个新终端中看一下turtle_teleop_key节点在 /turtle1/cmd_vel话题上发布的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$rostopic echo /turtle1/cmd_vel</div></pre></td></tr></table></figure></p>
<p>你可能看不到任何东西因为现在还没有数据发布到该话题上。接下来我们通过按下方向键使turtle_teleop_key节点发布数据。记住如果turtle没有动起来的话就需要你重新选中turtle_teleop_key节点运行时所在的终端窗口。</p>
<p>现在当你按下向上方向键时应该会看到下面的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">linear: </div><div class="line">  x: 2.0</div><div class="line">  y: 0.0</div><div class="line">  z: 0.0</div><div class="line">angular: </div><div class="line">  x: 0.0</div><div class="line">  y: 0.0</div><div class="line">  z: 0.0</div><div class="line">---</div><div class="line">linear: </div><div class="line">  x: 0.0</div><div class="line">  y: 0.0</div><div class="line">  z: 0.0</div><div class="line">angular: </div><div class="line">  x: 0.0</div><div class="line">  y: 0.0</div><div class="line">  z: 2.0</div><div class="line">---</div><div class="line">linear: </div><div class="line">  x: 0.0</div><div class="line">  y: 0.0</div><div class="line">  z: 0.0</div><div class="line">angular: </div><div class="line">  x: 0.0</div><div class="line">  y: 0.0</div><div class="line">  z: -2.0</div><div class="line">---</div></pre></td></tr></table></figure></p>
<p>现在让我们再看一下rqt_graph（你可能需要刷新一下ROS graph）。正如你所看到的，rostopic echo(红色显示部分）现在也订阅了turtle1/command_velocity话题。 </p>
<p><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics?action=AttachFile&amp;do=get&amp;target=rqt_graph_echo.png" alt="这里写图片描述"></p>
<h2 id="2-1-3使用-rostopic-list"><a href="#2-1-3使用-rostopic-list" class="headerlink" title="2.1.3使用 rostopic list"></a>2.1.3使用 rostopic list</h2><p>rostopic list能够列出所有当前订阅和发布的话题。</p>
<p>让我们查看一下list子命令需要的参数，在一个新终端中运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ rostopic list -h</div><div class="line"></div><div class="line">    Usage: rostopic list [/topic]</div><div class="line"></div><div class="line">    Options:</div><div class="line">      -h, --help            show this help message and exit</div><div class="line">      -b BAGFILE, --bag=BAGFILE</div><div class="line">                            list topics in .bag file</div><div class="line">      -v, --verbose         list full details about each topic</div><div class="line">      -p                    list only publishers</div><div class="line">      -s                    list only subscribers</div></pre></td></tr></table></figure></p>
<p>在rostopic list中使用verbose选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic list -v</div></pre></td></tr></table></figure></p>
<p>这会显示出有关所发布和订阅的话题及其类型的详细信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Published topics:</div><div class="line"> * /turtle1/color_sensor [turtlesim/Color] 1 publisher</div><div class="line"> * /turtle1/command_velocity [turtlesim/Velocity] 1 publisher</div><div class="line"> * /rosout [roslib/Log] 2 publishers</div><div class="line"> * /rosout_agg [roslib/Log] 1 publisher</div><div class="line"> * /turtle1/pose [turtlesim/Pose] 1 publisher</div><div class="line"></div><div class="line">Subscribed topics:</div><div class="line"> * /turtle1/command_velocity [turtlesim/Velocity] 1 subscriber</div><div class="line"> * /rosout [roslib/Log] 1 subscriber</div></pre></td></tr></table></figure></p>
<h1 id="3-ROS-Messages"><a href="#3-ROS-Messages" class="headerlink" title="3.ROS Messages"></a>3.ROS Messages</h1><p>话题之间的通信是通过在节点之间发送ROS消息实现的。对于发布器(turtle_teleop_key)和订阅器(turtulesim_node)之间的通信，发布器和订阅器之间必须发送和接收相同类型的消息。这意味着话题的类型是由发布在它上面的消息类型决定的。使用rostopic type命令可以查看发布在某个话题上的消息类型。</p>
<h2 id="3-1使用-rostopic-type"><a href="#3-1使用-rostopic-type" class="headerlink" title="3.1使用 rostopic type"></a>3.1使用 rostopic type</h2><p>rostopic type 命令用来查看所发布话题的消息类型。</p>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rostopic type [topic]</div></pre></td></tr></table></figure></p>
<p>hydro版请运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic type /turtle1/cmd_vel</div></pre></td></tr></table></figure></p>
<pre><code>你应该会看到:
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">geometry_msgs/Twist</div></pre></td></tr></table></figure>
<p>我们可以使用rosmsg命令来查看消息的详细情况：</p>
<p>hydro版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosmsg show geometry_msgs/Twist</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">geometry_msgs/Vector3 linear</div><div class="line">  float64 x</div><div class="line">  float64 y</div><div class="line">  float64 z</div><div class="line">geometry_msgs/Vector3 angular</div><div class="line">  float64 x</div><div class="line">  float64 y</div><div class="line">  float64 z</div></pre></td></tr></table></figure>
<p>现在我们已经知道了turtlesim节点所期望的消息类型，接下来我们就可以给turtle发布命令了。</p>
<h1 id="4-继续学习-rostopic"><a href="#4-继续学习-rostopic" class="headerlink" title="4.继续学习 rostopic"></a>4.继续学习 rostopic</h1><p>现在我们已经了解了什么是ROS的消息，接下来我们开始结合消息来使用rostopic。</p>
<h2 id="4-1使用-rostopic-pub"><a href="#4-1使用-rostopic-pub" class="headerlink" title="4.1使用 rostopic pub"></a>4.1使用 rostopic pub</h2><p>rostopic pub可以把数据发布到当前某个正在广播的话题上。</p>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rostopic pub [topic] [msg_type] [args]</div></pre></td></tr></table></figure></p>
<p>示例（hydro版)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- &apos;[2.0, 0.0, 0.0]&apos; &apos;[0.0, 0.0, 1.8]&apos;</div></pre></td></tr></table></figure></p>
<p>以上命令会发送一条消息给turtlesim，告诉它以2.0大小的线速度和1.8大小的角速度开始移动。<br><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics?action=AttachFile&amp;do=get&amp;target=turtle%28rostopicpub%29.png" alt="这里写图片描述"><br>这是一个非常复杂的例子，因此让我们来详细分析一下其中的每一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rostopic pub</div></pre></td></tr></table></figure></p>
<pre><code>这条命令将会发布消息到某个给定的话题。 
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-1</div></pre></td></tr></table></figure>
<pre><code>（单个破折号）这个参数选项使rostopic发布一条消息后马上退出。 
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/turtle1/command_velocity</div></pre></td></tr></table></figure>
<pre><code>这是消息所发布到的话题名称。 
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">turtlesim/Velocity</div></pre></td></tr></table></figure>
<pre><code>这是所发布消息的类型。 
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--</div></pre></td></tr></table></figure>
<pre><code>（双破折号）这会告诉命令选项解析器接下来的参数部分都不是命令选项。这在参数里面包含有破折号-（比如负号）时是必须要添加的。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.0 1.8</div></pre></td></tr></table></figure>
<pre><code>正如之前提到的，在一个turtlesim/Velocity消息里面包含有两个浮点型元素：linear和angular。在本例中，2.0是linear的值，1.8是angular的值。这些参数其实是按照YAML语法格式编写的，这在YAML文档中有更多的描述。 
</code></pre><p>你可能已经注意到turtle已经停止移动了。这是因为turtle需要一个稳定的频率为1Hz的命令流来保持移动状态。我们可以使用rostopic pub -r命令来发布一个稳定的命令流（非hydro版）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic pub /turtle1/command_velocity turtlesim/Velocity -r 1 -- 2.0  -1.8</div></pre></td></tr></table></figure></p>
<p>hydro版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- &apos;[2.0, 0.0, 0.0]&apos; &apos;[0.0, 0.0, 1.8]&apos;</div></pre></td></tr></table></figure></p>
<p>这条命令以1Hz的频率发布速度命令到速度话题上。</p>
<p>  <img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics?action=AttachFile&amp;do=get&amp;target=turtle%28rostopicpub%292.png" alt="这里写图片描述"></p>
<p>我们也可以看一下rqt_graph中的情形，可以看到rostopic发布器节点（红色）正在与rostopic echo节点（绿色）进行通信：</p>
<p><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics?action=AttachFile&amp;do=get&amp;target=rqt_graph_pub.png" alt="这里写图片描述"></p>
<p>正如你所看到的，turtle正沿着一个圆形轨迹连续运动。我们可以在一个新终端中通过rostopic echo命令来查看turtlesim所发布的数据。</p>
<h2 id="4-2使用-rostopic-hz"><a href="#4-2使用-rostopic-hz" class="headerlink" title="4.2使用 rostopic hz"></a>4.2使用 rostopic hz</h2><p>rostopic hz命令可以用来查看数据发布的频率。</p>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rostopic hz [topic]</div></pre></td></tr></table></figure></p>
<p>我们看一下turtlesim_node发布/turtle/pose时有多快：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic hz /turtle1/pose</div></pre></td></tr></table></figure></p>
<p>你会看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">subscribed to [/turtle1/pose]</div><div class="line">average rate: 59.354</div><div class="line">        min: 0.005s max: 0.027s std dev: 0.00284s window: 58</div><div class="line">average rate: 59.459</div><div class="line">        min: 0.005s max: 0.027s std dev: 0.00271s window: 118</div><div class="line">average rate: 59.539</div><div class="line">        min: 0.004s max: 0.030s std dev: 0.00339s window: 177</div><div class="line">average rate: 59.492</div><div class="line">        min: 0.004s max: 0.030s std dev: 0.00380s window: 237</div><div class="line">average rate: 59.463</div><div class="line">        min: 0.004s max: 0.030s std dev: 0.00380s window: 290</div></pre></td></tr></table></figure></p>
<p>现在我们可以知道了turtlesim正以大约60Hz的频率发布数据给turtle。我们也可以结合rostopic type和rosmsg show命令来获取关于某个话题的更深层次的信息（非hydro版）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rostopic type /turtle1/command_velocity | rosmsg show</div></pre></td></tr></table></figure></p>
<p>hydro版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rostopic type /turtle1/cmd_vel | rosmsg show</div></pre></td></tr></table></figure></p>
<p>到此我们已经完成了通过rostopic来查看话题相关情况的过程，接下来我将使用另一个工具来查看turtlesim发布的数据。</p>
<h1 id="5-使用-rqt-plot"><a href="#5-使用-rqt-plot" class="headerlink" title="5.使用 rqt_plot"></a>5.使用 rqt_plot</h1><p>注意：如果你使用的是electric或更早期的ROS版本，那么rqt命令是不可用的，请使用rxplot命令来代替。</p>
<p>rqt_plot命令可以实时显示一个发布到某个话题上的数据变化图形。这里我们将使用rqt_plot命令来绘制正在发布到/turtle1/pose话题上的数据变化图形。首先，在一个新终端中运行rqt_plot命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosrun rqt_plot rqt_plot</div></pre></td></tr></table></figure></p>
<p>这会弹出一个新窗口，在窗口左上角的一个文本框里面你可以添加需要绘制的话题。在里面输入/turtle1/pose/x后之前处于禁用状态的加号按钮将会被使能变亮。按一下该按钮，并对/turtle1/pose/y重复相同的过程。现在你会在图形中看到turtle的x-y位置坐标图。</p>
<p><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics?action=AttachFile&amp;do=get&amp;target=rqt_plot.png" alt="这里写图片描述"></p>
<p>按下减号按钮会显示一组菜单让你隐藏图形中指定的话题。现在隐藏掉你刚才添加的话题并添加/turtle1/pose/theta，你会看到如下图所示的图形：<br><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics?action=AttachFile&amp;do=get&amp;target=rqt_plot2.png" alt="这里写图片描述"><br>本部分教程到此为止，请使用Ctrl-C退出rostopic命令，但要保持turtlesim继续运行。</p>
<p>到此我们已经理解了ROS话题是如何工作的，接下来我们开始学习理解ROS服务和参数。 </p>
<p>来自：<br><a href="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingTopics" target="_blank" rel="external">理解ROS话题</a><br>本教程介绍ROS话题（topics）以及如何使用rostopic 和 rqt_plot 命令行工具。 </p>
]]></content>
      
        <categories>
            
            <category> ros </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ros </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ros：（2）ros节点]]></title>
      <url>/2017/11/13/ros/ros%EF%BC%9A%EF%BC%882%EF%BC%89ros%E8%8A%82%E7%82%B9/</url>
      <content type="html"><![CDATA[<h1 id="图概念概述"><a href="#图概念概述" class="headerlink" title="图概念概述"></a>图概念概述</h1><pre><code>Nodes:节点,一个节点即为一个可执行文件，它可以通过ROS与其它节点进行通信。

Messages:消息，消息是一种ROS数据类型，用于订阅或发布到一个话题。

Topics:话题,节点可以发布消息到话题，也可以订阅话题以接收消息。

Master:节点管理器，ROS名称服务 (比如帮助节点找到彼此)。

rosout: ROS中相当于stdout/stderr。

roscore: 主机+ rosout + 参数服务器 (参数服务器会在后面介绍)。 
</code></pre><h1 id="1-roscore"><a href="#1-roscore" class="headerlink" title="1.roscore"></a>1.roscore</h1><p>roscore 是你在运行所有ROS程序前首先要运行的命令。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws$ roscore</div></pre></td></tr></table></figure>
<h1 id="2-1使用rosnode"><a href="#2-1使用rosnode" class="headerlink" title="2.1使用rosnode"></a>2.1使用rosnode</h1><p>rosnode 显示当前运行的ROS节点信息。rosnode list 指令列出活跃的节点:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ rosnode list</div><div class="line">/rosout</div><div class="line">/turtlesim</div></pre></td></tr></table></figure>
<h1 id="2-1rosnode-info-命令"><a href="#2-1rosnode-info-命令" class="headerlink" title="2.1rosnode info 命令"></a>2.1rosnode info 命令</h1><p>rosnode info 命令返回的是关于一个特定节点的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ rosnode info /rosout</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">--------------------------------------------------------------------------------</div><div class="line">Node [/rosout]</div><div class="line">Publications: </div><div class="line"> * /rosout_agg [rosgraph_msgs/Log]</div><div class="line"></div><div class="line">Subscriptions: </div><div class="line"> * /rosout [unknown type]</div><div class="line"></div><div class="line">Services: </div><div class="line"> * /rosout/set_logger_level</div><div class="line"> * /rosout/get_loggers</div><div class="line"></div><div class="line"></div><div class="line">contacting node http://kuo-Inspiron-7420:46315/ ...</div><div class="line">Pid: 5414</div></pre></td></tr></table></figure>
<h1 id="3-使用-rosrun"><a href="#3-使用-rosrun" class="headerlink" title="3.使用 rosrun"></a>3.使用 rosrun</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ rosrun turtlesim turtlesim_node</div></pre></td></tr></table></figure>
<p>出现以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[ INFO] [1506515421.527660398]: Starting turtlesim with node name /turtlesim</div><div class="line">[ INFO] [1506515421.540510002]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]</div></pre></td></tr></table></figure></p>
<p>同时弹出以下窗口:<br><img src="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingNodes?action=AttachFile&amp;do=get&amp;target=turtlesim.png" alt="这里写图片描述"></p>
<p>在一个 新的终端:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rosnode list</div></pre></td></tr></table></figure></p>
<p>你会看见类似于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/rosout</div><div class="line">/turtlesim</div></pre></td></tr></table></figure></p>
<h1 id="4-ROS的一个强大特性就是你可以通过命令行重新配置名称"><a href="#4-ROS的一个强大特性就是你可以通过命令行重新配置名称" class="headerlink" title="4.ROS的一个强大特性就是你可以通过命令行重新配置名称"></a>4.ROS的一个强大特性就是你可以通过命令行重新配置名称</h1><p>记得首先回到rosrun turtlesim终端并使用<code>ctrl-C</code><br>现在让我们重新运行它，但是这一次使用Remapping Argument改变节点名称:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ rosrun turtlesim turtlesim_node __name:=my_turtle</div></pre></td></tr></table></figure></p>
<p>此时再回到<code>rosnode list</code>端口，输入<code>rosnode list</code>会看到名字已经改了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ rosnode list</div><div class="line">/my_turtle  #注意，这里以前是turtlesim</div><div class="line">/rosout</div></pre></td></tr></table></figure></p>
<p>你可以用<code>rosnode ping</code>测试这个节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$  rosnode ping my_turtle</div><div class="line">rosnode: node is [/my_turtle]</div><div class="line">pinging /my_turtle with a timeout of 3.0s</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/	time=0.518084ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/	time=1.244068ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/	time=1.185894ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/	time=1.127005ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/	time=0.943899ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/	time=0.998020ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/	time=0.899076ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/	time=1.173973ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/	time=1.152992ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/	time=0.983000ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/	time=1.232862ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/	time=0.945091ms</div><div class="line">xmlrpc reply from http://kuo-Inspiron-7420:39605/	time=1.293182ms</div><div class="line">^Cping average: 1.053627ms</div></pre></td></tr></table></figure></p>
<p>来自：<br><a href="http://wiki.ros.org/cn/ROS/Tutorials/UnderstandingNodes" target="_blank" rel="external">理解 ROS节点</a><br>本教程主要介绍 ROS 图（graph）概念 并讨论roscore、rosnode和 rosrun 命令行工具的使用。 </p>
]]></content>
      
        <categories>
            
            <category> ros </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ros </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ros：（1）我的第一个ros文件]]></title>
      <url>/2017/11/13/ros/ros%EF%BC%9A%EF%BC%881%EF%BC%89%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAros%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h1 id="1-配置好环境"><a href="#1-配置好环境" class="headerlink" title="1.配置好环境"></a>1.配置好环境</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ source /opt/ros/indigo/setup.bash</div></pre></td></tr></table></figure>
<p>在每次打开终端时你都需要先运行上面这条命令后才能运行ros相关的命令，为了避免这一繁琐过程，你可以事先在.bashrc文件。</p>
<h1 id="2-创建ROS工作空间"><a href="#2-创建ROS工作空间" class="headerlink" title="2.创建ROS工作空间"></a>2.创建ROS工作空间</h1><h2 id="2-1-下面我们开始创建一个catkin-工作空间："><a href="#2-1-下面我们开始创建一个catkin-工作空间：" class="headerlink" title="2.1 下面我们开始创建一个catkin 工作空间："></a>2.1 下面我们开始创建一个catkin 工作空间：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ mkdir -p ~/catkin_ws/src</div><div class="line">kuo@kuo-Inspiron-7420:~$ ls</div><div class="line">catkin_ws         missfont.log  projects  模板</div></pre></td></tr></table></figure>
<h2 id="2-2-cat-make"><a href="#2-2-cat-make" class="headerlink" title="2.2 cat_make"></a>2.2 cat_make</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws$ catkin_make</div><div class="line">...</div><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws$ ls</div><div class="line">build  devel  src</div></pre></td></tr></table></figure>
<h3 id="2-3-source-setup-bash"><a href="#2-3-source-setup-bash" class="headerlink" title="2.3 source setup.bash"></a>2.3 source setup.bash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws$ cd devel</div><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/devel$ ls</div><div class="line">env.sh  lib  setup.bash  setup.sh  _setup_util.py  setup.zsh</div><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/devel$ source setup.bash</div></pre></td></tr></table></figure>
<h1 id="3-ROS文件系统介绍"><a href="#3-ROS文件系统介绍" class="headerlink" title="3.ROS文件系统介绍"></a>3.ROS文件系统介绍</h1><p>Description: 本教程介绍ROS文件系统概念，包括命令行工具roscd、rosls和rospack的使用。</p>
<h2 id="3-1-rospack-寻找文件夹地址"><a href="#3-1-rospack-寻找文件夹地址" class="headerlink" title="3.1 rospack :寻找文件夹地址"></a>3.1 <em>rospack</em> :寻找文件夹地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ rospack find roscpp</div><div class="line">/opt/ros/indigo/share/roscpp</div></pre></td></tr></table></figure>
<h2 id="3-2-roscd-进入文件夹"><a href="#3-2-roscd-进入文件夹" class="headerlink" title="3.2 roscd :进入文件夹"></a>3.2 <em>roscd</em> :进入文件夹</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ roscd roscpp</div><div class="line">kuo@kuo-Inspiron-7420:/opt/ros/indigo/share/roscpp$ pwd</div><div class="line">/opt/ros/indigo/share/roscpp</div></pre></td></tr></table></figure>
<h2 id="3-3-rosls-显示问价夹内容"><a href="#3-3-rosls-显示问价夹内容" class="headerlink" title="3.3 rosls :显示问价夹内容"></a>3.3 <em>rosls</em> :显示问价夹内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/.ros/log$ rosls roscpp_tutorials</div><div class="line">cmake  launch  package.xml  srv</div></pre></td></tr></table></figure>
<h1 id="4-创建ROS程序包"><a href="#4-创建ROS程序包" class="headerlink" title="4.创建ROS程序包"></a>4.创建ROS程序包</h1><p>Description: 本教程介绍如何使用 <em>roscreate-pkg</em> 或 <em>catkin</em> 创建一个新程序包,并使用 <em>rospack</em> 查看程序包的依赖关系。</p>
<h4 id="4-1-本教程中我们将会用到ros-tutorials程序包，请先安装："><a href="#4-1-本教程中我们将会用到ros-tutorials程序包，请先安装：" class="headerlink" title="4.1 本教程中我们将会用到ros-tutorials程序包，请先安装："></a>4.1 本教程中我们将会用到ros-tutorials程序包，请先安装：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/src$ sudo apt-get install ros-indigo-ros-tutorials</div></pre></td></tr></table></figure>
<h4 id="4-2-现在使用-catkin-create-pkg-命令来创建一个名为’beginner-tutorials’的新程序包，这个程序包依赖于std-msgs、roscpp和rospy："><a href="#4-2-现在使用-catkin-create-pkg-命令来创建一个名为’beginner-tutorials’的新程序包，这个程序包依赖于std-msgs、roscpp和rospy：" class="headerlink" title="4.2 现在使用 catkin_create_pkg 命令来创建一个名为’beginner_tutorials’的新程序包，这个程序包依赖于std_msgs、roscpp和rospy："></a>4.2 现在使用 <em>catkin_create_pkg</em> 命令来创建一个名为’beginner_tutorials’的新程序包，这个程序包依赖于std_msgs、roscpp和rospy：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/src$ cd ~/catkin_ws/src</div><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/src$ catkin_create_pkg beginner_tutorials std_msgs rospy roscpp</div></pre></td></tr></table></figure>
<h1 id="5-编译ROS程序包"><a href="#5-编译ROS程序包" class="headerlink" title="5.编译ROS程序包"></a>5.编译ROS程序包</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/src$ cd ~/catkin_ws/</div><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws$ catkin_make</div></pre></td></tr></table></figure>
<h1 id="6-运行ros"><a href="#6-运行ros" class="headerlink" title="6.运行ros"></a>6.运行ros</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws$ roscore</div></pre></td></tr></table></figure>
<h1 id="7-打开-turtlesim-窗口"><a href="#7-打开-turtlesim-窗口" class="headerlink" title="7.打开 turtlesim 窗口"></a>7.打开 turtlesim 窗口</h1><p>运行turtlesim包中的 turtlesim_node节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ rosrun turtlesim turtlesim_node</div><div class="line">[ INFO] [1506515421.527660398]: Starting turtlesim with node name /turtlesim</div><div class="line">[ INFO] [1506515421.540510002]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]</div></pre></td></tr></table></figure>
<p>如果出现 turtlesim 窗口，就表示文件创建成功！<br><img src="http://img.blog.csdn.net/20170927203643496?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="bug时间：环境变量设置问题"><a href="#bug时间：环境变量设置问题" class="headerlink" title="bug时间：环境变量设置问题"></a>bug时间：环境变量设置问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">. ~/catkin_ws/devel/setup.bash</div></pre></td></tr></table></figure>
<p>解决 <em>roscd beginner_tutorials</em> 没有此文件的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ roscd beginner_tutorials</div><div class="line">roscd: No such package/stack &apos;beginner_tutorials&apos;</div><div class="line">kuo@kuo-Inspiron-7420:~$ . ~/catkin_ws/devel/setup.bash</div><div class="line">kuo@kuo-Inspiron-7420:~$ roscd beginner_tutorials</div><div class="line">kuo@kuo-Inspiron-7420:~/catkin_ws/src/beginner_tutorials$</div></pre></td></tr></table></figure></p>
<p>来自：初级教程1-4：<a href="http://wiki.ros.org/cn/ROS/Tutorials" target="_blank" rel="external">http://wiki.ros.org/cn/ROS/Tutorials</a></p>
]]></content>
      
        <categories>
            
            <category> ros </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ros </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ros：（0）安装与教程]]></title>
      <url>/2017/11/13/ros/ros%EF%BC%9A%EF%BC%880%EF%BC%89%E5%AE%89%E8%A3%85%E4%B8%8E%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="1-ros"><a href="#1-ros" class="headerlink" title="1.ros"></a>1.ros</h1><h2 id="1-1安装"><a href="#1-1安装" class="headerlink" title="1.1安装"></a>1.1安装</h2><pre><code>一.在Ubuntu14.04上安装和配置ROS Indigo ：http://blog.csdn.net/zhuquan945/article/details/53079257
</code></pre><h2 id="1-2学习教程"><a href="#1-2学习教程" class="headerlink" title="1.2学习教程"></a>1.2学习教程</h2><pre><code>一.ros官方中文教程：http://wiki.ros.org/cn/ROS/Tutorials
二.ROS机器人操作系统的安装、配置与初级教程：https://www.shiyanlou.com/courses/854
三.创客智造|ROS入门教程:http://www.ncnynl.com/archives/201608/497.html
</code></pre>]]></content>
      
        <categories>
            
            <category> ros </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ros </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Google超有趣 AI 小实验合集]]></title>
      <url>/2017/11/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Google%E8%B6%85%E6%9C%89%E8%B6%A3%20AI%20%E5%B0%8F%E5%AE%9E%E9%AA%8C%E5%90%88%E9%9B%86/</url>
      <content type="html"><![CDATA[<p>转自：<a href="https://zhuanlan.zhihu.com/p/30501448" target="_blank" rel="external">不论你会不会编程，你都可以在这感受到AI的乐趣（园长诚意推荐）</a></p>
<pre><code>简评：都是些特别有趣的、有意义、有想法的小项目，让人工智能落地，接地气，看得见摸得着。真不错，其中能玩的我都玩了。
</code></pre><p>Google Experiment（谷歌实验）是谷歌官方出品的，各种前沿技术的新锐实验，让非技术用户也能够体验到最新的技术成果。<br>入口：Google Ai 实验<br>（因为是 Google 的，都要科学上网)</p>
<p>这个网页是这样的：</p>
<p><img src="http://img.blog.csdn.net/20171028211408689?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<pre><code>原网页：https://experiments.withgoogle.com/ai
</code></pre>]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[opencv安装问题`ippicv_linux_20140513.tgz...`]]></title>
      <url>/2017/11/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/opencv%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%60ippicv_linux_20140513.tgz...%60/</url>
      <content type="html"><![CDATA[<h2 id="Ubuntu14-04安装OpenCV3-0-http-blog-csdn-net-u011762313-article-details-47263845"><a href="#Ubuntu14-04安装OpenCV3-0-http-blog-csdn-net-u011762313-article-details-47263845" class="headerlink" title="Ubuntu14.04安装OpenCV3.0 :http://blog.csdn.net/u011762313/article/details/47263845"></a>Ubuntu14.04安装OpenCV3.0 :<a href="http://blog.csdn.net/u011762313/article/details/47263845" target="_blank" rel="external">http://blog.csdn.net/u011762313/article/details/47263845</a></h2><h2 id="opencv安装问题ippicv-linux-20140513-tgz"><a href="#opencv安装问题ippicv-linux-20140513-tgz" class="headerlink" title="opencv安装问题ippicv_linux_20140513.tgz..."></a>opencv安装问题<code>ippicv_linux_20140513.tgz...</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">-- ICV: Downloading ippicv_linux_20140513.tgz...</div><div class="line">CMake Error at 3rdparty/ippicv/downloader.cmake:71 (file):</div><div class="line">  file DOWNLOAD HASH mismatch</div><div class="line"></div><div class="line">    for file: [/home/kuo/opencv/opencv-3.0.0-alpha/3rdparty/ippicv/downloads/linux-d80cb24f3a565113a9d6dc56344142f6/ippicv_linux_20140513.tgz]</div><div class="line">      expected hash: [d80cb24f3a565113a9d6dc56344142f6]</div><div class="line">        actual hash: [d41d8cd98f00b204e9800998ecf8427e]</div><div class="line"></div><div class="line">Call Stack (most recent call first):</div><div class="line">  3rdparty/ippicv/downloader.cmake:108 (_icv_downloader)</div><div class="line">  cmake/OpenCVFindIPP.cmake:212 (include)</div><div class="line">  cmake/OpenCVFindLibsPerf.cmake:12 (include)</div><div class="line">  CMakeLists.txt:449 (include)</div><div class="line"></div><div class="line"></div><div class="line">CMake Error at 3rdparty/ippicv/downloader.cmake:75 (message):</div><div class="line">  ICV: Failed to download ICV package: ippicv_linux_20140513.tgz.</div><div class="line">  Status=35;&quot;SSL connect error&quot;</div><div class="line">Call Stack (most recent call first):</div><div class="line">  3rdparty/ippicv/downloader.cmake:108 (_icv_downloader)</div><div class="line">  cmake/OpenCVFindIPP.cmake:212 (include)</div><div class="line">  cmake/OpenCVFindLibsPerf.cmake:12 (include)</div><div class="line">  CMakeLists.txt:449 (include)</div><div class="line"></div><div class="line"></div><div class="line">-- Configuring incomplete, errors occurred!</div><div class="line">See also &quot;/home/kuo/opencv/opencv-3.0.0-alpha/CMakeFiles/CMakeOutput.log&quot;.</div><div class="line">See also &quot;/home/kuo/opencv/opencv-3.0.0-alpha/CMakeFiles/CMakeError.log&quot;.</div></pre></td></tr></table></figure>
<p><a href="https://osdn.net/projects/sfnet_opencvlibrary/downloads/3rdparty/ippicv/ippicv_linux_20140513.tgz/" target="_blank" rel="external">https://osdn.net/projects/sfnet_opencvlibrary/downloads/3rdparty/ippicv/ippicv_linux_20140513.tgz/</a></p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[是AI就躲个飞机-纯Python实现人工智能]]></title>
      <url>/2017/11/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%98%AFAI%E5%B0%B1%E8%BA%B2%E4%B8%AA%E9%A3%9E%E6%9C%BA-%E7%BA%AFPython%E5%AE%9E%E7%8E%B0%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>转自：<a href="http://blog.csdn.net/u014365862/article/details/54380422" target="_blank" rel="external">是AI就躲个飞机-纯Python实现人工智能</a></p>
<p>很久以前微信流行过一个小游戏：打飞机，这个游戏简单又无聊。在2017年来临之际，我就实现一个超级弱智的人工智能（AI），这货可以躲避从屏幕上方飞来的飞机。本帖只使用纯Python实现，不依赖任何高级库。</p>
<p>本文的AI基于<a href="https://en.wikipedia.org/wiki/Neuroevolution" target="_blank" rel="external">neuro-evolution</a>，首先简单科普一下neuro-evolution。从neuro-evolution这个名字就可以看出它由两部分组成-neuro and evolution，它是使用进化算法（遗传算法是进化算法的一种）提升人工神经网络的机器学习技术，其实就是用进化算法改进并选出最优的神经网络。</p>
<p>   <a href="http://blog.topspeedsnail.com/archives/10709" target="_blank" rel="external">使用TPOT自动选择scikit-learn机器学习模型和参数</a></p>
<h2 id="neuro-evolution"><a href="#neuro-evolution" class="headerlink" title="neuro-evolution"></a>neuro-evolution</h2><p>定义一些变量：</p>
<figure class="highlight plain"><figcaption><span>view plain copy</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import math  </div><div class="line">import random  </div><div class="line">   </div><div class="line"># 神经网络3层, 1个隐藏层; 4个input和1个output  </div><div class="line">network = [4, [16], 1]  </div><div class="line"># 遗传算法相关  </div><div class="line">population = 50  </div><div class="line">elitism = 0.2   </div><div class="line">random_behaviour = 0.1  </div><div class="line">mutation_rate = 0.5  </div><div class="line">mutation_range = 2  </div><div class="line">historic = 0  </div><div class="line">low_historic = False  </div><div class="line">score_sort = -1  </div><div class="line">n_child = 1</div></pre></td></tr></table></figure>
<p>定义神经网络：</p>
<figure class="highlight plain"><figcaption><span>view plain copy</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># 激活函数  </div><div class="line">def sigmoid(z):  </div><div class="line">    return 1.0/(1.0+math.exp(-z))  </div><div class="line"># random number  </div><div class="line">def random_clamped():  </div><div class="line">    return random.random()*2-1  </div><div class="line">   </div><div class="line"># &quot;神经元&quot;  </div><div class="line">class Neuron():  </div><div class="line">    def __init__(self):  </div><div class="line">        self.biase = 0  </div><div class="line">        self.weights = []  </div><div class="line">   </div><div class="line">    def init_weights(self, n):  </div><div class="line">        self.weights = []  </div><div class="line">        for i in range(n):  </div><div class="line">            self.weights.append(random_clamped())  </div><div class="line">    def __repr__(self):  </div><div class="line">        return &apos;Neuron weight size:&#123;&#125;  biase value:&#123;&#125;&apos;.format(len(self.weights), self.biase)  </div><div class="line">   </div><div class="line"># 层  </div><div class="line">class Layer():  </div><div class="line">    def __init__(self, index):  </div><div class="line">        self.index = index  </div><div class="line">        self.neurons = []  </div><div class="line">   </div><div class="line">    def init_neurons(self, n_neuron, n_input):  </div><div class="line">        self.neurons = []  </div><div class="line">        for i in range(n_neuron):  </div><div class="line">            neuron = Neuron()  </div><div class="line">            neuron.init_weights(n_input)  </div><div class="line">            self.neurons.append(neuron)  </div><div class="line">   </div><div class="line">    def __repr__(self):  </div><div class="line">        return &apos;Layer ID:&#123;&#125;  Layer neuron size:&#123;&#125;&apos;.format(self.index, len(self.neurons))  </div><div class="line">   </div><div class="line"># 神经网络  </div><div class="line">class NeuroNetwork():  </div><div class="line">    def __init__(self):  </div><div class="line">        self.layers = []  </div><div class="line">   </div><div class="line">    # input:输入层神经元数 hiddens:隐藏层 output:输出层神经元数  </div><div class="line">    def init_neuro_network(self, input, hiddens , output):  </div><div class="line">        index = 0  </div><div class="line">        previous_neurons = 0  </div><div class="line">        # input  </div><div class="line">        layer = Layer(index)  </div><div class="line">        layer.init_neurons(input, previous_neurons)  </div><div class="line">        previous_neurons = input  </div><div class="line">        self.layers.append(layer)  </div><div class="line">        index += 1  </div><div class="line">        # hiddens  </div><div class="line">        for i in range(len(hiddens)):  </div><div class="line">            layer = Layer(index)  </div><div class="line">            layer.init_neurons(hiddens[i], previous_neurons)  </div><div class="line">            previous_neurons = hiddens[i]  </div><div class="line">            self.layers.append(layer)  </div><div class="line">            index += 1  </div><div class="line">        # output  </div><div class="line">        layer = Layer(index)  </div><div class="line">        layer.init_neurons(output, previous_neurons)  </div><div class="line">        self.layers.append(layer)  </div><div class="line">   </div><div class="line">    def get_weights(self):  </div><div class="line">        data = &#123; &apos;network&apos;:[], &apos;weights&apos;:[] &#125;  </div><div class="line">        for layer in self.layers:  </div><div class="line">            data[&apos;network&apos;].append(len(layer.neurons))  </div><div class="line">            for neuron in layer.neurons:  </div><div class="line">                for weight in neuron.weights:  </div><div class="line">                    data[&apos;weights&apos;].append(weight)  </div><div class="line">        return data  </div><div class="line">   </div><div class="line">    def set_weights(self, data):  </div><div class="line">        previous_neurons = 0  </div><div class="line">        index = 0  </div><div class="line">        index_weights = 0  </div><div class="line">   </div><div class="line">        self.layers = []  </div><div class="line">        for i in data[&apos;network&apos;]:  </div><div class="line">            layer = Layer(index)  </div><div class="line">            layer.init_neurons(i, previous_neurons)  </div><div class="line">            for j in range(len(layer.neurons)):  </div><div class="line">                for k in range(len(layer.neurons[j].weights)):  </div><div class="line">                    layer.neurons[j].weights[k] = data[&apos;weights&apos;][index_weights]  </div><div class="line">                    index_weights += 1  </div><div class="line">            previous_neurons = i  </div><div class="line">            index += 1  </div><div class="line">            self.layers.append(layer)  </div><div class="line">   </div><div class="line">    # 输入游戏环境中的一些条件(如敌机位置), 返回要执行的操作  </div><div class="line">    def feed_forward(self, inputs):  </div><div class="line">        for i in range(len(inputs)):  </div><div class="line">            self.layers[0].neurons[i].biase = inputs[i]  </div><div class="line">   </div><div class="line">        prev_layer = self.layers[0]  </div><div class="line">        for i in range(len(self.layers)):  </div><div class="line">            # 第一层没有weights  </div><div class="line">            if i == 0:  </div><div class="line">                continue  </div><div class="line">            for j in range(len(self.layers[i].neurons)):  </div><div class="line">                sum = 0  </div><div class="line">                for k in range(len(prev_layer.neurons)):  </div><div class="line">                    sum += prev_layer.neurons[k].biase * self.layers[i].neurons[j].weights[k]  </div><div class="line">                self.layers[i].neurons[j].biase = sigmoid(sum)  </div><div class="line">            prev_layer = self.layers[i]  </div><div class="line">   </div><div class="line">        out = []  </div><div class="line">        last_layer = self.layers[-1]  </div><div class="line">        for i in range(len(last_layer.neurons)):  </div><div class="line">            out.append(last_layer.neurons[i].biase)  </div><div class="line">        return out  </div><div class="line">   </div><div class="line">    def print_info(self):  </div><div class="line">        for layer in self.layers:  </div><div class="line">            print(layer)</div></pre></td></tr></table></figure>
<p>遗传算法：</p>
<figure class="highlight plain"><figcaption><span>view plain copy</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># &quot;基因组&quot;  </div><div class="line">class Genome():  </div><div class="line">    def __init__(self, score, network_weights):  </div><div class="line">        self.score = score  </div><div class="line">        self.network_weights = network_weights  </div><div class="line">   </div><div class="line">class Generation():  </div><div class="line">    def __init__(self):  </div><div class="line">        self.genomes = []  </div><div class="line">   </div><div class="line">    def add_genome(self, genome):  </div><div class="line">        i = 0  </div><div class="line">        for i in range(len(self.genomes)):  </div><div class="line">            if score_sort &lt; 0:  </div><div class="line">                if genome.score &gt; self.genomes[i].score:  </div><div class="line">                    break  </div><div class="line">            else:  </div><div class="line">                if genome.score &lt; self.genomes[i].score:  </div><div class="line">                    break  </div><div class="line">        self.genomes.insert(i, genome)  </div><div class="line">   </div><div class="line">        # 杂交+突变  </div><div class="line">    def breed(self, genome1, genome2, n_child):  </div><div class="line">        datas = []  </div><div class="line">        for n in range(n_child):  </div><div class="line">            data = genome1  </div><div class="line">            for i in range(len(genome2.network_weights[&apos;weights&apos;])):  </div><div class="line">                if random.random() &lt;= 0.5:  </div><div class="line">                    data.network_weights[&apos;weights&apos;][i] = genome2.network_weights[&apos;weights&apos;][i]  </div><div class="line">   </div><div class="line">            for i in range(len(data.network_weights[&apos;weights&apos;])):  </div><div class="line">                if random.random() &lt;= mutation_rate:  </div><div class="line">                    data.network_weights[&apos;weights&apos;][i] += random.random() * mutation_range * 2 - mutation_range  </div><div class="line">            datas.append(data)  </div><div class="line">        return datas  </div><div class="line">   </div><div class="line">        # 生成下一代  </div><div class="line">    def generate_next_generation(self):  </div><div class="line">        nexts = []  </div><div class="line">        for i in range(round(elitism*population)):  </div><div class="line">            if len(nexts) &lt; population:  </div><div class="line">                nexts.append(self.genomes[i].network_weights)  </div><div class="line">   </div><div class="line">        for i in range(round(random_behaviour*population)):  </div><div class="line">            n = self.genomes[0].network_weights  </div><div class="line">            for k in range(len(n[&apos;weights&apos;])):  </div><div class="line">                n[&apos;weights&apos;][k] = random_clamped()  </div><div class="line">            if len(nexts) &lt; population:  </div><div class="line">                nexts.append(n)  </div><div class="line">   </div><div class="line">        max_n = 0  </div><div class="line">        while True:  </div><div class="line">            for i in range(max_n):  </div><div class="line">                childs = self.breed(self.genomes[i], self.genomes[max_n], n_child if n_child &gt; 0 else 1)  </div><div class="line">                for c in range(len(childs)):  </div><div class="line">                    nexts.append(childs[c].network_weights)  </div><div class="line">                    if len(nexts) &gt;= population:  </div><div class="line">                        return nexts  </div><div class="line">            max_n += 1  </div><div class="line">            if max_n &gt;= len(self.genomes)-1:  </div><div class="line">                max_n = 0</div></pre></td></tr></table></figure>
<p>NeuroEvolution：</p>
<figure class="highlight plain"><figcaption><span>view plain copy</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Generations():  </div><div class="line">    def __init__(self):  </div><div class="line">        self.generations = []  </div><div class="line">   </div><div class="line">    def first_generation(self):  </div><div class="line">        out = []  </div><div class="line">        for i in range(population):  </div><div class="line">            nn = NeuroNetwork()  </div><div class="line">            nn.init_neuro_network(network[0], network[1], network[2])  </div><div class="line">            out.append(nn.get_weights())  </div><div class="line">        self.generations.append(Generation())  </div><div class="line">        return out  </div><div class="line">          </div><div class="line">    def next_generation(self):  </div><div class="line">        if len(self.generations) == 0:  </div><div class="line">            return False  </div><div class="line">   </div><div class="line">        gen = self.generations[-1].generate_next_generation()  </div><div class="line">        self.generations.append(Generation())  </div><div class="line">        return gen  </div><div class="line">   </div><div class="line">    def add_genome(self, genome):  </div><div class="line">        if len(self.generations) == 0:  </div><div class="line">            return False  </div><div class="line">   </div><div class="line">        return self.generations[-1].add_genome(genome)  </div><div class="line">   </div><div class="line">class NeuroEvolution():  </div><div class="line">    def __init__(self):  </div><div class="line">        self.generations = Generations()  </div><div class="line">   </div><div class="line">    def restart(self):  </div><div class="line">        self.generations = Generations()  </div><div class="line">   </div><div class="line">    def next_generation(self):  </div><div class="line">        networks = []  </div><div class="line">        if len(self.generations.generations) == 0:  </div><div class="line">            networks = self.generations.first_generation()  </div><div class="line">        else:  </div><div class="line">            networks = self.generations.next_generation()  </div><div class="line">   </div><div class="line">        nn = []  </div><div class="line">        for i in range(len(networks)):  </div><div class="line">            n = NeuroNetwork()  </div><div class="line">            n.set_weights(networks[i])  </div><div class="line">            nn.append(n)  </div><div class="line">   </div><div class="line">        if low_historic:  </div><div class="line">            if len(self.generations.generations) &gt;= 2:  </div><div class="line">                genomes = self.generations.generations[len(self.generations.generations) - 2].genomes  </div><div class="line">                for i in range(genomes):  </div><div class="line">                    genomes[i].network = None  </div><div class="line">   </div><div class="line">        if historic != -1:  </div><div class="line">            if len(self.generations.generations) &gt; historic+1:  </div><div class="line">                del self.generations.generations[0:len(self.generations.generations)-(historic+1)]  </div><div class="line">   </div><div class="line">        return nn  </div><div class="line">   </div><div class="line">    def network_score(self, score, network):  </div><div class="line">        self.generations.add_genome(Genome(score, network.get_weights()))</div></pre></td></tr></table></figure>
<p>是AI就躲个飞机<br><figure class="highlight plain"><figcaption><span>view plain copy</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import pygame  </div><div class="line">import sys  </div><div class="line">from pygame.locals import *  </div><div class="line">import random  </div><div class="line">import math  </div><div class="line">   </div><div class="line">import neuro_evolution  </div><div class="line">   </div><div class="line">BACKGROUND = (200, 200, 200)  </div><div class="line">SCREEN_SIZE = (320, 480)  </div><div class="line">   </div><div class="line">class Plane():  </div><div class="line">    def __init__(self, plane_image):  </div><div class="line">        self.plane_image = plane_image  </div><div class="line">        self.rect = plane_image.get_rect()  </div><div class="line">   </div><div class="line">        self.width = self.rect[2]  </div><div class="line">        self.height = self.rect[3]  </div><div class="line">        self.x = SCREEN_SIZE[0]/2 - self.width/2  </div><div class="line">        self.y = SCREEN_SIZE[1] - self.height  </div><div class="line">   </div><div class="line">        self.move_x = 0  </div><div class="line">        self.speed = 2  </div><div class="line">   </div><div class="line">        self.alive = True  </div><div class="line">   </div><div class="line">    def update(self):  </div><div class="line">        self.x += self.move_x * self.speed  </div><div class="line">   </div><div class="line">    def draw(self, screen):  </div><div class="line">        screen.blit(self.plane_image, (self.x, self.y, self.width, self.height))  </div><div class="line">   </div><div class="line">    def is_dead(self, enemes):  </div><div class="line">        if self.x &lt; -self.width or self.x + self.width &gt; SCREEN_SIZE[0]+self.width:  </div><div class="line">            return True  </div><div class="line">   </div><div class="line">        for eneme in enemes:  </div><div class="line">            if self.collision(eneme):  </div><div class="line">                return True  </div><div class="line">        return False  </div><div class="line">   </div><div class="line">    def collision(self, eneme):  </div><div class="line">        if not (self.x &gt; eneme.x + eneme.width or self.x + self.width &lt; eneme.x or self.y &gt; eneme.y + eneme.height or self.y + self.height &lt; eneme.y):  </div><div class="line">            return True  </div><div class="line">        else:  </div><div class="line">            return False  </div><div class="line">   </div><div class="line">    def get_inputs_values(self, enemes, input_size=4):  </div><div class="line">        inputs = []  </div><div class="line">   </div><div class="line">        for i in range(input_size):  </div><div class="line">            inputs.append(0.0)  </div><div class="line">   </div><div class="line">        inputs[0] = (self.x*1.0 / SCREEN_SIZE[0])  </div><div class="line">        index = 1  </div><div class="line">        for eneme in enemes:  </div><div class="line">            inputs[index] = eneme.x*1.0 / SCREEN_SIZE[0]  </div><div class="line">            index += 1  </div><div class="line">            inputs[index] = eneme.y*1.0 / SCREEN_SIZE[1]  </div><div class="line">            index += 1  </div><div class="line">        #if len(enemes) &gt; 0:  </div><div class="line">            #distance = math.sqrt(math.pow(enemes[0].x + enemes[0].width/2 - self.x + self.width/2, 2) + math.pow(enemes[0].y + enemes[0].height/2 - self.y + self.height/2, 2));  </div><div class="line">        if len(enemes) &gt; 0 and self.x &lt; enemes[0].x:  </div><div class="line">            inputs[index] = -1.0  </div><div class="line">            index += 1  </div><div class="line">        else:  </div><div class="line">            inputs[index] = 1.0  </div><div class="line">   </div><div class="line">        return inputs  </div><div class="line">   </div><div class="line">class Enemy():  </div><div class="line">    def __init__(self, enemy_image):  </div><div class="line">        self.enemy_image = enemy_image  </div><div class="line">        self.rect = enemy_image.get_rect()  </div><div class="line">   </div><div class="line">        self.width = self.rect[2]  </div><div class="line">        self.height = self.rect[3]  </div><div class="line">        self.x = random.choice(range(0, int(SCREEN_SIZE[0] - self.width/2), 71))  </div><div class="line">        self.y = 0  </div><div class="line">   </div><div class="line">    def update(self):  </div><div class="line">        self.y += 6  </div><div class="line">   </div><div class="line">    def draw(self, screen):  </div><div class="line">        screen.blit(self.enemy_image, (self.x, self.y, self.width, self.height))  </div><div class="line">   </div><div class="line">    def is_out(self):  </div><div class="line">        return True if self.y &gt;= SCREEN_SIZE[1] else False  </div><div class="line">   </div><div class="line">class Game():  </div><div class="line">    def __init__(self):  </div><div class="line">        pygame.init()  </div><div class="line">        self.screen = pygame.display.set_mode(SCREEN_SIZE)  </div><div class="line">        self.clock = pygame.time.Clock()  </div><div class="line">        pygame.display.set_caption(&apos;是AI就躲个飞机&apos;)  </div><div class="line">   </div><div class="line">        self.ai = neuro_evolution.NeuroEvolution()  </div><div class="line">        self.generation = 0  </div><div class="line">   </div><div class="line">        self.max_enemes = 1  </div><div class="line">                # 加载飞机、敌机图片  </div><div class="line">        self.plane_image = pygame.image.load(&apos;plane.png&apos;).convert_alpha()  </div><div class="line">        self.enemy_image = pygame.image.load(&apos;enemy.png&apos;).convert_alpha()  </div><div class="line">   </div><div class="line">    def start(self):  </div><div class="line">        self.score = 0  </div><div class="line">        self.planes = []  </div><div class="line">        self.enemes = []  </div><div class="line">   </div><div class="line">        self.gen = self.ai.next_generation()  </div><div class="line">        for i in range(len(self.gen)):  </div><div class="line">            plane = Plane(self.plane_image)  </div><div class="line">            self.planes.append(plane)  </div><div class="line">   </div><div class="line">        self.generation += 1  </div><div class="line">        self.alives = len(self.planes)  </div><div class="line">   </div><div class="line">    def update(self, screen):  </div><div class="line">        for i in range(len(self.planes)):  </div><div class="line">            if self.planes[i].alive:  </div><div class="line">                inputs = self.planes[i].get_inputs_values(self.enemes)  </div><div class="line">                res = self.gen[i].feed_forward(inputs)  </div><div class="line">                if res[0] &lt; 0.45:  </div><div class="line">                    self.planes[i].move_x = -1  </div><div class="line">                elif res[0] &gt; 0.55:  </div><div class="line">                    self.planes[i].move_x = 1  </div><div class="line">   </div><div class="line">   </div><div class="line">                self.planes[i].update()  </div><div class="line">                self.planes[i].draw(screen)  </div><div class="line">   </div><div class="line">                if self.planes[i].is_dead(self.enemes) == True:  </div><div class="line">                    self.planes[i].alive = False  </div><div class="line">                    self.alives -= 1  </div><div class="line">                    self.ai.network_score(self.score, self.gen[i])  </div><div class="line">                    if self.is_ai_all_dead():  </div><div class="line">                        self.start()  </div><div class="line">   </div><div class="line">          </div><div class="line">        self.gen_enemes()  </div><div class="line">   </div><div class="line">        for i in range(len(self.enemes)):  </div><div class="line">            self.enemes[i].update()  </div><div class="line">            self.enemes[i].draw(screen)  </div><div class="line">            if self.enemes[i].is_out():  </div><div class="line">                del self.enemes[i]  </div><div class="line">                break  </div><div class="line">   </div><div class="line">        self.score += 1  </div><div class="line">   </div><div class="line">        print(&quot;alive:&#123;&#125;, generation:&#123;&#125;, score:&#123;&#125;&quot;.format(self.alives, self.generation, self.score), end=&apos;\r&apos;)  </div><div class="line">   </div><div class="line">    def run(self, FPS=1000):  </div><div class="line">        while True:  </div><div class="line">            for event in pygame.event.get():  </div><div class="line">                if event.type == QUIT:  </div><div class="line">                    pygame.quit()  </div><div class="line">                    sys.exit()  </div><div class="line">   </div><div class="line">            self.screen.fill(BACKGROUND)  </div><div class="line">   </div><div class="line">            self.update(self.screen)  </div><div class="line">   </div><div class="line">            pygame.display.update()  </div><div class="line">            self.clock.tick(FPS)  </div><div class="line">   </div><div class="line">    def gen_enemes(self):  </div><div class="line">        if len(self.enemes) &lt; self.max_enemes:  </div><div class="line">            enemy = Enemy(self.enemy_image)  </div><div class="line">            self.enemes.append(enemy)  </div><div class="line">   </div><div class="line">    def is_ai_all_dead(self):  </div><div class="line">        for plane in self.planes:  </div><div class="line">            if plane.alive:  </div><div class="line">                return False  </div><div class="line">        return True  </div><div class="line">   </div><div class="line">   </div><div class="line">game = Game()  </div><div class="line">game.start()  </div><div class="line">game.run()</div></pre></td></tr></table></figure></p>
<h2 id="AI的工作逻辑"><a href="#AI的工作逻辑" class="headerlink" title="AI的工作逻辑"></a>AI的工作逻辑</h2><p>假设你是AI，你首先繁殖一个种群（50个个体），开始的个体大都是歪瓜裂枣（上来就被敌机撞）。但是，即使是歪瓜裂枣也有表现好的，在下一代，你会使用这些表现好的再繁殖一个种群，经过代代相传，存活下来的个体会越来越优秀。其实就是仿达尔文进化论，种群-&gt;自然选择-&gt;优秀个体-&gt;杂交、变异-&gt;种群-&gt;循环n世代。</p>
<p>ai开始时候的表现：<br><img src="http://blog.topspeedsnail.com/wp-content/uploads/2016/12/ai1.gif" alt="是AI就躲个飞机 - 纯Python实现人工智能图片被拉扁了 sorry"></p>
<p>经过几百代之后，ai开始娱乐的躲飞机：</p>
<p><img src="http://blog.topspeedsnail.com/wp-content/uploads/2016/12/ai2.gif" alt="是AI就躲个飞机 - 纯Python实现人工智能"></p>
<p>代码：<a href="https://github.com/xiongdemao/py_game_AI_plane.git" target="_blank" rel="external">https://github.com/xiongdemao/py_game_AI_plane.git</a></p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器人的自主定位导航]]></title>
      <url>/2017/11/13/%E5%AF%BC%E8%88%AA/%E5%88%A9%E7%94%A8%E8%A7%86%E8%A7%89%E5%92%8Cdeep%20learning%E5%81%9A%E8%87%AA%E4%B8%BB%E5%AF%BC%E8%88%AA/</url>
      <content type="html"><![CDATA[<h1 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h1><h2 id="1-1-机器人的自主定位导航"><a href="#1-1-机器人的自主定位导航" class="headerlink" title="1.1 机器人的自主定位导航"></a>1.1 <strong>机器人的自主定位导航</strong></h2><p><img src="http://img.blog.csdn.net/20171112195115316?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>正如图中所示，<strong>机器人自主定位导航技术</strong>中包括：<strong>定位和地图创建（SLAM）</strong>与<strong>路径规划和运动控制</strong>两个部分，而SLAM本身只是完成机器人的定位和地图创建，二者有所区别。</p>
<p>首先明确一下自主导航的两大解决方案：</p>
<blockquote>
<p>1.传统方案（稍微成熟一点）：SLAM+路径规划+运动控制；</p>
<p>2.深度学习（还不完善）：<br>这一两年，深度学习成为人工智能的代名词。在这个行业，前几年还是以比较传统的概率学，或者控制论的方式进行机器人自主定位导航。但这里展现的是完全通过深度学习，直接通过摄像头数据作为信号输入，再通过神经网络直接产生出机器人的控制信号。其中像 SLAM 的过程、路径规划的过程，完全通过学习的方式就可以进行实现。</p>
</blockquote>
<h2 id="1-2-传统方案"><a href="#1-2-传统方案" class="headerlink" title="1.2.传统方案"></a>1.2.传统方案</h2><p>传统方案是：（SLAM+路径规划+运动控制）</p>
<h3 id="1-2-1-SLAM"><a href="#1-2-1-SLAM" class="headerlink" title="1.2.1.SLAM"></a>1.2.1.SLAM</h3><p>SLAM是同步定位与地图构建(Simultaneous Localization And Mapping)的缩写，最早由Hugh Durrant-Whyte 和 John J.Leonard提出。</p>
<p>其实，SLAM更像是一个概念而不是一个算法，它本身包含许多步骤，其中的每一个步骤均可以使用不同的算法实现。主要用于解决移动机器人在未知环境中运行时即时定位与地图构建的问题。</p>
<p>当你身处异地，怎么准确找到想去的地方？在户外迷路时，怎么找到回家的路？没错，我们有导航软件和户外地图。</p>
<h4 id="1-选择地图"><a href="#1-选择地图" class="headerlink" title="1.选择地图"></a>1.选择地图</h4><p>和人类绘制地图一样，机器人描述环境、认识环境的过程主要就是依靠地图。它利用环境地图来描述其当前环境信息，并随着使用的算法与传感器差异采用不同的地图描述形式。</p>
<p>机器人学中地图的表示方法有四种：<strong>栅格地图、特征地图、直接表征法以及拓扑地图</strong>。</p>
<h5 id="（1）-栅格地图"><a href="#（1）-栅格地图" class="headerlink" title="（1）.栅格地图"></a>（1）.<strong>栅格地图</strong></h5><p>机器人对环境地图的描述的方式最常见的为栅格地图(Grid map)或者称为Occupancy Map。栅格地图就是把环境划分成一系列栅格，其中每一栅格给定一个可能值，表示该栅格被占据的概率。<br><img src="http://img.blog.csdn.net/20171112213014441?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>这种地图看起来和人们所认知的地图没什么区别，它最早由NASA的Alberto Elfes在1989年提出，在火星探测车上就用到过，其本质是一张位图图片，但其中每个“像素”则表示了实际环境中存在障碍物的概率分布。</p>
<p>一般来说，采用激光雷达、深度摄像头、超声波传感器等可以直接测量距离数据的传感器进行SLAM时，可以使用该地图。这种地图也可以通过距离测量传感器、超声波（早期）、激光雷达（现在）绘制出来。</p>
<h5 id="（2）-特征点地图"><a href="#（2）-特征点地图" class="headerlink" title="（2）.特征点地图"></a><strong>（2）.特征点地图</strong></h5><p>特征点地图，是用有关的几何特征（如点、直线、面）表示环境，常见于vSLAM（视觉SLAM）技术中。<br><img src="http://img.blog.csdn.net/20171112213152552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>相比栅格地图，这种地图看起来就不那么直观了。它一般通过如GPS、UWB以及摄像头配合稀疏方式的vSLAM算法产生，优点是相对数据存储量和运算量比较小，多见于最早的SLAM算法中。</p>
<h5 id="（3）-直接表征法"><a href="#（3）-直接表征法" class="headerlink" title="（3）.直接表征法"></a><strong>（3）.直接表征法</strong></h5><p>直接表征法中，省去了特征或栅格表示这一中间环节，直接用传感器读取的数据来构造机器人的位姿空间。</p>
<p><img src="http://img.blog.csdn.net/20171112213242871?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>上图就是直接记录了屋子内天花板画面的图像地图。这种方法就像卫星地图一样，直接将传感器原始数据通过简单处理拼接形成地图，相对来说更加直观。</p>
<h5 id="（4）-拓扑地图"><a href="#（4）-拓扑地图" class="headerlink" title="（4）.拓扑地图"></a><strong>（4）.拓扑地图</strong></h5><p>拓扑地图，是一种相对更加抽象的地图形式，它把室内环境表示为带结点和相关连接线的拓扑结构图，其中结点表示环境中的重要位置点（拐角、门、电梯、楼梯等），边表示结点间的连接关系，如走廊等。这种方法只记录所在环境拓扑链接关系，这类地图一般是由前几类地图通过相关算法提取得到。</p>
<p>比如扫地机器人要进行房间清扫的时候，就会建立这样的拓扑地图：<br><img src="http://img.blog.csdn.net/20171112213350432?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h5 id="（5）-小结"><a href="#（5）-小结" class="headerlink" title="（5）.小结"></a><strong>（5）.小结</strong></h5><p>在机器人技术中，SLAM的地图构建通常指的是建立与环境几何一致的地图。</p>
<p>一般算法中建立的<strong>拓扑地图</strong>只反映了环境中的各点连接关系，并不能构建几何一致的地图，因此，这些拓扑算法不能被用于SLAM。</p>
<p><strong>直接表征法</strong>类似卫星地图，它是直接使用传感器（一般是图像传感器）构建得到。这种方法的信息冗余度最大，对于数据存储是很大的挑战，同时，机器人要从中提取出有用的数据也要耗费一番周折，因此在实际应用中很少使用。</p>
<p><strong>特征点地图</strong>又是另一个极端，虽然数据量少，但是它往往不能反应所在环境的一些必须的信息，比如环境中障碍物的位置。vSLAM技术中，多采用这种地图来解决机器人定位问题。想让机器人进行自主避障和路径规划，还需要额外配置距离传感器，如激光雷达、超声波来完成。</p>
<p><strong>栅格地图</strong>，或者Occupancy Map（占据地图）恰好介于其中，一方面它能表示空间环境中的很多特征，机器人可以用它来进行路径规划，另一方面，它又不直接记录传感器的原始数据，相对实现了空间和时间消耗的最优。因此，栅格地图是目前机器人所广泛应用的地图存储方式。</p>
<p><img src="http://img.blog.csdn.net/20171112224222094?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="2-定位及传感器选择"><a href="#2-定位及传感器选择" class="headerlink" title="2.定位及传感器选择"></a>2.定位及传感器选择</h4><p>当你打开手机中的导航软件，在选择前往目的地的最佳路线之前，首先要做的动作是什么呢？没错，就是定位。我们要先知道自己在地图中的位置，才可以进行后续的路径规划。</p>
<p>在机器人实时定位问题中，由于通过机器人运动估计得到的机器人位置信息通常具有较大的误差，我们还需要使用测距单元得到的周围环境信息更正机器人的位置。</p>
<p>关于定位方案的选择，具体看这里：<a href="http://www.arduino.cn/thread-45526-1-1.html" target="_blank" rel="external">干货|服务机器人常用的定位导航技术及优缺点分析</a></p>
<p>目前，常见的测距单元包括激光测距、超声波测距以及图像测距三种。其中，凭借激光良好的指向性和高度聚焦性，<strong>激光雷达</strong>已经成为移动机器人的核心传感器，同时它也是目前最可靠、最稳定的定位技术。</p>
<p>自1988年被提出以来，SLAM的理论研究发展十分迅速。在实际应用时，除配备激光雷达外，还需要机器人具有IMU（惯性测量单元）、里程计来为激光雷达提供辅助数据，这一过程的运算消耗是巨大的，传统上需要PC级别的处理器，这也成为限制SLAM广泛应用的瓶颈之一。</p>
<h4 id="3-传感器数据预处理"><a href="#3-传感器数据预处理" class="headerlink" title="3.传感器数据预处理"></a>3.传感器数据预处理</h4><p>这是一个完整的SLAM和导航系统的主要架构图：</p>
<p><img src="http://img.blog.csdn.net/20171112215345477?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>其中，SLAM核心过程包括3个步骤，第一步称为<strong>预处理</strong>。我们知道，激光雷达和其他雷达设备一样，某一个时刻只能获取它所在位置的环境信息。</p>
<p>这就是我们所说的点云，它只能反映机器人所在环境中的一个部分。第一步预处理就是对激光雷达原始数据进行优化，剔除一些有问题的数据，或者进行滤波。</p>
<center><img src="http://img.blog.csdn.net/20171112215550615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></center>

<h4 id="4-匹配"><a href="#4-匹配" class="headerlink" title="4.匹配"></a>4.匹配</h4><p>第二步是<strong>匹配</strong>，也就是说把当前这一个局部环境的点云数据在已经建立地图上寻找到对应的位置，这个步骤非常关键。</p>
<center><img src="http://img.blog.csdn.net/20171112215731166?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></center>

<p>这个是ICP的点云匹配算法，用于实现匹配。说这个过程关键，就是因为它的好坏，直接影响了SLAM构建地图的精度。这个过程和我们玩拼图游戏有点类似，就是在已经拼好的画面中找到相似之处，确定新的一个拼图该放在哪里。</p>
<p>在SLAM过程中，需要将激光雷达当前采集的点云（红色部分）匹配拼接到原有地图中。</p>
<p><img src="http://img.blog.csdn.net/20171112220423025?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>如果不进行匹配过程，所构建的地图可能就乱成一团，变成这样。</p>
<p><img src="http://img.blog.csdn.net/20171112220456272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="5-地图融合"><a href="#5-地图融合" class="headerlink" title="5.地图融合"></a>5.地图融合</h4><p>在这个部分完毕以后，就进行第三步，<strong>地图融合</strong>，也就是将这一轮来自激光雷达的新数据拼接到原始地图当中，最终完成地图的更新。</p>
<p>就像这个图一样，这个过程是永远伴随SLAM过程的。</p>
<p><img src="http://img.blog.csdn.net/20171112220620581?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>数据融合和简单的贴图是有很大的差异的。因为实际上传感器描绘的世界存在一定的误差，或者正巧在这个时间环境有了变化，例如机器人旁边闯入了一只小猫。</p>
<p>因此，实际要进行的过程会更加复杂，需要用很多概率算法，并采用滤波的方式进行融合。将上述这个过程逐次执行，就最终产生了我们看到的栅格地图。</p>
<p><img src="http://img.blog.csdn.net/20171112220715666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="6-Loop-Closure（回环）问题"><a href="#6-Loop-Closure（回环）问题" class="headerlink" title="6.Loop Closure（回环）问题"></a>6.Loop Closure（回环）问题</h4><p>这个过程听起来其实并不复杂，但是要处理好有很大难度。这里举几个例子，比如叫做<strong>Loop Closure（回环）问题</strong>。如果匹配算法不足够优秀，或者环境中存在很不巧的干扰，当机器人绕着环境一圈后，就会发现原本是应该闭合的一个环形走廊断开了。</p>
<p>比如正常地图应该这样：</p>
<p><img src="http://img.blog.csdn.net/20171112220901937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>如果处理不好，实际地图就成这样：</p>
<p><img src="http://img.blog.csdn.net/20171112220931142?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>对于环境比较大的场景，回环问题是不得不面对的，但现实总是不完美的，即使是激光雷达这种高精度传感器，也难免存在误差。而回环问题的难点恰恰在于在一开始出现少许误差的时候，并不会被发觉，直到机器人绕着环路一圈，随着误差的累加，发现环路已经无法闭合时，此时已经酿成大错，一般很难回天。</p>
<p>当然这个问题并不是无解，一个好的商用化SLAM系统，回环问题是否能很好的解决，就成为评判这个系统实力的指标了。</p>
<p>这是前两天在『思岚科技』办公室进行的测试，左边的视频是基于开源的ROS机器人操作系统进行的地图构建，右边的是基于SLAMWARE构建的地图。</p>
<p>『视频暂缺』</p>
<p>当机器人已经绕场一周后，ROS构建的地图出现了中断，而SLAMWARE构建的地图是一个完美的闭环，它与我们办公室的设计图完美重合。</p>
<p><img src="http://img.blog.csdn.net/20171112221129621?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>除了算法层面的回环问题，SLAM实际应用中还有很多这种坑，比如<strong>走廊问题</strong>与<strong>外界干扰问题</strong>。</p>
<p>以外界干扰问题来说，通常，激光雷达作为机器人的眼睛，一般是安装在底盘上的，它能看到的视野很有限。当受到外界干扰（人类或者宠物等等）后，机器人很容易丢失定位精度，无法正常完成后续的建图工作。</p>
<p>当机器人安装SLAMWARE后，机器人受到干扰，可以完全不受影响，照样能够正常工作。</p>
<p>『视频暂缺』</p>
<p>目前，SLAM的开源实现代表多为学术界，实际应用有很多Corner Case要处理，需要传感器、系统参数、其他辅助设备的联合调优。</p>
<p>一般来说，上述的SLAM过程对于运算消耗是巨大的，虽然并没有达到像训练神经网络动用服务器集群那种地步，但传统上需要PC级别的处理器。</p>
<p>除配备激光雷达外，还需要机器人具有IMU（惯性测量单元）、里程计来为激光雷达提供辅助数据，否则SLAM系统也难以得到运行。总的来说，SLAM算法本身是一个对于外部系统有着多种依赖的算法，这是一个切实的工程问题。</p>
<h4 id="7-算法优化及商用"><a href="#7-算法优化及商用" class="headerlink" title="7.算法优化及商用"></a>7.算法优化及商用</h4><p>很多机器人，比如扫地机是不可能装一个PC进去的，为了让SLAM能在这类设备里运行，除了解决激光雷达成本外，还要对SLAM算法做出很好的优化。</p>
<blockquote>
<p>了解，不是本文主题：</p>
<p>这也是我们思岚科技SLAMTEC主要的努力方向，一方面，我们这7年多很好的解决了各类实际SLAM算法难点，另一方面，我们把SLAM这个复杂的系统做了很大的优化，可以放到一个硬币那么大的模块内部，降低尺寸功耗。此外，它还集成了IMU等配套传感器，力求做到对于SLAM的使用便捷性。</p>
</blockquote>
<h3 id="1-2-2-路径规划"><a href="#1-2-2-路径规划" class="headerlink" title="1.2.2.路径规划"></a>1.2.2.路径规划</h3><p>那么，机器人利用SLAM技术得到了有效的空间信息后，它是怎样实现路径规划的？SLAM和路径规划之间关系是怎样的？</p>
<p><img src="http://img.blog.csdn.net/20171112221822109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>实际上，SLAM算法本身只是完成了机器人的<strong>定位和地图构建</strong>两件事情，与我们说的<strong>导航定位</strong>并不是完全等价的。这里的导航，其实是SLAM算法做不了的。它在业内叫做<strong>运动规划(Motion Planning)</strong>。</p>
<p><strong>运动规划</strong>是一个很大的概念，从机械臂的运动、到飞行器的飞行，再到这里我们说的扫地机的清扫<strong>路径规划，都是运动规划的范畴</strong>。</p>
<p>我们先谈谈针对扫地机这类轮式机器人的运动规划。这里所需的基础能力就是<strong>路径规划</strong>，也就是一般在完成SLAM后，要进行一个叫做目标点导航的能力。通俗的说，就是规划一条从A点到B点的路径出来，然后让机器人移动过去。</p>
<p><img src="http://img.blog.csdn.net/20171112222723876?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="1-全局规划"><a href="#1-全局规划" class="headerlink" title="1.全局规划"></a>1.全局规划</h4><p>要实现这个过程，运动规划要实现至少两个层次的模块，一个叫做<strong>全局规划</strong>，这个和我们车载导航仪有一点像，它需要在地图上预先规划一条线路，也要有当前机器人的位置。这是由我们的SLAM系统提供出来的。行业内一般会用叫做<strong>A*</strong>的算法来实现这个过程，它是一种启发式的搜索算法，非常优秀。它最多的应用，是在游戏中，比如像星际争霸、魔兽争霸之类的即时战略游戏，都是使用这个算法来计算单位的运动轨迹的。</p>
<h4 id="2-局部规划"><a href="#2-局部规划" class="headerlink" title="2.局部规划"></a>2.局部规划</h4><p>当然，仅仅规划了路径还是不够的，现实中会有很多突发情况，比如正巧有个小孩子挡道了，就需要调整原先的路径。当然，有时候这种调整并不需要重新计算一遍全局路径，机器人可能稍微绕一个弯就可以。此时，我们就需要另一个层次的规划模块，叫做<strong>局部规划</strong>。它可能并不知道机器人最终要去哪，但是对于机器人怎么绕开眼前的障碍物特别在行。</p>
<h4 id="3-已知地图（A）与未知地图（D）算法"><a href="#3-已知地图（A）与未知地图（D）算法" class="headerlink" title="3.已知地图（A）与未知地图（D）算法"></a>3.已知地图（A<em>）与未知地图（D</em>）算法</h4><p>这两个层次的规划模块协同工作，机器人就可以很好的实现从A点到B点的行动了，不过实际工作环境下，上述配置还不够。比如<strong>A＊算法规划的路径是根据已知地图，预先规划好的</strong>，一旦机器人前往目的地的过程中遇到了新的障碍物，就只好完全停下来，等待障碍物离开或者重新规划路径了。如果扫地机器人买回家，必须先把屋子都走一遍以后才肯扫地，那用户体验就会很差。</p>
<p>为此，也会有针对这类算法的改进，比如SLAMWARE内我们采用改良的<strong>D*算法</strong>进行路径规划，这也是美国火星探测器采用的核心寻路算法。<strong>这是一种动态启发式路径搜索算法，它让机器人在陌生环境中行动自如，在瞬息万变的环境中游刃有余。</strong></p>
<p><strong>D*算法的最大优点是不需要预先探明地图，机器人可以和人一样，即使在未知环境中，也可以展开行动，随着机器人不断探索，路径也会时刻调整。</strong></p>
<h4 id="4-空间覆盖（space-coverage）"><a href="#4-空间覆盖（space-coverage）" class="headerlink" title="4.空间覆盖（space coverage）"></a>4.空间覆盖（space coverage）</h4><p>以上是目前大部分移动机器人都需要的路径规划算法，而扫地机器人作为最早出现在消费市场的服务机器人之一，它需要的路径规划算法更为复杂。</p>
<p>一般来说，扫地机需要这么几个规划能力：贴边打扫、折返的工字形清扫以及没电时候自主充电。单单依靠前面介绍的D*这类算法，无法满足这些基础需要。</p>
<p>扫地机器人还需要有额外的规划算法，比如针对折返的工字形清扫，有很多问题要处理。扫地机如何最有效进行清扫而不重复清扫？如何让扫地机和人一样，理解房间、门、走廊这种概念？</p>
<p>针对这些问题，学术界长久以来有一个专门的研究课题，叫做空间覆盖（space coverage），同时也提出了非常多的算法和理论。其中，比较有名的是Morse Decompositions，扫地机通过它实现对空间进行划分，随后进行清扫。</p>
<p><img src="http://img.blog.csdn.net/20171112223348348?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>20世纪70年代，卡内基梅陇大学（CMU）完全依靠超声波做到了现在我们扫地机的行为，当然造价也十分昂贵。</p>
<p><img src="http://img.blog.csdn.net/20171112223518498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>前面介绍的从A点到B点移动路径规划也是实现这类更高级路径规划的基础。实际上，要从SLAM实现到扫地机器人所需要的这些功能，还是有非常多的工作要做的。</p>
<blockquote>
<p>了解，不是主题</p>
<p>针对扫地机器人，我们将其特有的路径规划功能预先内置在SLAMWARE中，方便厂家进行整合，不需要进行二次开发。</p>
</blockquote>
<p>参考：<a href="http://www.arduino.cn/thread-46394-1-1.html" target="_blank" rel="external">http://www.arduino.cn/thread-46394-1-1.html</a><br><a href="http://www.arduino.cn/thread-46541-1-1.html" target="_blank" rel="external">http://www.arduino.cn/thread-46541-1-1.html</a><br><a href="http://www.arduino.cn/thread-46992-1-1.html" target="_blank" rel="external">http://www.arduino.cn/thread-46992-1-1.html</a><br><a href="http://www.arduino.cn/thread-45526-1-1.html" target="_blank" rel="external">http://www.arduino.cn/thread-45526-1-1.html</a></p>
<p>扩展阅读：<a href="http://blog.sina.com.cn/s/blog_bee56e800102wbpk.html" target="_blank" rel="external">机器人自主导航四大方案</a></p>
<p><a href="http://www.robot-china.com/news/201707/10/42910.html" target="_blank" rel="external">自主定位导航技术的现状和未来应用趋势</a></p>
<h2 id="1-3基于深度学习的自主导航"><a href="#1-3基于深度学习的自主导航" class="headerlink" title="1.3基于深度学习的自主导航"></a>1.3基于深度学习的自主导航</h2><p>V SLAM 还是 LIDAR SLAM？</p>
<p>　　最后讲一下未来导航定位系统的发展趋势。</p>
<blockquote>
<p><a href="http://www.computervisionblog.com/2016/01/why-slam-matters-future-of-real-time.html" target="_blank" rel="external">这篇博客解释了SLAM和Deep Learning的关系，写得非常仔细。</a></p>
</blockquote>
<p>　　对于 V SLAM 和 LIDAR SLAM 谁更重要的问题，实际上是一个融合的过程。这两种技术都有优缺点，激光的缺点毋庸置疑，传统激光雷达很贵，第二很多方面不大灵活，目前为止，传感器还不成熟。对环境光影的变化或者室内比较昏暗的场景，V SLAM技术都没办法使用，但如果把这两种 SLAM 技术融合在一起，并且配以目前低成本的传感器，这种融合式的 SLAM 方式会是未来比较重要的趋势。</p>
<p>　　提取语义信息，也是配合视觉激光做的。目前绘制的地图还比较平级，通过采集图象数据和深度学习，可以主动在地图上进行标记，就可以避开前面提到的人工 POI 标注过程。</p>
<p>　　前行业中还有一个趋势——深度学习。这一两年，深度学习成为人工智能的代名词。在这个行业，前几年还是以比较传统的概率学，或者控制论的方式进行机器人自主定位导航。但这里展现的是完全通过深度学习，直接通过摄像头数据作为信号输入，再通过神经网络直接产生出机器人的控制信号。其中像 SLAM 的过程、路径规划的过程，完全通过学习的方式就可以进行实现。</p>
<p>　　我认为这种技术可能会成为未来的一种潮流，但是不是在有限的将来，在实际产品中进行体现，还是需要给予时日。但不变的是，在行业中取长补短，结合不同新的技术进行融合，这是不会改变的事实。<br>　　<br>　　从目前的研究情况来看，深度学习在SLAM这个问题上还没有完全取代传统方法的能力。希望各位同僚继续努力！跳出SLAM，说点题外话，利用深度强化学习来进行端对端的机器人导航，已经有了不错的结果。人类在环境中导航，不也是直接输入image，输出action吗？有兴趣的可以看看这两篇文章：</p>
<p>(1) <a href="https://sites.google.com/view/cognitive-mapping-and-planning/" target="_blank" rel="external">[1702.03920] Cognitive Mapping and Planning for Visual Navigation</a></p>
<p><a href="https://www.sohu.com/a/126513259_465975" target="_blank" rel="external">《视觉导航的认知映射与规划 》</a></p>
<blockquote>
<p>摘要<br>我们介绍了一种用于在全新的环境中导航的神经架构。我们提出的架构可以学习根据第一人称视角构建地图（mapping）和在环境中规划（planning）到达目的地的动作序列。这个认知型地图构建器和规划器（CMP/Cognitive Mapper and Planner）基于两个关键思想：a）一个用于地图构建和规划的统一联合架构，这样使得该地图构建可由规划者的需求来驱动；b）一个可以在关于世界的观察集合不完整时能够进行规划的空间记忆。CMP 能构建一个自上而下的关于世界的可信度地图（belief map）并应用一个可微神经网络规划器来在每一个时间步骤产生下一个动作。这种关于世界的积累的可信度使得该代理（agent）能够跟踪其环境中已经访问过的区域。我们的实验表明该 CMP 的表现超过了反应策略（reactive strategies）和标准的基于记忆的架构，并且可以在全新的环境中获得良好的表现。此外，我们还表明 CMP 也能够实现特定语义的目标，比如「go to a chair」。</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20171113163838058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>(2) 当然，DL 在 navigation 方面也已经有一些研究了，例如 Feifei Li 实验室的工作：通过 DRL 实现机器人自主导航。</p>
<p><a href="https://arxiv.org/abs/1609.05143" target="_blank" rel="external">[1609.05143] Target-driven Visual Navigation in Indoor Scenes using Deep Reinforcement Learning</a></p>
<p><a href="http://www.jianshu.com/p/1ef3cebe366e" target="_blank" rel="external">《基于深度增强的室内场景目标驱动视觉导航 》</a></p>
<p>但是，目前所有这些工作都存在一个问题：只是训练出一个 local planner，无法实现全局的路径规划。所以，我个人认为，「用 DL 学习到全局的信息，进而引导 navigation」，会比「尝试用 DL 建立精确的地图，之后用这个地图进行 navigation」更有前景。未来，可能就没有 SLAM + navigation 这种框架了。</p>
<blockquote>
<p>摘要<br>两个较少的深层强化学习问题是：（1）缺乏对新的目标目标的泛化能力;（2）数据低效率，即模型需要几次（通常是昂贵的）尝试和错误的聚合，这使得它不切实际 应用于真实世界的场景。 在本文中，我们解决这两个问题，并将我们的模型应用于目标驱动的视觉导航任务。 为了解决第一个问题，我们提出了一个行为者 - 评论者模型，其政策是目标的功能以及当前状态，从而能够更好地概括。 为了解决第二个问题，我们提出了AI2-THOR框架，它提供了一个高质量的3D场景和物理引擎的环境。 我们的框架使代理能够采取行动并与对象进行交互。 因此，我们可以高效地收集大量的训练样本。</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20171113165826756?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>（3） <a href="http://xueshu.baidu.com/s?wd=paperuri:%28f25e0510cc61360db434474c94a01677%29&amp;filter=sc_long_sign&amp;tn=SE_xueshusource_2kduw22v&amp;sc_vurl=http://arxiv.org/abs/1611.03673&amp;ie=utf-8&amp;sc_us=1983469550890279566" target="_blank" rel="external">Mirowski, Piotr, et al. （Learning to navigate in complex environments.）</a></p>
<p><a href="http://blog.csdn.net/mrhcat/article/details/71267200" target="_blank" rel="external">在复杂环境中学习导航</a><br><a href="http://www.rosclub.cn/post-628.html" target="_blank" rel="external">http://www.rosclub.cn/post-628.html</a></p>
<blockquote>
<p>摘要<br>学习在具有动态元素的复杂环境中进行导航是开发AI代理的重要里程碑。 在这项工作中，我们将导航问题作为一个强化学习问题，并且表明通过利用多模式感官输入的附加辅助任务可以显着提高数据效率和任务性能。 具体而言，我们考虑联合学习目标驱动强化学习问题与辅助深度预测和闭环分类任务。 这种方法可以学习从复杂的3D迷宫中的原始感官输入导航，即使在目标位置经常变化的情况下也能接近人类的表现。 我们对代理行为，本地化能力和网络活动动态进行详细的分析，显示代理隐式学习关键导航能力。</p>
</blockquote>
<p>（4）ETH 室内导航：<a href="https://arxiv.org/abs/1609.07910" target="_blank" rel="external">From Perception to Decision: A Data-driven Approach to End-to-end Motion Planning for Autonomous Ground Robots</a><br>从感知到决策：一种基于数据驱动的端到端运动规划方法 </p>
<p>（5）CMU 无人机穿越森林：<a href="https://arxiv.org/pdf/1211.1690.pdf" target="_blank" rel="external">Learning Monocular Reactive UAV Control in Cluttered Natural Environments</a><br>学习单目无功无人机控制在复杂的自然环境 </p>
<p>（6）<a href="https://mp.weixin.qq.com/s?__biz=MzA5MDE2MjQ0OQ==&amp;mid=2652786682&amp;idx=1&amp;sn=21e1a64a2a47c865cb73c381c3f10001&amp;chksm=8be53b84bc92b292e841e7cb15e425763a72751806b5a942d2508d286b7eff383053e05f9eac#rd" target="_blank" rel="external">运动规划 | 视频篇</a> </p>
<blockquote>
<p>了解<br>你好，答主好，我也想做基于dp的自动驾驶的运动规划。现在自动驾驶的决策主要分成四层来完成：1.大路线规划；2.汽车行为决策（变道/减速等）；3.路径/轨迹规划；4.轨迹跟随控制。目前4已经完全没问题了，3也有很多完全并可靠的算法，而在2中的难点主要在于其他交通参与者的运动意图预测，这里是机器学习切入的地方，也是四个层面中最契合机器学习的，其他部分现有的算法已经足够好并且可靠。而运动意图预测似乎更像是cs的活，距离运动规划比较远了。因此我很犹豫下一步研究方向该怎么走。想和二位讨论一下。</p>
</blockquote>
<p>（7）第一期我们与大家分享的是苏黎世大学Davide Scaramuzza教授研究团队的最新成果——基于深度神经网络利用单目视觉帮助无人机穿过森林小道。这项研究入选理由是迄今为止第一次实现了基于机载硬件在真实林间小路上实时地规划和控制。<a href="https://mp.weixin.qq.com/s/oTGC8i0NKGi-ad7TlfsRfg" target="_blank" rel="external">https://mp.weixin.qq.com/s/oTGC8i0NKGi-ad7TlfsRfg</a></p>
<p>(8)<a href="https://arxiv.org/abs/1705.02550" target="_blank" rel="external">Toward Low-Flying Autonomous MAV Trail Navigation using Deep Neural Networks for Environmental Awareness</a></p>
<p>（9）<a href="https://github.com/cometa/Autonomia" target="_blank" rel="external">https://github.com/cometa/Autonomia</a></p>
<p>（10）<a href="https://github.com/RyanZotti/Self-Driving-Car" target="_blank" rel="external">https://github.com/RyanZotti/Self-Driving-Car</a></p>
<p>（11）<a href="https://github.com/DJTobias/Cherry-Autonomous-Racecar" target="_blank" rel="external">https://github.com/DJTobias/Cherry-Autonomous-Racecar</a></p>
<p>（12）<a href="https://github.com/hamuchiwa/AutoRCCar" target="_blank" rel="external">https://github.com/hamuchiwa/AutoRCCar</a></p>
]]></content>
      
        <categories>
            
            <category> 自主导航 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DL </tag>
            
            <tag> 导航 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python笔记]]></title>
      <url>/2017/10/26/python/python%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="1-ubuntu-14-04-打开Python2-7-IDLE"><a href="#1-ubuntu-14-04-打开Python2-7-IDLE" class="headerlink" title="1.ubuntu 14.04 打开Python2.7 IDLE"></a>1.ubuntu 14.04 打开Python2.7 IDLE</h2><p>直接在命令行中输入idle，如果系统已经安装，将打开idle，否则提示安装idle。</p>
<p>安装idle命令 sudo apt-get install idle</p>
<p>然后再输入idle就可以用idle编辑Python程序了</p>
<h2 id="2-Python3-4-IDLE"><a href="#2-Python3-4-IDLE" class="headerlink" title="2.Python3.4 IDLE"></a>2.Python3.4 IDLE</h2><p>1.在Ubuntu14.04 LTS版本中，已经自行安装了python，可以在Terminal（CTRL+ALT+T）中输入：ls /usr/bin | grep python 进行查看。</p>
<p>如果想运行python2.7的话，直接在终端输入：python即可。</p>
<p>如果想运行python3.4的话，直接在终端输入：python3即可。</p>
<p>2.Ubuntu14.04 LTS中的python是没有自带IDLE的，可以在终端输入：sudo apt-get install idle-python3.4，进行python3.4版本的IDLE的安装，安装好之后直接在/usr/share/applications，就可以找到IDLE的图标，直接将其复制到桌面上，以后直接在桌面双击就可以启动。</p>
<p>或者在终端输入：/usr/bin/idle-python3.4即可启动。</p>
<h2 id="3-在Ubuntu-14-04-64bit上安装numpy和matplotlib库"><a href="#3-在Ubuntu-14-04-64bit上安装numpy和matplotlib库" class="headerlink" title="3.在Ubuntu 14.04 64bit上安装numpy和matplotlib库"></a>3.在Ubuntu 14.04 64bit上安装numpy和matplotlib库</h2><p>原创 2015年03月01日 19:19:51</p>
<pre><code>标签：
numpy /
matplotlib
</code></pre><p>机器学习是数据挖掘的一种实现形式，在学习《机器学习实战》过程中,需要python环境中安装好numpy和matplotlib库,特此将我在Ubuntu 14.04 64bit上的摸索过程总结如下:</p>
<p>书上的建议是:</p>
<p>在Debian/Ubuntu系统下安装Python, Numpy和Matplotlib的最佳方式是使用apt-get等软件包管理器. 避免源码包形式的安装, 因为包的依赖关系较难处理.</p>
<p>安装numpy只需要输入下面的命令:</p>
<p>sudo apt-get install python-numpy</p>
<p>sudo apt-get install python-scipy</p>
<p>在确保上面两个安装正确的情况下, 再安装matplotlib库，注意</p>
<p>安装matplotlib方式有很多，最好的方式就是和你使用的操作系统、你已经安装了的软件以及你想怎么使用它紧密结合。</p>
<p>sudo apt-get python-matplotlib</p>
<h2 id="4-一、python单行注释符号"><a href="#4-一、python单行注释符号" class="headerlink" title="4. 一、python单行注释符号(#)"></a>4. 一、python单行注释符号(#)</h2><p>井号(#)常被用作单行注释符号，在代码中使用#时，它右边的任何数据都会被忽略，当做是注释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print 1 #输出1</div></pre></td></tr></table></figure></p>
<p><code>#</code>号右边的内容在执行的时候是不会被输出的。<br>二、批量、多行注释符号</p>
<p>在python中也会有注释有很多行的时候，这种情况下就需要批量多行注释符了。多行注释是用三引号<code>&#39;&#39;&#39;   &#39;&#39;&#39;</code>包含的，例如：</p>
<h2 id="5-Python中的Numpy入门教程-http-www-jb51-net-article-49397-htm"><a href="#5-Python中的Numpy入门教程-http-www-jb51-net-article-49397-htm" class="headerlink" title="5.Python中的Numpy入门教程:http://www.jb51.net/article/49397.htm"></a>5.Python中的Numpy入门教程:<a href="http://www.jb51.net/article/49397.htm" target="_blank" rel="external">http://www.jb51.net/article/49397.htm</a></h2><h2 id="6-Ubuntu-Python2-7安装-scipy-numpy-matplotlib-pygame"><a href="#6-Ubuntu-Python2-7安装-scipy-numpy-matplotlib-pygame" class="headerlink" title="6.Ubuntu-Python2.7安装 scipy,numpy,matplotlib,pygame"></a>6.Ubuntu-Python2.7安装 scipy,numpy,matplotlib,pygame</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install python-scipy</div><div class="line"></div><div class="line">sudo apt-get install python-numpy</div><div class="line"></div><div class="line">sudo apt-get install python-matplotlib</div><div class="line"></div><div class="line">sudo apt-get install python-pandas</div><div class="line"></div><div class="line">sudo apt-get install python-sklearn</div><div class="line"></div><div class="line">sudo apt-get install python-pygame</div><div class="line"></div><div class="line">python</div><div class="line"></div><div class="line">import scipy</div><div class="line"></div><div class="line">import numpy</div><div class="line"></div><div class="line">import pylab</div><div class="line"></div><div class="line">scipy.test()</div><div class="line"></div><div class="line">numpy.test()</div><div class="line"></div><div class="line">pylab.test()</div><div class="line"></div><div class="line">import pandas as pd</div><div class="line"></div><div class="line">import matplotlib.pyplot as plt</div><div class="line"></div><div class="line">from sklearn import datasets,linear_model</div></pre></td></tr></table></figure>
<h2 id="7-ubuntu下安装anaconda-http-blog-csdn-net-zhdgk19871218-article-details-46502637"><a href="#7-ubuntu下安装anaconda-http-blog-csdn-net-zhdgk19871218-article-details-46502637" class="headerlink" title="7.ubuntu下安装anaconda:http://blog.csdn.net/zhdgk19871218/article/details/46502637"></a>7.ubuntu下安装anaconda:<a href="http://blog.csdn.net/zhdgk19871218/article/details/46502637" target="_blank" rel="external">http://blog.csdn.net/zhdgk19871218/article/details/46502637</a></h2>]]></content>
      
        <categories>
            
            <category> python基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu显示正在运行的程序，并结束它]]></title>
      <url>/2017/10/07/linux/ubuntu%E6%98%BE%E7%A4%BA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%B9%B6%E7%BB%93%E6%9D%9F%E5%AE%83/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">top  //显示正在运行的程序</div><div class="line">kill 2951 //QQ的PID</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~$ top</div><div class="line"></div><div class="line">top - 22:17:51 up  6:15,  2 users,  load average: 1.27, 1.06, 1.04</div><div class="line">Tasks: 253 total,   1 running, 252 sleeping,   0 stopped,   0 zombie</div><div class="line">%Cpu(s):  7.9 us,  7.5 sy,  0.0 ni, 84.0 id,  0.6 wa,  0.0 hi,  0.0 si,  0.0 st</div><div class="line">KiB Mem:   3903164 total,  3734824 used,   168340 free,    47180 buffers</div><div class="line">KiB Swap:  7811068 total,    87292 used,  7723776 free.  1018796 cached Mem</div><div class="line"></div><div class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     </div><div class="line"> 3422 kuo       20   0 2686968  35252  12816 S  22.6  0.9  36:56.74 Tencentdl.+ </div><div class="line"> 2863 kuo       20   0   12988  10152   1820 S  11.6  0.3  17:13.79 wineserver  </div><div class="line"> 2653 kuo       20   0 3468032 1.095g 127236 S  10.3 29.4  40:19.60 firefox     </div><div class="line"> 2951 kuo       20   0 2815056 195092  16184 S  10.0  5.0  14:59.99 QQ.exe      </div><div class="line"> 1097 root      20   0  421520  92348  64544 S   6.0  2.4   6:19.10 Xorg        </div><div class="line"> 2293 kuo       20   0 1565044 181860  58572 S   5.3  4.7   5:34.90 compiz      </div><div class="line"> 9526 kuo       20   0  917404 106284  48116 S   1.7  2.7   0:00.91 plugin-con+ </div><div class="line"> 5925 kuo       20   0  668168  29608  22464 S   1.3  0.8   0:03.04 gnome-term+ </div><div class="line"> 2797 kuo       20   0 1537728 190628  21608 S   0.7  4.9   2:06.03 lantern     </div><div class="line"> 8797 kuo       20   0  131604  39300  17132 S   0.7  1.0   0:15.68 idle-pytho+ </div><div class="line"> 8810 kuo       20   0  225364  33524  13000 S   0.7  0.9   0:13.28 python3.4   </div><div class="line">  548 root     -51   0       0      0      0 S   0.3  0.0   0:19.53 irq/28-iwl+ </div><div class="line"> 2232 kuo       20   0  124928   4692   4492 S   0.3  0.1   0:01.88 at-spi2-re+ </div><div class="line"> 8084 root      20   0       0      0      0 S   0.3  0.0   0:00.65 kworker/1:1 </div><div class="line">    1 root      20   0   33788   3900   2596 S   0.0  0.1   0:01.09 init        </div><div class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kthreadd    </div><div class="line">    3 root      20   0       0      0      0 S   0.0  0.0   0:00.26 ksoftirqd/0 </div><div class="line">[1]+  已停止               top</div><div class="line">kuo@kuo-Inspiron-7420:~$ kill 2951</div><div class="line">kuo@kuo-Inspiron-7420:~$ top</div><div class="line"></div><div class="line">top - 22:18:19 up  6:16,  2 users,  load average: 1.18, 1.06, 1.04</div><div class="line">Tasks: 253 total,   2 running, 250 sleeping,   1 stopped,   0 zombie</div><div class="line">%Cpu(s):  9.0 us,  5.5 sy,  0.0 ni, 85.1 id,  0.4 wa,  0.0 hi,  0.0 si,  0.0 st</div><div class="line">KiB Mem:   3903164 total,  3502908 used,   400256 free,    47396 buffers</div><div class="line">KiB Swap:  7811068 total,    87292 used,  7723776 free.  1019720 cached Mem</div><div class="line"></div><div class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     </div><div class="line"> 3422 kuo       20   0 2686968  36296  13872 S  23.3  0.9  37:03.28 Tencentdl.+ </div><div class="line"> 2653 kuo       20   0 3459840 1.046g 127236 R  19.6 28.1  40:24.23 firefox     </div><div class="line"> 2293 kuo       20   0 1565040 181860  58572 S   5.6  4.7   5:36.36 compiz      </div><div class="line"> 1097 root      20   0  419512  91268  63464 S   5.3  2.3   6:20.40 Xorg        </div><div class="line"> 2863 kuo       20   0   12988  10152   1820 S   3.3  0.3  17:15.36 wineserver  </div><div class="line"> 5925 kuo       20   0  668104  29552  22464 S   2.0  0.8   0:03.44 gnome-term+ </div><div class="line"> 9526 kuo       20   0  917404 106332  48116 S   1.7  2.7   0:01.47 plugin-con+ </div><div class="line"> 2797 kuo       20   0 1537728 190628  21608 S   1.0  4.9   2:06.34 lantern     </div><div class="line"> 8797 kuo       20   0  131604  39300  17132 S   1.0  1.0   0:15.90 idle-pytho+ </div><div class="line"> 8810 kuo       20   0  225364  33524  13000 S   1.0  0.9   0:13.47 python3.4   </div><div class="line">  548 root     -51   0       0      0      0 S   0.3  0.0   0:19.58 irq/28-iwl+ </div><div class="line"> 2232 kuo       20   0  124928   4692   4492 S   0.3  0.1   0:01.89 at-spi2-re+ </div><div class="line"> 9552 kuo       20   0   29164   3092   2512 R   0.3  0.1   0:00.07 top         </div><div class="line">    1 root      20   0   33788   3900   2596 S   0.0  0.1   0:01.09 init        </div><div class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kthreadd    </div><div class="line">    3 root      20   0       0      0      0 S   0.0  0.0   0:00.27 ksoftirqd/0 </div><div class="line">    5 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:+ </div><div class="line">kuo@kuo-Inspiron-7420:~$</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu 下查看caj文件]]></title>
      <url>/2017/10/07/linux/ubuntu%20%E4%B8%8B%E6%9F%A5%E7%9C%8Bcaj%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>知网的学位论文只有CAJ版，而我又偏偏使用Ubuntu，所以就有了这篇文章。</p>
<p>前端时间发现第一种方法在ubuntu 16 上不行， 请使用第二种方法。</p>
<h1 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h1><p>环境：Ubuntu 14.04 64bit</p>
<p>1.安装wine：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install wine</div></pre></td></tr></table></figure></p>
<p>2.下载caj6.0绿色版CAJViewer6.0_green.rar： <a href="http://pan.baidu.com/s/1mhwEvAK" target="_blank" rel="external">http://pan.baidu.com/s/1mhwEvAK</a></p>
<p>3.解压到目录cajviewer6.0：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir cajviewer6.0</div><div class="line">unrar x CAJViewer6.0_green.rar cajviewer6.0</div></pre></td></tr></table></figure></p>
<p>4.运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo chmod u+x CAJViewer.exe //修改权限</div><div class="line">wine CAJViewer.exe</div></pre></td></tr></table></figure></p>
<p>===============================================================</p>
<h1 id="第二种方法："><a href="#第二种方法：" class="headerlink" title="第二种方法："></a>第二种方法：</h1><p>前段时间发现用Ubuntu16.04上边的这种不行了，请使用下边的方法：</p>
<p>下载链接： <a href="http://pan.baidu.com/s/1jIqHxLs" target="_blank" rel="external">http://pan.baidu.com/s/1jIqHxLs</a></p>
<p>　　　　　　或 <a href="http://download.csdn.net/detail/arhaiyun/5457947" target="_blank" rel="external">http://download.csdn.net/detail/arhaiyun/5457947</a></p>
<p>压缩包里边有安装说明，这里边是7.2 的cajviewer版本。亲测可用。</p>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[E_ 软件包 ffmpeg 没有可供安装的候选者]]></title>
      <url>/2017/10/06/linux/E_%20%E8%BD%AF%E4%BB%B6%E5%8C%85%20ffmpeg%20%E6%B2%A1%E6%9C%89%E5%8F%AF%E4%BE%9B%E5%AE%89%E8%A3%85%E7%9A%84%E5%80%99%E9%80%89%E8%80%85/</url>
      <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/OpenCV/opencv/release$ sudo apt-get install libopencv-dev build-essential checkinstall cmake pkg-config yasm libtiff4-dev libjpeg-dev libjasper-dev libavcodec-dev libavformat-dev libswscale-dev libdc1394-22-dev libxine-dev libgstreamer0.10-dev libgstreamer-plugins-base0.10-dev libv4l-dev python-dev python-numpy libtbb-dev libqt4-dev libgtk2.0-dev libfaac-dev libmp3lame-dev libopencore-amrnb-dev libopencore-amrwb-dev libtheora-dev libvorbis-dev libxvidcore-dev x264 v4l-utils ffmpeg</div><div class="line">正在读取软件包列表... 完成</div><div class="line">正在分析软件包的依赖关系树       </div><div class="line">正在读取状态信息... 完成       </div><div class="line">现在没有可用的软件包 ffmpeg，但是它被其它的软件包引用了。</div><div class="line">这可能意味着这个缺失的软件包可能已被废弃，</div><div class="line">或者只能在其他发布源中找到</div><div class="line"></div><div class="line">E: 软件包 ffmpeg 没有可供安装的候选者</div></pre></td></tr></table></figure>
<h1 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h1><p>E: 软件包 gstreamer0.10-ffmpeg 没有可供安装的候选者</p>
<p>好吧，装不上来，因为在Ubuntu上gstreamer0.10-ffmpeg属于额外的版权受限程序，gstreamer0.10-ffmpeg包可通过一些第三方的PPA源，但是<br>所有您需要做的就是添加PPA到您的系统，更新本地存储索引和安装gstreamero.10-ffmpeg包。如下输入命令：</p>
<p>sudo add-apt-repository ppa:mc3man/trusty-media<br>sudo apt-get update<br>sudo apt-get install gstreamer0.10-ffmpeg</p>
<p>这样终于安装上来，测试来下程序也没有解码的问题。</p>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Ubuntu 16.04下安装Matlab 2017a]]></title>
      <url>/2017/10/06/linux/%E5%9C%A8Ubuntu%2016.04%E4%B8%8B%E5%AE%89%E8%A3%85Matlab%202017a/</url>
      <content type="html"><![CDATA[<h2 id="1-在Ubuntu-16-04下安装Matlab-2017a"><a href="#1-在Ubuntu-16-04下安装Matlab-2017a" class="headerlink" title="1.在Ubuntu 16.04下安装Matlab 2017a"></a>1.在Ubuntu 16.04下安装Matlab 2017a</h2><p><a href="http://blog.csdn.net/u011713358/article/details/69659265" target="_blank" rel="external">http://blog.csdn.net/u011713358/article/details/69659265</a></p>
<h2 id="2-在Linux（Ubuntu）用alias命令设置永久别名"><a href="#2-在Linux（Ubuntu）用alias命令设置永久别名" class="headerlink" title="2.在Linux（Ubuntu）用alias命令设置永久别名"></a>2.在Linux（Ubuntu）用alias命令设置永久别名</h2><p><a href="http://jingyan.baidu.com/article/22fe7ced17c1543002617f9c.html" target="_blank" rel="external">http://jingyan.baidu.com/article/22fe7ced17c1543002617f9c.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias matlab=&apos;sudo /home/&lt;user name&gt;/Matlab/install&apos;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在 Ubuntu14.04 上部署 Hexo+Node.js 到 Github 和 coding 和 gitee]]></title>
      <url>/2017/10/06/linux/%E5%9C%A8%20Ubuntu14.04%20%E4%B8%8A%E9%83%A8%E7%BD%B2%20Hexo+Node.js%20%E5%88%B0%20Github%20%E5%92%8C%20coding%20%E5%92%8C%20gitee/</url>
      <content type="html"><![CDATA[<h2 id="1-在-Ubuntu14-04-上部署-Hexo-到-Github"><a href="#1-在-Ubuntu14-04-上部署-Hexo-到-Github" class="headerlink" title="1.在 Ubuntu14.04 上部署 Hexo 到 Github"></a>1.在 Ubuntu14.04 上部署 Hexo 到 Github</h2><p>首先部署到github上，用下边的就行：<br><a href="http://www.leyar.me/create-a-blog-with-hexo-in-ubuntu/" target="_blank" rel="external">在 Ubuntu14.04 上部署 Hexo 到 Github</a></p>
<p>这里仅仅是将网页部署到github上了，下边部署到gitee和coding上。</p>
<h2 id="2-首先是创建同名库问题"><a href="#2-首先是创建同名库问题" class="headerlink" title="2.首先是创建同名库问题"></a>2.首先是创建同名库问题</h2><ul>
<li><p>github：username.github.io</p>
</li>
<li><p>coding：username.coding.me </p>
</li>
<li><p>gitee（码云）：username 【这个直接就是用户名】 </p>
</li>
</ul>
<p>然后在仓库中分别再创建一个分支<code>hexo</code>并设置为主分支，用来存储所有文件，而<code>master</code>用来存储生成的网页文件。</p>
<h2 id="3-然后是部署到gitee和coding上"><a href="#3-然后是部署到gitee和coding上" class="headerlink" title="3.然后是部署到gitee和coding上"></a>3.然后是部署到gitee和coding上</h2><p>这里仅需重点修改<code>_config.yml</code>：<br>重点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repository:</div><div class="line">      github: git@github.com:ShomyLiu/ShomyLiu.github.io.git</div><div class="line">      coding: git@git.coding.net:shomyliu/shomyliu.git</div><div class="line">      gitee: git@gitee.com:XiongDeMiao/xiongdemiao.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<p>然后是同终端多git帐号问题。</p>
<h2 id="4-同终端多git帐号问题"><a href="#4-同终端多git帐号问题" class="headerlink" title="4.同终端多git帐号问题"></a>4.同终端多git帐号问题</h2><p>先查看下我已经存在的 SSH keys：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls -al ~/.ssh   #这个是查看已经存在的ssh keys；</div><div class="line">    # Lists the files in your .ssh directory, if they exist</div></pre></td></tr></table></figure></p>
<p>这是我这边的显示结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">id_rsa				# 这是私钥</div><div class="line">id_rsa.pub			# 这是公钥</div><div class="line">github_rsa			# 这是给 github 生成的私钥，下面会讲到创建方法</div><div class="line">github_rsa.pub </div><div class="line">known_hosts</div><div class="line">config				# 这个文件就是重点，下面会讲到。</div></pre></td></tr></table></figure></p>
<p>下面我们来开始给创建 SSH key 吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &apos; &quot;your_email@example.com&quot; &apos; </div><div class="line">#这里引号内改成你在 Github 上设置的邮箱，比如我的是 leyar.me@gmail.com</div></pre></td></tr></table></figure></p>
<p>回车后会提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Generating public/private rsa key pair.</div><div class="line">#提示生成密钥配对</div></pre></td></tr></table></figure></p>
<p>继续回车，提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Enter file in which to save the key (/home/leyar/.ssh/id_rsa): /home/leyar/.ssh/github_rsa </div><div class="line">#注意！冒号后面这里官方帮助文档里是建议你直接回车，如果涉及多个 SSH keys，这个方法是不可行的。因此后面输入你想要创建的文件及其路径再回车。比如上面我输入的。 github_rsa 这个文件名你可以换别的。</div></pre></td></tr></table></figure></p>
<p>然后出现提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Enter passphrase (empty &apos;for&apos; no passphrase):		# 这里输入你想设置的密码，也可以直接回车</div><div class="line">Enter same passphrase again:			# 再次输入密码，或者直接回车</div></pre></td></tr></table></figure></p>
<p>官方文档强烈推荐设置密码,具体原因参考：<a href="https://help.github.com/articles/working-with-ssh-key-passphrases/" target="_blank" rel="external">Working with SSH key passphrases</a> 。</p>
<p>界面会提示成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Your identification has been saved in /home/leyar/.ssh/github_rsa.</div><div class="line">Your public key has been saved in /home/leyar/.ssh/github_rsa.pub.</div><div class="line">The key fingerprint is:</div><div class="line">01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db leyar.me@gmail.com</div></pre></td></tr></table></figure></p>
<p>接下来也是至关重要的一步，它保证了 GitHub 能否正确读取到你新建的密钥。<br>编辑 ssh 配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gedit  ~/.ssh/config</div></pre></td></tr></table></figure></p>
<p>在文件里面输入如下配置信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#GitHub user(leyar.me@gmail.com)</div><div class="line">Host ileyar.github.com				#这里修改成你自己的 host</div><div class="line">HostName github.com</div><div class="line">PreferredAuthentications publickey	# 这个貌似可以不需要的，暂时还没弄清楚。</div><div class="line">IdentityFile ~/.ssh/github_rsa		# 这里填入你前面新建的密钥的路径</div><div class="line">User git</div></pre></td></tr></table></figure>
<p>输入完成后，保存，关闭。回到终端。</p>
<p>接下来看看你添加的 SSH key 是否在运行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssh-add -l    #这个是检验是否运行ssh</div><div class="line">2048 d9:1b:af:b4:8e:8d:28:bb:2e:b3:7c:ce:eb:83:c6:52 leyar@iLeyar (RSA)</div><div class="line">2048 3e:22:25:65:0b:24:f5:51:43:27:8b:fd:91:3f:7f:85 leyar.me@gmail.com (RSA)</div></pre></td></tr></table></figure></p>
<p>可以看到第二个就是我新建的，已经在运行了。如果没有出现，可以通过如下操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-add ~/.ssh/github_rsa</div></pre></td></tr></table></figure></p>
<p>接着就是把本地生成的 SSH key 拷贝到 GitHub 网页里面了。<br>打开 ~/.ssh/github_rsa.pub 文件，把里面的内容（公钥）复制出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gedit ~/.ssh/github_rsa.pub</div></pre></td></tr></table></figure></p>
<p>登陆 Github ，点击 Add SSH key，”Title“ 随便填写，然后把你复制的内容，粘贴到 ”Key“ 里面。点击 Add key，OK！</p>
<p>检验结果的时刻到来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com  #这个是检验是否连上服务器</div><div class="line">Hi iLeyar! You’ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure></p>
<p>这里代表已经配对成功了～ </p>
<p>其中<br>github用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure></p>
<p>coding用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@git.coding.net</div></pre></td></tr></table></figure>
<p>gitee用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@gitee.com</div></pre></td></tr></table></figure>
<h2 id="5-修改hexo文档"><a href="#5-修改hexo文档" class="headerlink" title="5.修改hexo文档"></a>5.修改hexo文档</h2><p>在以前的笔记里有说明。<br>修改之后就可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">hexo s</div><div class="line">hexo d</div></pre></td></tr></table></figure></p>
<p>至此，<code>hexo g</code>一下可以同时在三个网址更新你blog。</p>
<h2 id="6-把本地仓库传到github上的hexo主分支去"><a href="#6-把本地仓库传到github上的hexo主分支去" class="headerlink" title="6.把本地仓库传到github上的hexo主分支去"></a>6.把本地仓库传到github上的hexo主分支去</h2><p>接下来我们要做的就是把本地仓库传到github上去，<br>可能遇到需要设置username和email，因为github每次commit都会记录他们<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name your name</div><div class="line">git config --global user.email your_email@youremail.com</div></pre></td></tr></table></figure></p>
<p> 此时已经在github和coding中已经设置好了SSH。</p>
<p>一般是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;fist...&quot;</div><div class="line">git remote add origin git@git.coding.net:user/project.git </div><div class="line">git push -u origin hexo</div></pre></td></tr></table></figure></p>
<p>但是这里要同时push三个，所以需要：用<code>git remote set-url</code>命令实现二者的同步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$git remote -v #查看当前远端仓库</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$git remote add both git@git.coding.net:user/project.git</div><div class="line">#添加一个名为 both 的远端</div><div class="line">$git remote set-url --add --push both git@git.coding.net:user/project.git</div><div class="line"># 为其添加 push 到 Coding 的 SSH 地址</div><div class="line">$git remote set-url --add --push both git@github.com:user/repo.git</div><div class="line"># 为其添加 push 到 GitHub 的 SSH 地址</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$git remote -v #查看当前远端仓库</div><div class="line">origin  git@git.coding.net:user/project.git (fetch)</div><div class="line">origin  git@git.coding.net:user/project.git (push)</div><div class="line">github  git@github.com:user/repo.git (fetch)</div><div class="line">github  git@github.com:user/repo.git (push)</div></pre></td></tr></table></figure>
<p>之后在推送的时候科研用git push both实现二者同步更新</p>
<p>注意出现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">To git@gitee.com:XiongDeMiao/xiongdemiao.git</div><div class="line"> ! [rejected]        hexo -&gt; hexo (fetch first)</div><div class="line">error: 无法推送一些引用到 &apos;git@gitee.com:XiongDeMiao/xiongdemiao.git&apos;</div><div class="line">提示：更新被拒绝，因为远程仓库包含您本地尚不存在的提交。这通常是因为另外</div><div class="line">提示：一个仓库已向该引用进行了推送。再次推送前，您可能需要先整合远程变更</div><div class="line">提示：（如 &apos;git pull ...&apos;）。</div><div class="line">提示：详见 &apos;git push --help&apos; 中的 &apos;Note about fast-forwards&apos; 小节。</div></pre></td></tr></table></figure></p>
<p>说明远程库有东西，可以：<code>git push -u both +hexo</code>强制push<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/文档/blog/xiongdemao.github.io$ git push -u both +hexo</div></pre></td></tr></table></figure></p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>按照以上的步骤就进行了 hexo 源文件的初次备份。<br>以后每次修改了内容之后，都可通过以下几条命令实现同步。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;...&quot;	 # 双引号内填写更新内容</div><div class="line">git push both hexo	# 或者 git push</div></pre></td></tr></table></figure></p>
<p>另外刚在 stackoverflow 上看到一个关于 git add . , git add -u 以及 git add -A 的区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add -A	# stages **ALL**</div><div class="line">git add .	# stages new and modified, **without deleted**</div><div class="line">git add -u	# stages modified and deleted, **without new**</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu 使用笔记]]></title>
      <url>/2017/10/06/linux/ubuntu%20%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%20/</url>
      <content type="html"><![CDATA[<h2 id="1-ubuntu如何用快捷键截图："><a href="#1-ubuntu如何用快捷键截图：" class="headerlink" title="1.ubuntu如何用快捷键截图："></a>1.ubuntu如何用快捷键截图：</h2><p><a href="http://jingyan.baidu.com/article/7f41ececf72d42593d095c33.html" target="_blank" rel="external">http://jingyan.baidu.com/article/7f41ececf72d42593d095c33.html</a></p>
<p>我的设置：<br><img src="http://img.blog.csdn.net/20170927222508871?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="2-在msg文件夹里创建新文件并写入内容"><a href="#2-在msg文件夹里创建新文件并写入内容" class="headerlink" title="2.在msg文件夹里创建新文件并写入内容"></a>2.在<code>msg</code>文件夹里创建新文件并写入内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;int64 num&quot; &gt; msg/Num.msg</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu 16.04 安装 uTorrent]]></title>
      <url>/2017/10/06/linux/Ubuntu%2016.04%20%E5%AE%89%E8%A3%85%20uTorrent/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.topspeedsnail.com/archives/5752" target="_blank" rel="external">Ubuntu 16.04 安装 uTorrent</a><br>uTorrent是小巧的BT下载软件，是BitTorrent开发的。</p>
<h2 id="在Ubuntu上安装uTorrent"><a href="#在Ubuntu上安装uTorrent" class="headerlink" title="在Ubuntu上安装uTorrent"></a>在Ubuntu上安装uTorrent</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install libssl1.0.0 libssl-dev</div></pre></td></tr></table></figure>
<p>从官网下载最新的uTorrent server：</p>
<p>64位系统：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget http://download-new.utorrent.com/endpoint/utserver/os/linux-x64-ubuntu-13-04/track/beta/ -O utserver.tar.gz</div></pre></td></tr></table></figure></p>
<p>解压文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo tar -zxvf utserver.tar.gz -C /opt/</div></pre></td></tr></table></figure></p>
<p>更改目录权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo chmod 777 /opt/utorrent-server-alpha-v3_3/</div></pre></td></tr></table></figure></p>
<p>创建/usr/bin的链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ln -s /opt/utorrent-server-alpha-v3_3/utserver /usr/bin/utserver</div></pre></td></tr></table></figure></p>
<p>启动uTorrent Server：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ utserver -settingspath /opt/utorrent-server-alpha-v3_3/</div></pre></td></tr></table></figure></p>
<p>运行之后，使用浏览器访问：<a href="http://your-ip-:8080/gui" target="_blank" rel="external">http://your-ip-:8080/gui</a></p>
<p>用户名admin，密码为空：</p>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu 火狐浏览器中，鼠标选择文字被删除的解决办法]]></title>
      <url>/2017/10/06/linux/Firefox/</url>
      <content type="html"><![CDATA[<h1 id="1-Ubuntu-火狐浏览器中，鼠标选择文字被删除的解决办法"><a href="#1-Ubuntu-火狐浏览器中，鼠标选择文字被删除的解决办法" class="headerlink" title="1. Ubuntu 火狐浏览器中，鼠标选择文字被删除的解决办法"></a>1. Ubuntu 火狐浏览器中，鼠标选择文字被删除的解决办法</h1><p>系统版本 14.04<br>ibus版本 1.5</p>
<p>系统输入法选择为ibus时会自动清除选中的文本，如果是英文输入法就没有这个问题。</p>
<p>解决方法：<br>终端中 ibus-setup<br>勾掉 在应用窗口中启用内嵌编辑模式</p>
<p>#2.Firefox中撤销按钮丢失了<br>1.新版本把撤销按钮去掉了。。</p>
<p>默认Firefox支持：Ctrl+Shift+T，实现撤销恢复。</p>
<p>2.如果不习惯用快捷键的，则去：</p>
<p><a href="http://mozilla.com.cn/addon/63-undo-closed-tabs-button/" target="_blank" rel="external">http://mozilla.com.cn/addon/63-undo-closed-tabs-button/</a></p>
<p>去安装对应插件，然后启用后，自己通过定制，即可加到工具栏中。</p>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu_ kdevelop 未指定有效的可执行文件!]]></title>
      <url>/2017/10/06/linux/ubuntu_%20kdevelop%20%E6%9C%AA%E6%8C%87%E5%AE%9A%E6%9C%89%E6%95%88%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6!/</url>
      <content type="html"><![CDATA[<h1 id="1-ubuntu下载安装-Kdevelop-之后想运行一下例子，却遇到这样的问题："><a href="#1-ubuntu下载安装-Kdevelop-之后想运行一下例子，却遇到这样的问题：" class="headerlink" title="1.ubuntu下载安装 Kdevelop 之后想运行一下例子，却遇到这样的问题："></a>1.ubuntu下载安装 Kdevelop 之后想运行一下例子，却遇到这样的问题：</h1><p><img src="http://img.blog.csdn.net/20171020221536697?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>解决：在最上边一栏【运行】-&gt;『配置启动器』中『Add New』-&gt;『应用程序』即可</p>
<p><img src="http://img.blog.csdn.net/20171020221920586?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>解释：当我们点击『execute』的时候是为了执行刚才『build』之后的代码，但是没有设置是否在『execute』（执行）的同时生成可运行程序（.exe）就会提示：“未指定有效的可执行文件!”</p>
<p>设置之后再『execute』一下，就可以看到久违的“ hello，world！”啦！</p>
<p><img src="http://img.blog.csdn.net/20171020222855302?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MjUxMDQ0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="2-tar-bz2文件解压命令"><a href="#2-tar-bz2文件解压命令" class="headerlink" title="2 .tar.bz2文件解压命令"></a>2 .tar.bz2文件解压命令</h2><p>从网络上下载到的源码包， 最常见的是 .tar.gz 包， 还有一部分是 .tar.bz2包</p>
<p>要解压很简单 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.tar.gz     格式解压为          tar   -zxvf   xx.tar.gz</div><div class="line"></div><div class="line">.tar.bz2   格式解压为          tar   -jxvf    xx.tar.bz2</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu14.04 安装Caffe（仅CPU）]]></title>
      <url>/2017/10/06/linux/Ubuntu14.04%20%E5%AE%89%E8%A3%85Caffe%EF%BC%88%E4%BB%85CPU%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Ubuntu14.04 安装Caffe（仅CPU） :<a href="http://blog.csdn.net/u011762313/article/details/47262549" target="_blank" rel="external">http://blog.csdn.net/u011762313/article/details/47262549</a></p>
<h2 id="1-其中："><a href="#1-其中：" class="headerlink" title="1.其中："></a>1.其中：</h2><p>1.<strong>如果安装的是opencv3.0：</strong>这一步可以省略，新版已解决，不用修改。<br>2.然后在<strong>编译Caffe：</strong>中</p>
<blockquote>
<p>修改Makefile.config文件：去掉CPU_ONLY:= 1的注释</p>
</blockquote>
<p>这一步再加一个：</p>
<blockquote>
<p>去掉　OPENCV_VERSION := 3注释</p>
</blockquote>
<h2 id="2-同时-如果编译出现错误了-则在改完别的时候"><a href="#2-同时-如果编译出现错误了-则在改完别的时候" class="headerlink" title="2.同时,如果编译出现错误了,则在改完别的时候:"></a>2.同时,如果编译出现错误了,则在改完别的时候:</h2><p>每次需要重新编译的过程中，首先需要清除掉以往编译的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make clean</div></pre></td></tr></table></figure>
<p>之后再<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make all</div></pre></td></tr></table></figure></p>
<h2 id="3-python-caffe报错：No-module-named-google-protobuf-internal"><a href="#3-python-caffe报错：No-module-named-google-protobuf-internal" class="headerlink" title="3.python caffe报错：No module named google.protobuf.internal"></a>3.python caffe报错：No module named google.protobuf.internal</h2><p>在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># python  </div><div class="line">&gt;&gt;&gt; import caffe</div></pre></td></tr></table></figure></p>
<p>然后就报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">No module named google.protobuf.internal</div></pre></td></tr></table></figure></p>
<p>解决的办法：</p>
<p>在anaconda2中安装protobuf最新版本。</p>
<p>在终端中进入anaconda2，在其中运行：conda install protobuf</p>
<p>然后再import caffe，就没有问题了。</p>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[win10+ubuntu双系统中ubuntu根目录扩容]]></title>
      <url>/2017/10/06/linux/win10+ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%B8%ADubuntu%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%89%A9%E5%AE%B9/</url>
      <content type="html"><![CDATA[<h1 id="1-Ubuntu无损扩展分区-目录-容量的方法"><a href="#1-Ubuntu无损扩展分区-目录-容量的方法" class="headerlink" title="1.Ubuntu无损扩展分区(目录)容量的方法"></a>1.Ubuntu无损扩展分区(目录)容量的方法</h1><p><a href="http://blog.csdn.net/jwq2011/article/details/54599744" target="_blank" rel="external">http://blog.csdn.net/jwq2011/article/details/54599744</a><br>或者（<a href="http://www.jianshu.com/p/beb9b7434c20" target="_blank" rel="external">Ubuntu 14.04 利用Gparted给根目录扩容</a>）</p>
<h1 id="2-扩容后可能出现开机无法启动，这是win10引导项有问题："><a href="#2-扩容后可能出现开机无法启动，这是win10引导项有问题：" class="headerlink" title="2.扩容后可能出现开机无法启动，这是win10引导项有问题："></a>2.扩容后可能出现开机无法启动，这是win10引导项有问题：</h1><p>可以有两种方法：</p>
<h2 id="一：u盘做成win8启动盘然后u盘启动，然后uboot修复下引导win10，然后就可以进入win10了，进入之后用easybcd加载ubuntu；（我的尝试失败）"><a href="#一：u盘做成win8启动盘然后u盘启动，然后uboot修复下引导win10，然后就可以进入win10了，进入之后用easybcd加载ubuntu；（我的尝试失败）" class="headerlink" title="一：u盘做成win8启动盘然后u盘启动，然后uboot修复下引导win10，然后就可以进入win10了，进入之后用easybcd加载ubuntu；（我的尝试失败）"></a>一：u盘做成win8启动盘然后u盘启动，然后uboot修复下引导win10，然后就可以进入win10了，进入之后用easybcd加载ubuntu；（我的尝试失败）</h2><h2 id="二：用Boot-repair修复双系统引导-百度经验"><a href="#二：用Boot-repair修复双系统引导-百度经验" class="headerlink" title="二：用Boot-repair修复双系统引导_百度经验"></a>二：用Boot-repair修复双系统引导_百度经验</h2><p><a href="http://jingyan.baidu.com/article/5553fa82cd48a765a23934ae.html" target="_blank" rel="external">http://jingyan.baidu.com/article/5553fa82cd48a765a23934ae.html</a><br>（亲测有效）</p>
<h2 id="三：别的（没试）：解决ubuntu与win10双系统安装之后没有ubuntu引导进入系统的问题-转载-http-blog-sina-com-cn-s-blog-4b183b7c0102wjgz-html"><a href="#三：别的（没试）：解决ubuntu与win10双系统安装之后没有ubuntu引导进入系统的问题-转载-http-blog-sina-com-cn-s-blog-4b183b7c0102wjgz-html" class="headerlink" title="三：别的（没试）：解决ubuntu与win10双系统安装之后没有ubuntu引导进入系统的问题(转载)http://blog.sina.com.cn/s/blog_4b183b7c0102wjgz.html"></a>三：别的（没试）：解决ubuntu与win10双系统安装之后没有ubuntu引导进入系统的问题(转载)<a href="http://blog.sina.com.cn/s/blog_4b183b7c0102wjgz.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4b183b7c0102wjgz.html</a></h2><h2 id="四：记录一下我的郁闷经历：修复GRUB2（未试）"><a href="#四：记录一下我的郁闷经历：修复GRUB2（未试）" class="headerlink" title="四：记录一下我的郁闷经历：修复GRUB2（未试）"></a>四：记录一下我的郁闷经历：修复GRUB2（未试）</h2><p><a href="http://blog.sina.com.cn/s/blog_6c9d65a10100m8fp.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_6c9d65a10100m8fp.html</a></p>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python：（4）条件判断]]></title>
      <url>/2017/09/18/python/python%EF%BC%9A%EF%BC%884%EF%BC%89%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/</url>
      <content type="html"><![CDATA[<h1 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">birth = input(<span class="string">'birth:'</span>)</div><div class="line"><span class="keyword">if</span> int(birth) &lt; <span class="number">2000</span>:</div><div class="line">    print(<span class="string">'00前'</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(<span class="string">'00后'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">birth:<span class="number">1993</span></div><div class="line"><span class="number">00</span>前</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h1 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h1><p>小明身高1.75，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数：</p>
<p>低于18.5：过轻<br>18.5-25：正常<br>25-28：过重<br>28-32：肥胖<br>高于32：严重肥胖<br>用if-elif判断并打印结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">high = <span class="number">1.75</span></div><div class="line">weight = <span class="number">80.5</span></div><div class="line">BMI = high + weight</div><div class="line"><span class="keyword">if</span> BMI &lt; <span class="number">18.5</span>:</div><div class="line">    print(<span class="string">'过轻'</span>)</div><div class="line"><span class="keyword">elif</span> BMI &lt;= <span class="number">25</span>:</div><div class="line">    print(<span class="string">'正常'</span>)</div><div class="line"><span class="keyword">elif</span> BMI &lt;= <span class="number">28</span>:</div><div class="line">    print(<span class="string">'过重'</span>)</div><div class="line"><span class="keyword">elif</span> BMI &lt;=<span class="number">32</span>:</div><div class="line">    print(<span class="string">'肥胖'</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(<span class="string">'严重肥胖'</span>)</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">====================== RESTART: E:\python_files\test.py ======================</div><div class="line">严重肥胖</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python：（3）使用list和tuple]]></title>
      <url>/2017/09/13/python/python%EF%BC%9A%EF%BC%883%EF%BC%89%E4%BD%BF%E7%94%A8list%E5%92%8Ctuple/</url>
      <content type="html"><![CDATA[<h1 id="1-list"><a href="#1-list" class="headerlink" title="1.list"></a>1.list</h1><p>新建列表；<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates = [<span class="string">'Michael'</span>,<span class="string">'Bob'</span>,<span class="string">'Tracy'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure></p>
<p>看长度及查询：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(classmates)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">0</span>]</div><div class="line"><span class="string">'Michael'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>]</div><div class="line"><span class="string">'Bob'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">2</span>]</div><div class="line"><span class="string">'Tracy'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-1</span>]</div><div class="line"><span class="string">'Tracy'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-2</span>]</div><div class="line"><span class="string">'Bob'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">-3</span>]</div><div class="line"><span class="string">'Michael'</span></div></pre></td></tr></table></figure></p>
<p>增：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">'Adam'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.insert(<span class="number">1</span>,<span class="string">'Jack'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>,<span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adam'</span>]</div></pre></td></tr></table></figure></p>
<p>删：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop()</div><div class="line"><span class="string">'Adam'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>,<span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop(<span class="number">1</span>)</div><div class="line"><span class="string">'Jack'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>,<span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure></p>
<p>改：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>] = <span class="string">'Sarah'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</div><div class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</div></pre></td></tr></table></figure></p>
<p>嵌套：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="string">'Aplle'</span>,<span class="number">123</span>,<span class="keyword">True</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[<span class="string">'Aplle'</span>, <span class="number">123</span>, <span class="keyword">True</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'Python'</span>,<span class="string">'java'</span>,L,<span class="string">'scheme'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s</div><div class="line">[<span class="string">'Python'</span>, <span class="string">'java'</span>, [<span class="string">'Aplle'</span>,<span class="number">123</span>,<span class="keyword">True</span>], <span class="string">'scheme'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>]</div><div class="line">[<span class="string">'Aplle'</span>,<span class="number">123</span>,<span class="keyword">True</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>][<span class="number">1</span>]</div><div class="line"><span class="number">123</span></div></pre></td></tr></table></figure></p>
<h1 id="2-tuple"><a href="#2-tuple" class="headerlink" title="2.tuple"></a>2.tuple</h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h2><p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = (<span class="string">'Micheal'</span>,<span class="string">'Bob'</span>,<span class="string">'ssss'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c.pop()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;pyshell#44&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    c.pop()</div><div class="line">AttributeError: <span class="string">'tuple'</span> object has no attribute <span class="string">'pop'</span></div></pre></td></tr></table></figure></p>
<h2 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h2><p>但是，要定义一个只有1个元素的tuple，如果你这么定义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</p>
<p>所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line">(<span class="number">1</span>,)</div></pre></td></tr></table></figure></p>
<p>Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。</p>
<h2 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h2><p>最后来看一个“可变的”tuple：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'A'</span>, <span class="string">'B'</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'X'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'Y'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'X'</span>, <span class="string">'Y'</span>])</div></pre></td></tr></table></figure></p>
<p>2.4<br><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014316724772904521142196b74a3f8abf93d8e97c6ee6000" target="_blank" rel="external">廖雪峰教程练习:</a></p>
<p>练习：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">请用索引取出下面list的指定元素：</div><div class="line"></div><div class="line"># -*- coding: utf-8 -*-</div><div class="line"></div><div class="line">L = [</div><div class="line">    ['Apple', 'Google', 'Microsoft'],</div><div class="line">    ['Java', 'Python', 'Ruby', 'PHP'],</div><div class="line">    ['Adam', 'Bart', 'Lisa']</div><div class="line">]</div><div class="line"># 打印Apple:</div><div class="line">print(?)</div><div class="line"># 打印Python:</div><div class="line">print(?)</div><div class="line"># 打印Lisa:</div><div class="line">print(?)</div></pre></td></tr></table></figure></p>
<p>答：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>L = [[<span class="string">'Apple'</span>,<span class="string">'Google'</span>,<span class="string">'Microsoft'</span>],[<span class="string">'Java'</span>,<span class="string">'Python'</span>,<span class="string">'Ruby'</span>,<span class="string">'PHP'</span>],<span class="string">'Adam'</span>,<span class="string">'Bart'</span>,<span class="string">'Lisa'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>L</div><div class="line">[[<span class="string">'Apple'</span>, <span class="string">'Google'</span>, <span class="string">'Microsoft'</span>], [<span class="string">'Java'</span>, <span class="string">'Python'</span>, <span class="string">'Ruby'</span>, <span class="string">'PHP'</span>], <span class="string">'Adam'</span>, <span class="string">'Bart'</span>, <span class="string">'Lisa'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(L[<span class="number">0</span>][<span class="number">1</span>])</div><div class="line">Google</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(L[<span class="number">0</span>][<span class="number">0</span>])</div><div class="line">Apple</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(L[<span class="number">0</span>][<span class="number">1</span>])</div><div class="line">Google</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(L[<span class="number">4</span>])</div><div class="line">Lisa</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python：（2）数据类型和变量]]></title>
      <url>/2017/09/12/python/python%EF%BC%9A%EF%BC%882%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<h1 id="1-整数"><a href="#1-整数" class="headerlink" title="1.整数"></a>1.整数</h1><p>十六进制用0x前缀和0-9，a-f表示，例如：<code>0xff00</code>，<code>0xa5b4c3d2</code>，等等。</p>
<h1 id="2-浮点数"><a href="#2-浮点数" class="headerlink" title="2.浮点数"></a>2.浮点数</h1><p>用科学计数法表示，把10用e替代，<code>1.23x109</code>就是<code>1.23e9</code>，或者<code>12.3e8</code>，<code>0.000012</code>可以写成<code>1.2e-5</code>，等等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0xff</span></div><div class="line"><span class="number">255</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.2e3</span><span class="number">-1</span></div><div class="line"><span class="number">1199.0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.2e-3</span> + <span class="number">1</span></div><div class="line"><span class="number">1.0012</span></div></pre></td></tr></table></figure></p>
<h1 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3.字符串"></a>3.字符串</h1><p>转义字符<code>\</code>来标识<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print('I\'m ok')</div><div class="line">I'm ok</div><div class="line">&gt;&gt;&gt; print("I'm ok") # " " 可以圈 '' </div><div class="line">I'm ok</div><div class="line">&gt;&gt;&gt; print('I\'m \"ok\"')</div><div class="line">I'm "ok"</div><div class="line">&gt;&gt;&gt; print('I\'m learning \n Python!')  # \n 表示换行</div><div class="line">I'm learning </div><div class="line"> Python!</div><div class="line">&gt;&gt;&gt; print('\\ \n \\') # \\ 表示 \ </div><div class="line">\ </div><div class="line"> \</div><div class="line">&gt;&gt;&gt; print('\\\n\\')</div><div class="line">\</div><div class="line">\</div><div class="line">&gt;&gt;&gt; print('\\\t\\')  # \t 表示制表（也就是四个Tab空格）</div><div class="line">\	\</div><div class="line">&gt;&gt;&gt; print(r'\\t\\')</div><div class="line">\\t\\</div><div class="line">&gt;&gt;&gt; print('''line1</div><div class="line">line2</div><div class="line">line3''')             #Python允许用 '''...''' 的格式表示多行内容</div><div class="line">line1</div><div class="line">line2</div><div class="line">line3</div></pre></td></tr></table></figure></p>
<h1 id="4-布尔值"><a href="#4-布尔值" class="headerlink" title="4.布尔值"></a>4.布尔值</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span>&gt;<span class="number">4</span></div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span>&gt;<span class="number">2</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> <span class="keyword">and</span> <span class="keyword">True</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span> <span class="keyword">and</span> <span class="keyword">False</span></div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> &gt; <span class="number">3</span> <span class="keyword">and</span> <span class="number">5</span> &gt; <span class="number">9</span></div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<h1 id="5-空值"><a href="#5-空值" class="headerlink" title="5.空值"></a>5.空值</h1><p>空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p>
<h1 id="6-变量"><a href="#6-变量" class="headerlink" title="6.变量"></a>6.变量</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'XYZ'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(b)</div><div class="line">ABC</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h1 id="7-常量"><a href="#7-常量" class="headerlink" title="7.常量"></a>7.常量</h1><h2 id="7-1"><a href="#7-1" class="headerlink" title="7.1"></a>7.1</h2><p>　　在Python中，通常用全部大写的变量名表示常量</p>
<h2 id="7-2"><a href="#7-2" class="headerlink" title="7.2"></a>7.2</h2><p>　　在Python中，有两种除法:</p>
<ul>
<li><p>一种除法是/：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> / <span class="number">3</span></div><div class="line"><span class="number">3.3333333333333335</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">9</span> / <span class="number">3</span></div><div class="line"><span class="number">3.0</span></div></pre></td></tr></table></figure>
</li>
<li><p>还有一种除法是//，称为地板除，两个整数的除法仍然是整数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> // <span class="number">3</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。</p>
<h1 id="8-字符编码"><a href="#8-字符编码" class="headerlink" title="8.字符编码"></a>8.字符编码</h1><p>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'A'</span>)</div><div class="line"><span class="number">65</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'中'</span>)</div><div class="line"><span class="number">20013</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">66</span>)</div><div class="line"><span class="string">'B'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">25991</span>)</div><div class="line"><span class="string">'文'</span></div></pre></td></tr></table></figure></p>
<p>如果知道字符的整数编码，还可以用十六进制这么写str：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\u4e2d\u6587'</span></div><div class="line"><span class="string">'中文'</span></div></pre></td></tr></table></figure></p>
<h1 id="9-格式化"><a href="#9-格式化" class="headerlink" title="9.格式化"></a>9.格式化</h1><p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello, %s'</span> % <span class="string">'world'</span></div><div class="line"><span class="string">'Hello, world'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hi, %s, you have $%d.'</span> % (<span class="string">'Michael'</span>, <span class="number">1000000</span>)</div><div class="line"><span class="string">'Hi, Michael, you have $1000000.'</span></div></pre></td></tr></table></figure></p>
<p>你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。</p>
<p>常见的占位符有：</p>
<p>| \%d    | 整数|<br>| \%f    | 浮点数|<br>| \%s    | 字符串|<br>| \%x    | 十六进制整数|</p>
<p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%2d-%02d'</span> % (<span class="number">3</span>, <span class="number">1</span>)</div><div class="line"><span class="string">' 3-01'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%.2f'</span> % <span class="number">3.1415926</span></div><div class="line"><span class="string">'3.14'</span></div></pre></td></tr></table></figure></p>
<p>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Age: %s. Gender: %s'</span> % (<span class="number">25</span>, <span class="keyword">True</span>)</div><div class="line"><span class="string">'Age: 25. Gender: True'</span></div></pre></td></tr></table></figure></p>
<p>有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'growth rate: %d %%'</span> % <span class="number">7</span></div><div class="line"><span class="string">'growth rate: 7 %'</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[matlab：（1）做作业中遇到的问题]]></title>
      <url>/2017/09/10/matlab/matlab%EF%BC%9A%EF%BC%881%EF%BC%89%E5%81%9A%E4%BD%9C%E4%B8%9A%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="1-求矩阵的逆用-inv"><a href="#1-求矩阵的逆用-inv" class="headerlink" title="1.求矩阵的逆用 inv()"></a>1.求矩阵的逆用 <code>inv()</code></h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; a=<span class="number">1</span>/<span class="number">27</span>*[<span class="number">-15</span> <span class="number">9</span> <span class="number">-27</span> <span class="number">-33</span>;<span class="number">1</span> <span class="number">-15</span> <span class="number">-9</span> <span class="number">-23</span>;<span class="number">9</span> <span class="number">0</span> <span class="number">-18</span> <span class="number">-18</span>;<span class="number">-7</span> <span class="number">-3</span> <span class="number">9</span> <span class="number">-1</span>]</div><div class="line"></div><div class="line">a =</div><div class="line"></div><div class="line">   <span class="number">-0.5556</span>    <span class="number">0.3333</span>   <span class="number">-1.0000</span>   <span class="number">-1.2222</span></div><div class="line">    <span class="number">0.0370</span>   <span class="number">-0.5556</span>   <span class="number">-0.3333</span>   <span class="number">-0.8519</span></div><div class="line">    <span class="number">0.3333</span>         <span class="number">0</span>   <span class="number">-0.6667</span>   <span class="number">-0.6667</span></div><div class="line">   <span class="number">-0.2593</span>   <span class="number">-0.1111</span>    <span class="number">0.3333</span>   <span class="number">-0.0370</span></div><div class="line"></div><div class="line">&gt;&gt; b = inv(a)</div><div class="line"></div><div class="line">b =</div><div class="line"></div><div class="line">   <span class="number">-1.0000</span>   <span class="number">-1.0000</span>    <span class="number">3.0000</span>    <span class="number">2.0000</span></div><div class="line">   <span class="number">-0.0000</span>   <span class="number">-2.5000</span>    <span class="number">3.0000</span>    <span class="number">3.5000</span></div><div class="line">   <span class="number">-0.7500</span>   <span class="number">-1.5000</span>    <span class="number">3.0000</span>    <span class="number">5.2500</span></div><div class="line">    <span class="number">0.2500</span>    <span class="number">1.0000</span>   <span class="number">-3.0000</span>   <span class="number">-4.2500</span></div></pre></td></tr></table></figure>
<h1 id="2-显示分数用rats-b"><a href="#2-显示分数用rats-b" class="headerlink" title="2.显示分数用rats(b)"></a>2.显示分数用<code>rats(b)</code></h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; c = <span class="built_in">rats</span>(b)</div><div class="line"></div><div class="line">c =</div><div class="line"></div><div class="line">      <span class="number">-1</span>            <span class="number">-1</span>             <span class="number">3</span>             <span class="number">2</span>      </div><div class="line">       <span class="number">0</span>           <span class="number">-5</span>/<span class="number">2</span>            <span class="number">3</span>            <span class="number">7</span>/<span class="number">2</span>     </div><div class="line">     <span class="number">-3</span>/<span class="number">4</span>          <span class="number">-3</span>/<span class="number">2</span>            <span class="number">3</span>           <span class="number">21</span>/<span class="number">4</span>     </div><div class="line">      <span class="number">1</span>/<span class="number">4</span>            <span class="number">1</span>            <span class="number">-3</span>          <span class="number">-17</span>/<span class="number">4</span></div></pre></td></tr></table></figure>
<h1 id="3-用matlab求Ax-0的基础解析的解程序为"><a href="#3-用matlab求Ax-0的基础解析的解程序为" class="headerlink" title="3.用matlab求Ax=0的基础解析的解程序为:"></a>3.用matlab求Ax=0的基础解析的解程序为:</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A=[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">-3</span> <span class="number">-1</span> <span class="number">1</span>;<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>;<span class="number">-2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">-2</span>];</div><div class="line">r=rank(A);</div><div class="line">y=null(A, ‘r’ )</div></pre></td></tr></table></figure>
<p>得到解为:<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">y=[    <span class="number">0</span>      <span class="number">-1</span>      <span class="number">-1</span>       <span class="number">0</span></div><div class="line">      <span class="number">-1</span>       <span class="number">2</span>       <span class="number">1</span>       <span class="number">1</span></div><div class="line">       <span class="number">1</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span></div><div class="line">       <span class="number">0</span>       <span class="number">2</span>       <span class="number">1</span>      <span class="number">-2</span></div><div class="line">       <span class="number">0</span>       <span class="number">1</span>       <span class="number">0</span>       <span class="number">0</span></div><div class="line">       <span class="number">0</span>       <span class="number">0</span>       <span class="number">1</span>       <span class="number">0</span></div><div class="line">       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">1</span>]</div></pre></td></tr></table></figure></p>
<p>其列向量构成Ax=0的一个基础解系。</p>
]]></content>
      
        <categories>
            
            <category> matlab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python基础：（2）第一个程序]]></title>
      <url>/2017/09/08/python/python%EF%BC%9A%EF%BC%881%EF%BC%89%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="1-计算"><a href="#1-计算" class="headerlink" title="1.计算"></a>1.计算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">212</span>+<span class="number">122</span></div><div class="line"><span class="number">334</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="2-打印"><a href="#2-打印" class="headerlink" title="2.打印"></a>2.打印</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"hello,world"</span>)</div><div class="line">hello,world</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="3-退出IDLE"><a href="#3-退出IDLE" class="headerlink" title="3.退出IDLE"></a>3.退出IDLE</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>exit()</div></pre></td></tr></table></figure>
<h2 id="4-逗号的用法"><a href="#4-逗号的用法" class="headerlink" title="4.逗号的用法"></a>4.逗号的用法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'100 + 200 ='</span>,<span class="number">100</span>+<span class="number">200</span>)</div><div class="line"><span class="number">100</span> + <span class="number">200</span> = <span class="number">300</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="5-input-和print"><a href="#5-input-和print" class="headerlink" title="5.input()和print()"></a>5.input()和print()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>name = input()</div><div class="line">mr. guo</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(name)</div><div class="line">mr. guo</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="6-python语法"><a href="#6-python语法" class="headerlink" title="6.python语法"></a>6.python语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># print absolute value of an integer</span></div><div class="line">print(<span class="string">"请输入一个数字："</span>)</div><div class="line">a = input()</div><div class="line">a = int(a)</div><div class="line"><span class="keyword">if</span> a &gt;= <span class="number">0</span>:</div><div class="line">    print(a)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    print(-a)</div></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">====================== RESTART: E:/python_files/取绝对值.py ======================</div><div class="line">请输入一个数字：</div><div class="line"><span class="number">-90</span></div><div class="line"><span class="number">90</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<blockquote>
<h3 id="6-1以-开头的语句是注释"><a href="#6-1以-开头的语句是注释" class="headerlink" title="6.1以#开头的语句是注释"></a>6.1以#开头的语句是注释</h3><h3 id="6-2按照约定俗成的管理，应该始终坚持使用4个空格的缩进。"><a href="#6-2按照约定俗成的管理，应该始终坚持使用4个空格的缩进。" class="headerlink" title="6.2按照约定俗成的管理，应该始终坚持使用4个空格的缩进。"></a>6.2按照约定俗成的管理，应该始终坚持使用4个空格的缩进。</h3><h3 id="6-1Python程序是大小写敏感的"><a href="#6-1Python程序是大小写敏感的" class="headerlink" title="6.1Python程序是大小写敏感的"></a>6.1Python程序是大小写敏感的</h3></blockquote>
<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2>]]></content>
      
        <categories>
            
            <category> python基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux笔记（4）：Linux命令]]></title>
      <url>/2017/08/07/linux/Linux%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9ALinux%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="1-命令使用方法"><a href="#1-命令使用方法" class="headerlink" title="1.命令使用方法"></a>1.命令使用方法</h1><p>Linux命令格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">command		[-options]		[parameter1]		...</div></pre></td></tr></table></figure></p>
<blockquote>
<p>说明:</p>
<ul>
<li>command:命令名,相应功能的英文单词或单词的缩写    </li>
<li>[-options]:选项,可用来对命令进行控制,也可以省略, [ ]代表可选         </li>
<li>parameter1    … : 传给命令的参数,可以是零个一个或多个</li>
</ul>
</blockquote>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xdm@xdm-virtual-machine:~/桌面/test1/test$ ls -a ./</div><div class="line">.  ..  a.py  .a.py.swo  t  test2  t.tar.gz  tt.tar.gz</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ubuntu </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习(4)：比较系统的深度学习和机器学习的资料]]></title>
      <url>/2017/08/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0(4)%EF%BC%9A%E6%AF%94%E8%BE%83%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%B5%84%E6%96%99/</url>
      <content type="html"><![CDATA[<hr>
<blockquote>
<p>写在前面，以下部分网站需要「翻墙」后食用，不在国内所以也不知道究竟被墙多少若无法翻墙，请「自寻」国内资源，如百度网盘，b站转载或知乎它人提供的链接</p>
</blockquote>
<ol>
<li><p>关于书籍<br>首推 Deep Learning这本书，我花了700+RMB买了一本，这本书作者就不用多说了，GAN之父Ian Goodfellow.另外一个好消息就是，这本书在几个星期前出了中文版，大快人心，才100多块，真心便宜，赶紧入手一本吧，圣经就算不读也可以供在家里吖。当然，你也可以从<a href="https://github.com/exacity/deeplearningbook-chinese" target="_blank" rel="external"> deeplearningbook-chinese</a> 下载本书的PDF啦<br>如果完全没有基础，建议还是要先学ML比较好，手头有李航的统计方法学，不过没看几页，然后是周志华老师的西瓜书，也没看几页，2333.</p>
</li>
<li><p>关于课程<br>其实已经不太推荐 Andrew Ng 的 ML了，因为有太多更好的代替品:<br>台大 <a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses.html" target="_blank" rel="external">李宏毅</a> 老师最近出了一系列视频，你可以在它的个人网站上找到<br>Machine Learning (2017,Spring)<br>Machine Learning (2016,Fall)<br>Machine Learning and having it deep and structured (2017,Spring)<br>这门课叫做<a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_MLDS17.html" target="_blank" rel="external">MLDS</a>,其实就是在讲Deep Learning，而且homework非常有意思，有GAN也有RL，关键是老师讲得确实很好，值得推荐<br>另外就是李宏毅老师的《一日搞懂深度学习》，其实<a href="http://speech.ee.ntu.edu.tw/~tlkagk/research.html" target="_blank" rel="external">链接</a> 全都在老师的个人网站上，8月13号在台北还有他的talk《一日搞懂生成对抗网络》，同学有报名去听，我的话，没钱啊。。2333.<br>其实李老师的所有视频都在他的YouTube上。</p>
</li>
<li><p>还有台大 <a href="https://www.csie.ntu.edu.tw/~htlin/" target="_blank" rel="external">林軒田</a>老师出的公开课<a href="https://www.csie.ntu.edu.tw/~htlin/course/mltech17spring/" target="_blank" rel="external">《机器学习基石》</a>和<a href="https://www.csie.ntu.edu.tw/~htlin/course/mlfound16fall/" target="_blank" rel="external">《机器学习技法》</a>。<br>老师讲得很好，PDF做得也很棒，毕竟林老师曾经是多届 KDD Cup 的冠军啊<br>Machine Learning Techniques, Spring 2017<br>Machine Learning Foundations, Fall 2016</p>
</li>
<li><p>最最推荐的其实是 Fei-Fei Li 的 CS231n，这门课就真心赞了,video, slide,note都写得非常好。课程的视频，在YouTube上面也能轻松找到。<br><a href="http://cs231n.stanford.edu/" target="_blank" rel="external">CS231n: Convolutional Neural Networks for Visual Recognition</a><br>知乎还有翻译  <a href="https://zhuanlan.zhihu.com/p/21930884" target="_blank" rel="external">贺完结！CS231n官方笔记授权翻译总集篇发布</a><br>或者是<a href="http://cs224d.stanford.edu/" target="_blank" rel="external">CS224d: Deep Learning for Natural Language Processing</a></p>
</li>
<li><p>关于Reinforcement Learning的课程和资料<br>首推 AlphaGo 团队的 Leader — <a href="https://github.com/BIGBALLON/crawler_demo" target="_blank" rel="external">David silver</a> 的<a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching.html" target="_blank" rel="external"> Reinforcement Learning</a> ，我最开始学DRL的时候就是看他的视频和slide，真的很赞。<br>以及Berkeley 的<a href="http://rll.berkeley.edu/deeprlcourse/" target="_blank" rel="external"> DRL : CS 294 Deep Reinforcement Learning, Fall 2017</a><br>另外，RL的鼻祖Sutton最近也在干大事，正在写<a href="http://incompleteideas.net/sutton/book/bookdraft2017june19.pdf" target="_blank" rel="external">Reinforcement Learning: An Introduction </a>的 第二版</p>
</li>
<li><p>其实学习RL最好的 Demo 就是 用 强化学习来 玩 2048 了，我们lab有世界上第一个用 TD learning 玩出 65536 的 AI，另外如果有机会想写一个关于RL的专栏，主要是DeepMind 的 paper，不过太菜了估计写了也没人看<br><a href="http://2048.aigames.nctu.edu.tw/replay.php" target="_blank" rel="external">重现看这里</a><br><a href="https://github.com/BIGBALLON/Deep-learning-and-practices/blob/master/Lab8-TDL2048/2048.cpp" target="_blank" rel="external">超级精简版code 看这里</a></p>
</li>
</ol>
<p>转自：<a href="https://zhuanlan.zhihu.com/p/28346839?utm_source=qq&amp;utm_medium=social" target="_blank" rel="external">给妹纸的深度学习教学(3)——用VGG19开荒</a></p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux笔记（3）：文件和目录]]></title>
      <url>/2017/08/07/linux/Linux%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
      <content type="html"><![CDATA[<h1 id="一-Linux目录"><a href="#一-Linux目录" class="headerlink" title="一.Linux目录"></a>一.Linux目录</h1><ul>
<li><p>/:根目录,一般根目录下只存放目录,在Linux下有且只有一个根目录。所有的东⻄都是从这里开始。当你在终端里输入“/home”,你其实是在告诉电脑,先从/(根目录)开始,再进入到home目录。</p>
</li>
<li><p>/bin、/usr/bin:可执行二进制文件的目录,如常用的命令ls、tar、mv、cat等。</p>
</li>
<li><p>/boot:放置linux系统启动时用到的一些文件,如Linux的内核文件:/boot/vmlinuz,系统引导管理器:/boot/grub。</p>
</li>
<li><p>/dev:存放linux系统下的设备文件,访问该目录下某个文件,相当于访问某个设备,常用的是挂载光驱    mount    /dev/cdrom    /mnt。</p>
</li>
<li><p>/etc:系统配置文件存放的目录,不建议在此目录下存放可执行文件,重要的配置文件有/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。</p>
</li>
<li><p>/home:系统默认的用户家目录,新增用户账号时,用户的家目录都存放在此目录下,~表示当前用户的家目录,~edu    表示用户    edu    的家目录。</p>
</li>
<li><p>/lib、/usr/lib、/usr/local/lib:系统使用的函数库的目录,程序在执行过程中,需要调用一些额外的参数时需要函数库的协助。</p>
</li>
<li><p>/lost+fount:系统异常产生错误时,会将一些遗失的片段放置于此目录下。</p>
</li>
<li><p>/mnt:    /media:光盘默认挂载点,通常光盘挂载于    /mnt/cdrom    下,也不一定,可以选择任意位置进行挂载。</p>
</li>
<li><p>/opt:给主机额外安装软件所摆放的目录。</p>
</li>
<li><p>/proc:此目录的数据都在内存中,如系统核心,外部设备,网络状态,由于数据都存放于内存中,所以不占用磁盘空间,比较重要的目录有<br>/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*    等。</p>
</li>
<li><p>/root:系统管理员root的家目录。</p>
</li>
<li><p>/sbin、/usr/sbin、/usr/local/sbin:放置系统管理员使用的可执行命令,如fdisk、shutdown、mount    等。与    /bin    不同的是,这几个目录是给系统管理员root使用的命令,一般用户只能”查看”而不能设置和使用。</p>
</li>
<li><p>/tmp:一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下。</p>
</li>
<li><p>/srv:服务启动之后需要访问的数据目录,如    www    服务需要访问的网⻚数据存放在/srv/www内。</p>
</li>
<li><p>/usr:应用程序存放目录,/usr/bin存放应用程序,/usr/share    存放共享数据,/usr/lib存放不能直接运行的,却是许多程序运行所必需的一些函数库文件。</p>
</li>
<li>/usr/local:    存放软件升级包。/</li>
<li>usr/share/doc:    系统说明文件存放目录。</li>
<li><p>/usr/share/man:    程序说明文件存放目录。</p>
</li>
<li><p>/var:放置系统执行过程中经常变化的文件,如随时更改的日志文件/var/log,</p>
</li>
<li>/var/log/message:所有的登录文件存放目录,/var/spool/mail:邮件存放的目录,</li>
<li>/var/run:程序或服务启动后,其PID存放在该目录下。</li>
</ul>
<h1 id="二-用户目录"><a href="#二-用户目录" class="headerlink" title="二.用户目录"></a>二.用户目录</h1><p>位于/home/user,称之为用户工作目录或家目录,表示方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xdm@xdm-virtual-machine:~$ </div><div class="line"></div><div class="line">&quot;~&quot;相当于“/home/user”</div></pre></td></tr></table></figure></p>
<h1 id="三-相对路径和绝对路径"><a href="#三-相对路径和绝对路径" class="headerlink" title="三.相对路径和绝对路径"></a>三.相对路径和绝对路径</h1><h2 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h2><p>从/目录开始描述的路径为绝对路径,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd	/home</div><div class="line">ls	/usr</div></pre></td></tr></table></figure></p>
<h2 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h2><p>从当前位置开始描述的路径为相对路径,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd	../../</div><div class="line">ls	abc/def</div></pre></td></tr></table></figure></p>
<h2 id="和"><a href="#和" class="headerlink" title=".和.."></a>.和..</h2><p>每个目录下都有.和..</p>
<h3 id="表示当前目录"><a href="#表示当前目录" class="headerlink" title=".    表示当前目录"></a>.    表示当前目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xdm@xdm-virtual-machine:~$ cd ./桌面</div><div class="line">xdm@xdm-virtual-machine:~/桌面$</div></pre></td></tr></table></figure>
<h3 id="表示上一级目录-即父目录"><a href="#表示上一级目录-即父目录" class="headerlink" title="..    表示上一级目录,即父目录"></a>..    表示上一级目录,即父目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xdm@xdm-virtual-machine:~/桌面/test1$ cd ../../</div><div class="line">xdm@xdm-virtual-machine:~$</div></pre></td></tr></table></figure>
<p>根目录下的.和..都表示当前目录</p>
<h1 id="四-文件权限"><a href="#四-文件权限" class="headerlink" title="四.文件权限"></a>四.文件权限</h1><p>  文件权限就是文件的访问控制权限,即哪些用户和组群可以访问文件以及可以执行什么样的操作。<br>Unix/Linux系统是一个典型的多用户系统,不同的用户处于不同的地位,对文件和目录有不同的访问权限。为了保护系统的安全性,Unix/Linux系统除了对用户权限作了严格的界定外,还在用户身份认证、访问控制、传输安全、文件读写权限等方面作了周密的控制。</p>
<h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>用户能够控制一个给定的文件或目录的访问程度,一个文件或目录可能有读、写及执行权限:</p>
<ul>
<li><p>读权限(r)    对文件而言,具有读取文件内容的权限;对目录来说,具有浏览目录的权限。</p>
</li>
<li><p>写权限(w)    对文件而言,具有新增、修改文件内容的权限;对目录来说,具有删除、移动目录内文件的权限。</p>
</li>
<li><p>可执行权限(x)    对文件而言,具有执行文件的权限;对目录了来说该用户具有进入目录的权限。</p>
</li>
</ul>
<p>注意:通常,Unix/Linux系统只允许文件的属主(所有者)或超级用户改变文件的读写权限。</p>
<h2 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xdm@xdm-virtual-machine:~/桌面/test1/test$ ls -lh</div><div class="line">总用量 28K</div><div class="line">-rwxrw-rw- 1 xdm xdm   26 8月   6 15:57 a.py</div><div class="line">-rw-rw-rw- 1 xdm xdm  10K 2月  13 15:33 t</div><div class="line">drwxrwxrwx 2 xdm xdm 4.0K 2月  13 14:57 test2</div><div class="line">-rw-rw-rw- 1 xdm xdm  263 2月  13 15:35 t.tar.gz</div><div class="line">-rw-rw-rw- 1 xdm xdm  600 2月  13 15:44 tt.tar.gz</div></pre></td></tr></table></figure>
<blockquote>
<p>第1个字母代表文件的类型:“d”    代表文件夹、“-”    代表普通文件、“c”代表硬件字符设备、“b”    代表硬件块设备、“s”表示管道文件、“l”    代表软链接文件。</p>
</blockquote>
<hr>
<blockquote>
<p>后9个字母分别代表三组权限:文件所有者、用户者、其他用户拥有的权限。</p>
<p>每一个用户都有它自身的读、写和执行权限。</p>
<ul>
<li>第一组权限控制访问自己的文件权限,即所有者权限。</li>
<li>第二组权限控制用户组访问其中一个用户的文件的权限。</li>
<li>第三组权限控制其他所有用户访问一个用户的文件的权限。</li>
</ul>
<p>这三组权限赋予用户不同类型(即所有者、用户组和其他用户)的读、写及执行权限就构成了一个有9种类型的权限组。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ubuntu </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习（3）： 一张图帮你全面掌握机器学习算法知识体系]]></title>
      <url>/2017/08/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0(3)%EF%BC%9A%E4%B8%80%E5%BC%A0%E5%9B%BE%E5%B8%AE%E4%BD%A0%E5%85%A8%E9%9D%A2%E6%8E%8C%E6%8F%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
      <content type="html"><![CDATA[<p><img src="http://otl5jere6.bkt.clouddn.com/v1.png" alt="此处输入图片的描述"><br><img src="http://otl5jere6.bkt.clouddn.com/v2.png" alt="此处输入图片的描述"><br><img src="http://otl5jere6.bkt.clouddn.com/v3.png" alt="此处输入图片的描述"><br><img src="http://otl5jere6.bkt.clouddn.com/v4.png" alt="此处输入图片的描述"></p>
<p>原创 2017-08-06 <a href="https://zhuanlan.zhihu.com/p/28339662?utm_source=qq&amp;utm_medium=social" target="_blank" rel="external">智能菌</a> 智能玩咖</p>
<p>在开发者服务平台CSDN上有个叫王小雷的大神，近日整理了一份比较全面的机器学习知识体系，对此智能菌甚为震惊，专门在他的基础上给大家制作了这张思维导图，希望对大家有帮助。</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux笔记(5)：linux 命令]]></title>
      <url>/2017/08/06/linux/Linux%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9AUNIX%20%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>####1.1 Listing files and directories<br>     ls (list) </p>
<h4 id="1-2-Making-Directories"><a href="#1-2-Making-Directories" class="headerlink" title="1.2 Making Directories"></a>1.2 Making Directories</h4><pre><code>mkdir (make directory) 
</code></pre><h4 id="1-3-Changing-to-a-different-directory"><a href="#1-3-Changing-to-a-different-directory" class="headerlink" title="1.3 Changing to a different directory"></a>1.3 Changing to a different directory</h4><pre><code>cd (change directory)
</code></pre><p>1.4 The directories . and .. </p>
<pre><code>% cd . 

% cd .. 
</code></pre><h4 id="1-5-Pathnames（路径名）"><a href="#1-5-Pathnames（路径名）" class="headerlink" title="1.5 Pathnames（路径名）"></a>1.5 Pathnames（路径名）</h4><pre><code>pwd (print working directory) 
</code></pre><h4 id="1-6新建文件"><a href="#1-6新建文件" class="headerlink" title="1.6新建文件"></a>1.6新建文件</h4><pre><code>touch a.txt
</code></pre><table>
<thead>
<tr>
<th>Command</th>
<th style="text-align:center">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>ls</td>
<td style="text-align:center">list files and directories</td>
</tr>
<tr>
<td>ls -a</td>
<td style="text-align:center">list all files and directories</td>
</tr>
<tr>
<td>mkdir</td>
<td style="text-align:center">make a directory</td>
</tr>
<tr>
<td>cd</td>
<td style="text-align:center">directory     change to named directory</td>
</tr>
<tr>
<td>cd</td>
<td style="text-align:center">change to home-directory</td>
</tr>
<tr>
<td>cd ~</td>
<td style="text-align:center">change to home-directory</td>
</tr>
<tr>
<td>cd ..</td>
<td style="text-align:center">change to parent directory</td>
</tr>
<tr>
<td>pwd</td>
<td style="text-align:center">display the path of the current directory</td>
</tr>
</tbody>
</table>
<h4 id="2-1-Copying-Files"><a href="#2-1-Copying-Files" class="headerlink" title="2.1 Copying Files"></a>2.1 Copying Files</h4><pre><code>cp (copy)
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">% cp /vol/examples/tutorial/science.txt .</div></pre></td></tr></table></figure>
<blockquote>
<p>Note: Don’t forget the dot . at the end. Remember, in UNIX, the dot means the current directory.</p>
</blockquote>
<h4 id="2-2-Moving-files"><a href="#2-2-Moving-files" class="headerlink" title="2.2 Moving files"></a>2.2 Moving files</h4><pre><code>mv (move)

mv file1 file2 moves (or renames) file1 to file2 

% mv science.bak backups/.
</code></pre><h4 id="2-3-Removing-files-and-directories"><a href="#2-3-Removing-files-and-directories" class="headerlink" title="2.3 Removing files and directories"></a>2.3 Removing files and directories</h4><pre><code>rm (remove)(删除文件)
rmdir (remove directory)（删除空文件夹）
</code></pre><h4 id="2-4-Displaying-the-contents-of-a-file-on-the-screen"><a href="#2-4-Displaying-the-contents-of-a-file-on-the-screen" class="headerlink" title="2.4 Displaying the contents of a file on the screen"></a>2.4 Displaying the contents of a file on the screen</h4><pre><code>clear (clear screen)
    % clear 
cat (concatenate)
    % cat science.txt 
less
    % less science.txt 
head
    % head science.txt
    % head -5 science.txt 
tail
    % tail science.txt 
</code></pre><h4 id="2-5-Searching-the-contents-of-a-file"><a href="#2-5-Searching-the-contents-of-a-file" class="headerlink" title="2.5 Searching the contents of a file"></a>2.5 Searching the contents of a file</h4><h5 id="2-5-1-less"><a href="#2-5-1-less" class="headerlink" title="2.5.1  less"></a>2.5.1  <strong><em>less</em></strong></h5><pre><code>% less science.txt
</code></pre><p>then, still in less, type a forward slash [/] followed by the word to search</p>
<pre><code>/science
</code></pre><h5 id="2-5-2-grep"><a href="#2-5-2-grep" class="headerlink" title="2.5.2   grep"></a>2.5.2   <strong><em>grep</em></strong></h5><pre><code>% grep -i science science.txt 
</code></pre><h5 id="2-5-3-wc-word-count"><a href="#2-5-3-wc-word-count" class="headerlink" title="2.5.3 wc (word count)"></a>2.5.3 <strong><em>wc</em></strong> (word count)</h5><pre><code>% grep -i science science.txt 
</code></pre><p>A handy little utility is the wc command, short for word count. To do a word count on science.txt, type</p>
<pre><code>% wc -w science.txt
</code></pre><p>To find out how many lines the file has, type</p>
<pre><code>% wc -l science.txt 
</code></pre><table>
<thead>
<tr>
<th>Command</th>
<th style="text-align:center">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>cp file1 file2</td>
<td style="text-align:center">copy file1 and call it file2</td>
</tr>
<tr>
<td>mv file1 file2</td>
<td style="text-align:center">move or rename file1 to file2</td>
</tr>
<tr>
<td>rm file</td>
<td style="text-align:center">remove a file</td>
</tr>
<tr>
<td>rmdir directory</td>
<td style="text-align:center">remove a directory</td>
</tr>
<tr>
<td>cat file</td>
<td style="text-align:center">display a file</td>
</tr>
<tr>
<td>less file</td>
<td style="text-align:center">display a file a page at a time</td>
</tr>
<tr>
<td>head file</td>
<td style="text-align:center">display the first few lines of a file</td>
</tr>
<tr>
<td>tail file</td>
<td style="text-align:center">display the last few lines of a file</td>
</tr>
<tr>
<td>grep ‘keyword’ file</td>
<td style="text-align:center">search a file for keywords</td>
</tr>
<tr>
<td>wc file</td>
<td style="text-align:center">count number of lines/words/characters in file</td>
</tr>
</tbody>
</table>
<p> Linux中more和less命令用法 <a href="http://www.cnblogs.com/aijianshi/p/5750911.html" target="_blank" rel="external">http://www.cnblogs.com/aijianshi/p/5750911.html</a></p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><h4 id="3-1-Redirection-重定向"><a href="#3-1-Redirection-重定向" class="headerlink" title="3.1 Redirection   (重定向)"></a>3.1 Redirection   (重定向)</h4><pre><code>% cat
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ cat</div><div class="line">ddd</div><div class="line">ddd</div></pre></td></tr></table></figure>
<h4 id="3-2-Redirecting-the-Output-重定向输出"><a href="#3-2-Redirecting-the-Output-重定向输出" class="headerlink" title="3.2 Redirecting the Output(重定向输出)"></a>3.2 Redirecting the Output(重定向输出)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ cat &gt; list1</div><div class="line">pear</div><div class="line">banana</div><div class="line">apple</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ cat list1</div><div class="line">pear</div><div class="line">banana</div><div class="line">apple</div></pre></td></tr></table></figure>
<h4 id="3-2-1-Appending-to-a-file-附加到文件"><a href="#3-2-1-Appending-to-a-file-附加到文件" class="headerlink" title="3.2.1 Appending to a file (附加到文件)"></a>3.2.1 Appending to a file (附加到文件)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ cat &gt;&gt; list1</div><div class="line">peach</div><div class="line">grape</div><div class="line">orange</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ cat list1</div><div class="line">pear</div><div class="line">banana</div><div class="line">apple</div><div class="line">peach</div><div class="line">grape</div><div class="line">orange</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ cat &gt; list2</div><div class="line">orange</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ cat list1 list2 &gt;biglist</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ cat biglist</div><div class="line">pear</div><div class="line">banana</div><div class="line">apple</div><div class="line">peach</div><div class="line">grape</div><div class="line">orange</div><div class="line">orange</div></pre></td></tr></table></figure>
<h3 id="3-3-Redirecting-the-Input-重定向输入"><a href="#3-3-Redirecting-the-Input-重定向输入" class="headerlink" title="3.3 Redirecting the Input (重定向输入)"></a>3.3 Redirecting the Input (重定向输入)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ sort(排序)</div><div class="line">dog</div><div class="line">cat</div><div class="line">bird</div><div class="line">ape </div><div class="line"># ^D (Control D to stop) </div><div class="line">ape</div><div class="line">bird</div><div class="line">cat</div><div class="line">dog</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ sort &lt; biglist #(对列表biglist排序)</div><div class="line">apple</div><div class="line">banana</div><div class="line">grape</div><div class="line">orange</div><div class="line"># ^D (Control D to stop) </div><div class="line">orange</div><div class="line">peach</div><div class="line">pear</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ sort &lt; biglist &gt; slist   #(对biglist排序并保存到slist)</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ cat slist</div><div class="line">apple</div><div class="line">banana</div><div class="line">grape</div><div class="line">orange</div><div class="line">orange</div><div class="line">peach</div><div class="line">pear</div></pre></td></tr></table></figure>
<h3 id="3-4-Pipes"><a href="#3-4-Pipes" class="headerlink" title="3.4 Pipes"></a>3.4 Pipes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ who</div><div class="line">kuo      :0           2017-09-20 14:32 (:0)</div><div class="line">kuo      pts/1        2017-09-20 14:41 (:0)</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Command</th>
<th style="text-align:center">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>command &gt; file</td>
<td style="text-align:center">redirect standard output to a file</td>
</tr>
<tr>
<td>command &gt;&gt; file</td>
<td style="text-align:center">append standard output to a file</td>
</tr>
<tr>
<td>command &lt; file</td>
<td style="text-align:center">redirect standard input from a file</td>
</tr>
<tr>
<td>command1 l command2</td>
<td style="text-align:center">pipe the output of command1 to the input of command</td>
</tr>
<tr>
<td>cat file1 file2 &gt; file0</td>
<td style="text-align:center">concatenate file1 and file2 to file0</td>
</tr>
<tr>
<td>sort</td>
<td style="text-align:center">sort data</td>
</tr>
<tr>
<td>who</td>
<td style="text-align:center">list users currently logged in</td>
</tr>
</tbody>
</table>
<h3 id="4-1-Wildcards（通配符-）"><a href="#4-1-Wildcards（通配符-）" class="headerlink" title="4.1 Wildcards（通配符 *）"></a>4.1 Wildcards（通配符 *）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ ls list*</div><div class="line">list1  list2</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ ls *list</div><div class="line">biglist  slist</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ ls ?list</div><div class="line">slist</div></pre></td></tr></table></figure>
<h3 id="4-2-Filename-conventions-文件名约定"><a href="#4-2-Filename-conventions-文件名约定" class="headerlink" title="4.2 Filename conventions (文件名约定)"></a>4.2 Filename conventions (文件名约定)</h3><table>
<thead>
<tr>
<th>Good filenames</th>
<th>Bad filenames</th>
</tr>
</thead>
<tbody>
<tr>
<td>project.txt</td>
<td>project</td>
</tr>
<tr>
<td>my_big_program.c</td>
<td>my big program.c</td>
</tr>
<tr>
<td>fred_dave.doc</td>
<td>fred &amp; dave.doc</td>
</tr>
</tbody>
</table>
<h3 id="4-3-Getting-Help"><a href="#4-3-Getting-Help" class="headerlink" title="4.3 Getting Help"></a>4.3 Getting Help</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">% man wc </div><div class="line"></div><div class="line">% whatis wc  </div><div class="line">  #（gives a one-line description of the command, but omits any information about options etc.）</div><div class="line"></div><div class="line">% apropos keyword</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Command</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>match any number of characters</td>
</tr>
<tr>
<td>?</td>
<td>match one character</td>
</tr>
<tr>
<td>man command</td>
<td>read the online manual page for a command</td>
</tr>
<tr>
<td>whatis command</td>
<td>brief description of a command</td>
</tr>
<tr>
<td>apropos keyword</td>
<td>match commands with keyword in their man pages</td>
</tr>
</tbody>
</table>
<h3 id="5-1-File-system-security-access-rights-文件系统安全（访问权限）"><a href="#5-1-File-system-security-access-rights-文件系统安全（访问权限）" class="headerlink" title="5.1 File system security (access rights) (文件系统安全（访问权限）)"></a>5.1 File system security (access rights) (文件系统安全（访问权限）)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ ls -l</div><div class="line">总用量 28</div><div class="line">-rw-rw-r-- 1 kuo kuo 55  9月 20 16:51 a.txt</div><div class="line">-rw-rw-r-- 1 kuo kuo  6  9月 20 16:37 a.txt~</div><div class="line">-rw-rw-r-- 1 kuo kuo 44  9月 20 18:28 biglist</div><div class="line">-rw-rw-r-- 1 kuo kuo  0  9月 20 16:01 c.tat</div><div class="line">-rw-rw-r-- 1 kuo kuo 37  9月 20 18:27 list1</div><div class="line">-rw-rw-r-- 1 kuo kuo  7  9月 20 18:28 list2</div><div class="line">-rw-rw-r-- 1 kuo kuo 88  9月 20 18:34 names.txt</div><div class="line">-rw-rw-r-- 1 kuo kuo 44  9月 20 18:32 slist</div></pre></td></tr></table></figure>
<h3 id="5-2-Changing-access-rights-更改访问权限"><a href="#5-2-Changing-access-rights-更改访问权限" class="headerlink" title="5.2 Changing access rights(更改访问权限)"></a>5.2 Changing access rights(更改访问权限)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ chmod go-rwx biglist</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ ls -l</div><div class="line">总用量 28</div><div class="line">-rw-rw-r-- 1 kuo kuo 55  9月 20 16:51 a.txt</div><div class="line">-rw-rw-r-- 1 kuo kuo  6  9月 20 16:37 a.txt~</div><div class="line">-rw------- 1 kuo kuo 44  9月 20 18:28 biglist</div><div class="line">-rw-rw-r-- 1 kuo kuo  0  9月 20 16:01 c.tat</div><div class="line">-rw-rw-r-- 1 kuo kuo 37  9月 20 18:27 list1</div><div class="line">-rw-rw-r-- 1 kuo kuo  7  9月 20 18:28 list2</div><div class="line">-rw-rw-r-- 1 kuo kuo 88  9月 20 18:34 names.txt</div><div class="line">-rw-rw-r-- 1 kuo kuo 44  9月 20 18:32 slist</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ chmod a+rw biglist</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ ls -l</div><div class="line">总用量 28</div><div class="line">-rw-rw-r-- 1 kuo kuo 55  9月 20 16:51 a.txt</div><div class="line">-rw-rw-r-- 1 kuo kuo  6  9月 20 16:37 a.txt~</div><div class="line">-rw-rw-rw- 1 kuo kuo 44  9月 20 18:28 biglist</div><div class="line">-rw-rw-r-- 1 kuo kuo  0  9月 20 16:01 c.tat</div><div class="line">-rw-rw-r-- 1 kuo kuo 37  9月 20 18:27 list1</div><div class="line">-rw-rw-r-- 1 kuo kuo  7  9月 20 18:28 list2</div><div class="line">-rw-rw-r-- 1 kuo kuo 88  9月 20 18:34 names.txt</div><div class="line">-rw-rw-r-- 1 kuo kuo 44  9月 20 18:32 slist</div></pre></td></tr></table></figure>
<h3 id="5-3-Processes-and-Jobs-流程和工作"><a href="#5-3-Processes-and-Jobs-流程和工作" class="headerlink" title="5.3 Processes and Jobs (流程和工作)"></a>5.3 Processes and Jobs (流程和工作)</h3><h4 id="1-PS-显示正在工作的进程"><a href="#1-PS-显示正在工作的进程" class="headerlink" title="1.PS 显示正在工作的进程"></a>1.<strong>PS</strong> 显示正在工作的进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ ps</div><div class="line">  PID TTY          TIME CMD</div><div class="line"> 2533 pts/1    00:00:00 bash</div><div class="line"> 7467 pts/1    00:00:00 ps</div></pre></td></tr></table></figure>
<h4 id="2-Running-background-processes-运行后台进程"><a href="#2-Running-background-processes-运行后台进程" class="headerlink" title="2.Running background processes(运行后台进程)"></a>2.Running background processes(运行后台进程)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ sleep 10</div><div class="line">#前台运行休眠10s</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ sleep 10 &amp;</div><div class="line">[1] 7491</div><div class="line">#后台运行休眠10s</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ sleep 1000</div><div class="line">hh</div><div class="line">ffff</div><div class="line">#后台运行休眠10s</div><div class="line">^Z[1]   已完成               sleep 10</div><div class="line">#Crtl+z 停止前台运行</div><div class="line">[2]+  已停止               sleep 1000</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ bg</div><div class="line">[2]+ sleep 1000 &amp;</div><div class="line">#bg 转到后台运行</div></pre></td></tr></table></figure>
<h3 id="5-4-Listing-suspended-and-background-processes-（列出暂停和后台进程）"><a href="#5-4-Listing-suspended-and-background-processes-（列出暂停和后台进程）" class="headerlink" title="5.4 Listing suspended and background processes （列出暂停和后台进程）"></a>5.4 Listing suspended and background processes （列出暂停和后台进程）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ sleep 1000 </div><div class="line">^Z</div><div class="line"># ^Z 是暂停前台进程</div><div class="line">[1]+  已停止               sleep 1000</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ bg</div><div class="line"># bg 后台运行进程</div><div class="line">[1]+ sleep 1000 &amp;</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ jobs</div><div class="line"># jobs 显示后台进程</div><div class="line">[1]+  运行中               sleep 1000 &amp;</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ fg %1</div><div class="line"># fg%1 将后台进程1转到前台</div><div class="line">sleep 1000</div><div class="line">ddd</div><div class="line">ddd</div><div class="line">^Z</div><div class="line"># ^Z 是暂停进程</div><div class="line">[1]+  已停止               sleep 1000</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ jobs</div><div class="line">[1]+  已停止               sleep 1000</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ bg</div><div class="line">[1]+ sleep 1000 &amp;</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ fg %1</div><div class="line">sleep 1000</div><div class="line">^C</div><div class="line"># ^C是杀死进程</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ jobs</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$</div></pre></td></tr></table></figure>
<h3 id="5-5-Killing-a-process（杀死一个进程）"><a href="#5-5-Killing-a-process（杀死一个进程）" class="headerlink" title="5.5 Killing a process（杀死一个进程）"></a>5.5 Killing a process（杀死一个进程）</h3><p>1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ sleep 100 </div><div class="line">^Z</div><div class="line">[1]+  已停止               sleep 100</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ bg</div><div class="line">[1]+ sleep 100 &amp;</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ kill %1</div><div class="line"># kill%1 杀死进程1</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ jobs</div><div class="line">[1]+  已终止               sleep 100</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ jobs</div></pre></td></tr></table></figure></p>
<p>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ sleep 100 &amp;</div><div class="line">[1] 7579</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ jobs</div><div class="line">[1]+  运行中               sleep 100 &amp;</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ ps</div><div class="line">  PID TTY          TIME CMD</div><div class="line"> 2533 pts/1    00:00:00 bash</div><div class="line"> 7579 pts/1    00:00:00 sleep</div><div class="line"> 7580 pts/1    00:00:00 ps</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ kill 7579</div><div class="line"># kill 7579 使用（PID）号杀死进程</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ jobs</div><div class="line">[1]+  已终止               sleep 100</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ jobs</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$ ps</div><div class="line">  PID TTY          TIME CMD</div><div class="line"> 2533 pts/1    00:00:00 bash</div><div class="line"> 7581 pts/1    00:00:00 ps</div><div class="line">kuo@kuo-Inspiron-7420:~/unixstuff/backups$</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>ls -lag</td>
<td>list access rights for all files</td>
</tr>
<tr>
<td>chmod [options] file</td>
<td>change access rights for named file</td>
</tr>
<tr>
<td>command &amp;</td>
<td>run command in background</td>
</tr>
<tr>
<td>^C</td>
<td>kill the job running in the foreground</td>
</tr>
<tr>
<td>^Z</td>
<td>suspend the job running in the foreground</td>
</tr>
<tr>
<td>bg</td>
<td>background the suspended job</td>
</tr>
<tr>
<td>jobs</td>
<td>list current jobs</td>
</tr>
<tr>
<td>fg %1</td>
<td>foreground job number 1</td>
</tr>
<tr>
<td>kill %1</td>
<td>kill job number 1</td>
</tr>
<tr>
<td>ps</td>
<td>list current processes</td>
</tr>
<tr>
<td>kill 26152</td>
<td>kill process number 26152</td>
</tr>
</tbody>
</table>
<h3 id="6-环境变量"><a href="#6-环境变量" class="headerlink" title="6.环境变量"></a>6.环境变量</h3><p>% echo $OSTYPE</p>
<p>More examples of environment variables are</p>
<pre><code>USER (your login name)
HOME (the path name of your home directory)
HOST (the name of the computer you are using)
ARCH (the architecture of the computers processor)
DISPLAY (the name of the computer screen to display X windows)
PRINTER (the default printer to send print jobs)
PATH (the directories the shell should search to find a command)
</code></pre>]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> WMware </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux笔记(1)：VMware虚拟机 Ubuntu 16.04 安装 VMware Tools]]></title>
      <url>/2017/08/06/linux/Linux%E7%AC%94%E8%AE%B0(1)%EF%BC%9AVMware%E8%99%9A%E6%8B%9F%E6%9C%BA-Ubuntu-16-04-%E5%AE%89%E8%A3%85-VMware-Tools/</url>
      <content type="html"><![CDATA[<p>在VMware中装完Ubuntu后，为了与host之间互传文件，需要安装VMware tools。</p>
<h2 id="1、解决路径问题"><a href="#1、解决路径问题" class="headerlink" title="1、解决路径问题"></a>1、解决路径问题</h2><p>在“虚拟机设置”下修改“CD/DVD(SATA)”路径（以下关于linux.iso的说明为我的猜想，还未找到明确的说明），否则会出现如下提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">客户机操作系统已将 CD-ROM 门锁定，并且可能正在使用 CD-ROM，这可能会导致客户机无法识别介质的更改。</div><div class="line">如果可能，请在断开连接之前从客户机内部弹出 CD-ROM。确实要断开连接并覆盖锁定设置吗?</div></pre></td></tr></table></figure>
<p>解决：<br>一般刚安装完linux虚拟机时，这个路径指向的是iso安装文件，比如Ubuntu-16.04-desktop-amd64.iso。<br>在安装VMware Tools时，需要修改指向VMware Tools所在（VMware Workstation\linux.iso），<br>在这个路径下有个linux.iso文件，其中提供了linux操作系统平台需要的一些工具文件，当然包括VMware Tools安装文件。<br>为方便，我直接将安装目录下的linux.iso拷贝到 E:\Linuxidc.com虚拟机\Ubuntu16.04 目录下。</p>
<p>参考：<a href="http://www.linuxidc.com/Linux/2016-04/130806.htm" target="_blank" rel="external">安装 VMware Tools 时报 客户机操作系统已将 CD-ROM 门锁定，并且可能正在使用CD-ROM</a></p>
<h2 id="2-安装tools"><a href="#2-安装tools" class="headerlink" title="2.安装tools"></a>2.安装tools</h2><p>现在再开始进入系统后，在VMware菜单栏找到安装虚拟工具的时候，它会弹出一个文件夹，里面就有VMware Tools的安装包。<br>然后我们直接把WMwareTools拷贝出来到桌面吧</p>
<p>然后打开终端解压</p>
<p>命令：tar -xzvf  VMwareTools-10.0.6-3595377.tar.gz<br>进入解压后的目录，执行：sudo ./wmware-install.pl  然后就一直回车了。<br>Ubuntu会进行的很顺利，而其他发行版却未必。一直回车到底，到最后提示成功，reboot就可以了。<br>现在你可以在虚拟机与实体机之间自由复制文件了。</p>
<p>参考：<a href="http://www.linuxidc.com/Linux/2016-04/130807.htm" target="_blank" rel="external">VMware虚拟机 Ubuntu 16.04 安装 VMware Tools</a></p>
<hr>
<p>参考：<a href="https://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=1022525" target="_blank" rel="external">Installing VMware Tools in an Ubuntu virtual machine (1022525)</a><br>      <a href="http://jingyan.baidu.com/article/a17d52851ab9f98099c8f262.html" target="_blank" rel="external">成功安装VMware Tools!</a></p>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> WMware </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[怎样管理文件：好的命名]]></title>
      <url>/2017/08/01/%E9%9A%8F%E7%AC%94/%E6%80%8E%E6%A0%B7%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%EF%BC%9A%E5%A5%BD%E7%9A%84%E5%91%BD%E5%90%8D/</url>
      <content type="html"><![CDATA[<p>我收到了王小二、王小三、王小四三个人给我发的文件。我想打开王小二的文件，从文件名称上是看不出哪个是王小二的。即便三人发的文档格式不一样，王小二发的是 PPT,王小三发的是 PDF，王小四发的是 WORD，因为我极可能记不住，也不应该去记住这个细节。同理，同一个主题，多个版本，如果不再标题上做文章，自己也是无法快速提取想要的那个文件。比如写了一个方案，后来演变出了三个版本，自己修改了两个版本，王总查看审批修改了一个，名称都叫《××方案运营流程》。如果处于同一个文件夹，文件名冲突，可能变成《××方案运营流程》、《××方案运营流程 01》、《××方案运营流程 02》，这就真的成了三胞胎，不打开看看就不知道庐山真面目了。<br>我的解决方案逻辑如下：<br>把我们输入条件背后的决策理清楚，当我想找王小二发给我的关于《××方案运营流程》。关键识别特征条件应当是「王小二」、「××」、「流程」。再做进一步的规整，「王小二」对应的文件作者，「××」对应的内容主体，「流程」对应的是主题某个方面，后面两个构成了文件主题。所以靠谱的名称中应当包含这些可区别不同文件的关键词。<br>搞清楚上面那段话的意思，命名的时候就可以做到比较靠谱了。我列举几个我常用到命名格式。<br>•    {工作月报}#{军火生产部}#{王小二}#{2017-04-19}<br>•    {工作月报}#{军火生产部}#{王小二}#{王天霸修改}#{V1.0.0-2017-04-19}<br>上述格式时间可以去掉，不影响精准性召唤，但实际操作中去掉会有些不便。<br>有的时候，名称会比上面的还要复杂，加入了更多的维度。虽然长一些更有利于找到可能的目标文件，但也会造成在命名的那一刻不爽。当然，可以在复杂和精确度之间找到你自己认为比较平衡的一个点，不可以为了简短而丢失关键维度。我的实际操作中，一般也就输入两三个维度，就可以定位到我要找的文件。<br>如果结合 Listary 、Everything 提供的搜索语法，可以更精准命中你想要找的文件。但实际操作中，很少需要这样使用。</p>
<p>作者：AngryBug<br>链接：<a href="http://www.jianshu.com/p/99ca1531f375" target="_blank" rel="external">http://www.jianshu.com/p/99ca1531f375</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文件管理 </tag>
            
            <tag> 命名 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习(2)：资源下载]]></title>
      <url>/2017/07/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0(2)%EF%BC%9A%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>资源下载<br>嘉宾：张一茗 速感科技 CTO主题：给机器人一双慧眼——机器人视觉系统进化史<br>视频：<br><a href="http://jiangmen.gensee.com/webcast/site/vod/play-82fb6ca462c64124b77d831afcb17c98" target="_blank" rel="external">http://jiangmen.gensee.com/webcast/site/vod/play-82fb6ca462c64124b77d831afcb17c98</a><br>PDF：<a href="http://pan.baidu.com/s/1skNZGk9" target="_blank" rel="external">http://pan.baidu.com/s/1skNZGk9</a><br>嘉宾：高翔 清华大学自动化导航研究所博士生<br>主题：视觉SLAM的基础知识<br>视频：<br><a href="http://jiangmen.gensee.com/webcast/site/vod/play-be677f47f1a1484f895fe05eb6af8468" target="_blank" rel="external">http://jiangmen.gensee.com/webcast/site/vod/play-be677f47f1a1484f895fe05eb6af8468</a><br>PDF：<a href="http://pan.baidu.com/s/1o8lMt42" target="_blank" rel="external">http://pan.baidu.com/s/1o8lMt42</a><br>嘉宾：张浩 蓝胖子机器人 CTO<br>主题：Moble manipulator as general purpose robot: technology &amp; vision<br>视频：<br><a href="http://jiangmen.gensee.com/webcast/site/vod/play-f784df3a2d14450bb6d1c685d85fda8c" target="_blank" rel="external">http://jiangmen.gensee.com/webcast/site/vod/play-f784df3a2d14450bb6d1c685d85fda8c</a><br>PDF：<a href="http://pan.baidu.com/s/1nv0b64p" target="_blank" rel="external">http://pan.baidu.com/s/1nv0b64p</a><br>嘉宾：何梦文 CMU计算机工程系博士生<br>主题：RobotSDK介绍—— 一种自顶向下的模块化软件开发框架<br>视频：<br><a href="http://jiangmen.gensee.com/webcast/site/vod/play-87fbb1e231344c6a836d816eb00c1c37" target="_blank" rel="external">http://jiangmen.gensee.com/webcast/site/vod/play-87fbb1e231344c6a836d816eb00c1c37</a><br>PDF：<a href="http://pan.baidu.com/s/1hrSwgLmCS231n" target="_blank" rel="external">http://pan.baidu.com/s/1hrSwgLmCS231n</a> – Convolutional Neural Networks forVisual Recognition(Winter 2016)：链接：<a href="http://pan.baidu.com/s/1i562CIh" target="_blank" rel="external">http://pan.baidu.com/s/1i562CIh</a> 密码：63un<br>CS231n ：链接：<a href="http://pan.baidu.com/s/1bo808RP密码：mq4n" target="_blank" rel="external">http://pan.baidu.com/s/1bo808RP密码：mq4n</a><br>hinton neuralnets-2012-001 :链接：<a href="http://pan.baidu.com/s/1i4WAKoH密码：3dgehinton-ml" target="_blank" rel="external">http://pan.baidu.com/s/1i4WAKoH密码：3dgehinton-ml</a> ：链接：<a href="http://pan.baidu.com/s/1kUASfLt密码：s1j2" target="_blank" rel="external">http://pan.baidu.com/s/1kUASfLt密码：s1j2</a><br>Udacity : 链接：<a href="http://pan.baidu.com/s/1hsiimaC密码：y0sg" target="_blank" rel="external">http://pan.baidu.com/s/1hsiimaC密码：y0sg</a><br>深度学习进阶：链接: <a href="https://pan.baidu.com/s/1eRSDlqa" target="_blank" rel="external">https://pan.baidu.com/s/1eRSDlqa</a> 密码: 419a<br>深度学习基础介绍-机器学习：链接: <a href="https://pan.baidu.com/s/1o8K5DEU" target="_blank" rel="external">https://pan.baidu.com/s/1o8K5DEU</a> 密码: 7hew<br>python 数据分析 ：链接：<a href="http://pan.baidu.com/s/1qY4S1L6密码：qw6mPython入门课程" target="_blank" rel="external">http://pan.baidu.com/s/1qY4S1L6密码：qw6mPython入门课程</a> ： 链接：<a href="http://pan.baidu.com/s/1c3Zd3g密码：dv7lScikit" target="_blank" rel="external">http://pan.baidu.com/s/1c3Zd3g密码：dv7lScikit</a> Learn Machine Learning SVM Tutorialwith Python视频课程：链接：<a href="http://pan.baidu.com/s/1bWjlAA" target="_blank" rel="external">http://pan.baidu.com/s/1bWjlAA</a> 密码：f0pg<br>Tensorflow源码级技术分享集(1): 链接：<a href="http://pan.baidu.com/s/1qXBxNMs密码：us26TensorFlow教程" target="_blank" rel="external">http://pan.baidu.com/s/1qXBxNMs密码：us26TensorFlow教程</a> : 链接：<a href="http://pan.baidu.com/s/1dEPr1kd密码：8gjy" target="_blank" rel="external">http://pan.baidu.com/s/1dEPr1kd密码：8gjy</a><br>机器学习基石16国立台湾大学(林轩田) ：链接：<a href="http://pan.baidu.com/s/1geLjFVX" target="_blank" rel="external">http://pan.baidu.com/s/1geLjFVX</a> 密码：glht机器学习技法16国立台湾大学(林轩田) ：链接：<a href="http://pan.baidu.com/s/1i4ZYBzB密码：0zkm" target="_blank" rel="external">http://pan.baidu.com/s/1i4ZYBzB密码：0zkm</a><br>老段带你学鸟哥-服务器篇 ：链接：<a href="http://pan.baidu.com/s/1nuZk0Hj密码：nmrg老段带你学鸟哥-基础篇" target="_blank" rel="external">http://pan.baidu.com/s/1nuZk0Hj密码：nmrg老段带你学鸟哥-基础篇</a> ：链接：<a href="http://pan.baidu.com/s/1qYDFYjy密码：0bbo" target="_blank" rel="external">http://pan.baidu.com/s/1qYDFYjy密码：0bbo</a><br>模式识别35国防科学技术大学(蔡宣平) ： 链接：<a href="http://pan.baidu.com/s/1kUPLhAJ密码：zvy3徐亦达老师机器学习（高阶）" target="_blank" rel="external">http://pan.baidu.com/s/1kUPLhAJ密码：zvy3徐亦达老师机器学习（高阶）</a> ：链接：<a href="http://pan.baidu.com/s/1eRFfXiM密码：tbgy中科院统计学习基础43讲" target="_blank" rel="external">http://pan.baidu.com/s/1eRFfXiM密码：tbgy中科院统计学习基础43讲</a> :链接：<a href="http://pan.baidu.com/s/1slAWgHZ密码：htc5统计机器学习41上海交大(张志华" target="_blank" rel="external">http://pan.baidu.com/s/1slAWgHZ密码：htc5统计机器学习41上海交大(张志华</a>) ：链接：<a href="http://pan.baidu.com/s/1jIRzyke密码：41sd" target="_blank" rel="external">http://pan.baidu.com/s/1jIRzyke密码：41sd</a><br>数据分析 :链接：<a href="http://pan.baidu.com/s/1slHHIoP密码：wv3f" target="_blank" rel="external">http://pan.baidu.com/s/1slHHIoP密码：wv3f</a></p>
<p>自然语言理解64中科院(宗成庆) ：链接：<a href="http://pan.baidu.com/s/1i5zHfaH密码：of19" target="_blank" rel="external">http://pan.baidu.com/s/1i5zHfaH密码：of19</a><br>斯坦福NLP课程 :链接：<a href="http://pan.baidu.com/s/1pLPTmjD密码：hszc" target="_blank" rel="external">http://pan.baidu.com/s/1pLPTmjD密码：hszc</a></p>
<p>CNCC 2016 演讲 ：链接：<a href="http://pan.baidu.com/s/1o7D3LqU密码：jlm7" target="_blank" rel="external">http://pan.baidu.com/s/1o7D3LqU密码：jlm7</a></p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python基础(2)：print()]]></title>
      <url>/2017/07/26/python/python%E5%9F%BA%E7%A1%80%EF%BC%882%EF%BC%89%EF%BC%9Aprint()/</url>
      <content type="html"><![CDATA[<h1 id="print-字符串"><a href="#print-字符串" class="headerlink" title="print 字符串"></a>print 字符串</h1><p>python 中 print 字符串 要加’’或者””<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(&apos;hello world&apos;)</div><div class="line">&apos;&apos;&apos;</div><div class="line">hello world</div><div class="line">&apos;&apos;&apos;</div><div class="line">&gt;&gt;&gt; print(&quot;hello world 2&quot;)</div><div class="line">&apos;&apos;&apos;</div><div class="line">hello world 2</div><div class="line">&apos;&apos;&apos;</div></pre></td></tr></table></figure></p>
<h1 id="print-字符串叠加"><a href="#print-字符串叠加" class="headerlink" title="print 字符串叠加"></a>print 字符串叠加</h1><p>可以使用 + 将两个字符串链接起来, 如以下代码.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(&apos;Hello world&apos;+&apos; Hello Hong Kong&apos;)</div><div class="line">&quot;&quot;&quot;</div><div class="line">Hello world Hello Hong Kong</div><div class="line">&quot;&quot;&quot;</div></pre></td></tr></table></figure></p>
<h1 id="简单运算"><a href="#简单运算" class="headerlink" title="简单运算"></a>简单运算</h1><p>可以直接print 加法+,减法-,乘法*,除法/. 注意：字符串不可以直接和数字相加，否则出现错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(1+1)</div><div class="line">&quot;&quot;&quot;</div><div class="line">2</div><div class="line">&quot;&quot;&quot;</div><div class="line">&gt;&gt;&gt; print(3-1)</div><div class="line">&quot;&quot;&quot;</div><div class="line">2</div><div class="line">&quot;&quot;&quot;</div><div class="line">&gt;&gt;&gt; print(3*4)</div><div class="line">&quot;&quot;&quot;</div><div class="line">12</div><div class="line">&quot;&quot;&quot;</div><div class="line">&gt;&gt;&gt; print(12/4)</div><div class="line">&quot;&quot;&quot;</div><div class="line">3.0</div><div class="line">&quot;&quot;&quot;</div><div class="line">&gt;&gt;&gt; print(&apos;iphone&apos;+4) #字符串不可以直接和数字相加</div><div class="line">&quot;&quot;&quot;</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;pyshell#10&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">    print(&apos;iphone&apos;+4)</div><div class="line">TypeError: Can&apos;t convert &apos;int&apos; object to str implicitly</div><div class="line">&quot;&quot;&quot;</div></pre></td></tr></table></figure></p>
<p>int() 和 float()；当int()一个浮点型数时，int会保留整数部分,比如 int(1.9),会输出1,而不是四舍五入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(int(&apos;2&apos;)+3) #int为定义整数型</div><div class="line">&quot;&quot;&quot;</div><div class="line">5</div><div class="line">&quot;&quot;&quot;</div><div class="line">&gt;&gt;&gt; print(int(1.9))  #当int一个浮点型数时，int会保留整数部分</div><div class="line">&quot;&quot;&quot;</div><div class="line">1</div><div class="line">&quot;&quot;&quot;</div><div class="line">&gt;&gt;&gt; print(float(&apos;1.2&apos;)+3) #float()是浮点型，可以把字符串转换成小数</div><div class="line">&quot;&quot;&quot;&quot;</div><div class="line">4.2</div><div class="line">&quot;&quot;&quot;&quot;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python基础（1）：安装]]></title>
      <url>/2017/07/26/python/python%E5%9F%BA%E7%A1%80%EF%BC%881%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<h1 id="Windows-安装"><a href="#Windows-安装" class="headerlink" title="Windows 安装"></a>Windows 安装</h1><p> 请到<a href="https://www.python.org/" target="_blank" rel="external">官网</a>下载需要的版本的安装包， 下载所需(注意自己的系统是32位还是64位)，安装路径最好选择默认, 不然对于新手容易出现各种问题。</p>
<p>Windows 安装附加要点:<br>设置环境变量:<br>1.找到安装路径,默认</p>
<blockquote>
<p>C:\Users\你的用户名\AppData\Local\Programs\Python\Python35-32 粘贴路径 </p>
</blockquote>
<p>2.我的电脑 - 属性-高级-环境变量-系统变量中的PATH为（复制路径）:</p>
<blockquote>
<p>C:\Users*<em>你的用户名*</em>\AppData\Local\Programs\Python\Python35-32;</p>
</blockquote>
<p>3.设置环境变量:</p>
<blockquote>
<p>C:\Users\你的用户名\AppData\Local\Programs\Python\Python35-32\Scripts;</p>
</blockquote>
<h1 id="检测安装是否成功？"><a href="#检测安装是否成功？" class="headerlink" title="检测安装是否成功？"></a>检测安装是否成功？</h1><p>打开idle, print(1) 如果系统输出1,则表明安装成功.</p>
<blockquote>
<p>  “&gt;&gt;&gt;print(1)<br>      1<br>  “&gt;&gt;&gt;</p>
</blockquote>
<h1 id="运行Python"><a href="#运行Python" class="headerlink" title="运行Python"></a>运行Python</h1><p>　　安装成功后，打开命令提示符窗口，敲入python后，会出现：<br><img src="https://www.liaoxuefeng.com/files/attachments/001446601591019cbba6e698d32429bb4754753d86e286a000/l" alt="此处输入图片的描述"></p>
<p>　　看到上面的画面，就说明Python安装成功！</p>
<p>　　你看到提示符<code>&gt;&gt;&gt;</code>就表示我们已经在Python交互式环境中了，可以输入任何Python代码，回车后会立刻得到执行结果。<br>　　现在，输入exit()并回车，就可以退出Python交互式环境（直接关掉命令行窗口也可以）。</p>
]]></content>
      
        <categories>
            
            <category> python基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习(1)：普通程序员如何向人工智能靠拢]]></title>
      <url>/2017/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0(1)%EF%BC%9A%E6%99%AE%E9%80%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%90%91%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E9%9D%A0%E6%8B%A2/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相信看到这篇文章的朋友，几乎都想成为机器学习科学家。</p>
<p>事实上，绝大多数的付费课程，基本上都有完全免费的课程放在另一个地方。我们只是把这些信息整理好，告诉你在哪儿可以找到他们，以及通过什么样的顺序进行学习。</p>
<p>这样，哪怕你是还没毕业的大学生，或者是初入职场的工程师，都可以通过自学的方式掌握机器学习科学家的基础技能，并在论文、工作甚至日常生活中快速应用。</p>
<p>在这里我们推荐一份用户友好型的机器学习教程，你可以通过几个月的学习成为机器学习科学家，完全免费。</p>
<h1 id="一份用户友好型的机器学习教程"><a href="#一份用户友好型的机器学习教程" class="headerlink" title="一份用户友好型的机器学习教程"></a>一份用户友好型的机器学习教程</h1><p>当你学习机器学习课程时，有没有被信息过载所淹没？</p>
<p>大部分的学习者都遇到了这个问题，这不是他们的错，因为绝大多数的机器学习课程都过于关注个别算法了。 </p>
<p>没错，虽然算法很重要，但他们还是把太多时间花在了算法上。 </p>
<p>以至于……你几乎很难在短时间内走完一遍机器学习的流程，从而感受到通过它解决具体数据问题的巨大兴奋。</p>
<p>这些机器学习课程关注于算法是因为它容易教。相比之下，如果机器学习老师要带你走一遍机器学习的流程，那么他需要搭建计算环境，完成数据采集、清洗、拆分，特征处理，模型调参和模型预测，甚至他还需要一个面向学习者的交互界面。老师哪有这么多的工具，与其手把手带着学生走一遭，还不如学习机器学习算法。 </p>
<p>但这样的问题是，很难有人能坚持通过自学，成为一个卓越的机器学习科学家。哪怕他是数学博士，或者技术高超的程序员，都很容易陷在细节中而难以有具体项目实现的成就感。 </p>
<p>这份教程将会带来完全不同的思路。它非常适合自学者，即便完全没有编程的基础，也能通过恰当的工具快速实现机器学习模型，解决工作、生活中遇到的具体问题。</p>
<p>值得注意的是，我们享用了世界顶级的机器学习资源，而不需要花费 1 分钱。 </p>
<h1 id="自我学习的方法"><a href="#自我学习的方法" class="headerlink" title="自我学习的方法"></a>自我学习的方法</h1><p>我们推荐通过 Doing Shit（不是技术术语）完成你的学习。</p>
<p>在这之前你也许已经学习过机器学习了，但从我和朋友们的经验来看，往往会被各种神秘的符号、公式、大量的教科书和论文整的晕头转向，然后再也不想碰这恼人的玩意了。</p>
<p>我们的方法会更加友好，它的学习过程就像小朋友学习一样，你会了解一些基础的知识（但不一定要完全弄懂），然后通过好用的工具快速实现出来就好了。而当你被建模出来的结果吸引，那时候我们才谈算法背后的数学逻辑和计算逻辑。</p>
<p>所以我们会在学习中做很多机器学习项目，这样的好处是当你面对一个工作机会时，你就是一个经验丰富的机器学习科学家了！</p>
<p>当然自学本身是需要自律的，这本教程将一直陪伴着你，以下是 4 个步骤。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1.前提条件 （不需要完全弄懂）</div><div class="line">统计学、编程和数学（也可以不需要编程） </div><div class="line"></div><div class="line">2.海绵模式 </div><div class="line">把自己浸泡在机器学习的各种理论中 </div><div class="line"></div><div class="line">3.目标实践 </div><div class="line">通过机器学习包实践 9 个有意思的题目 </div><div class="line"></div><div class="line">4.机器学习项目 </div><div class="line">深度参与到感兴趣的项目和领域中</div></pre></td></tr></table></figure></p>
<h2 id="步骤一：前提条件"><a href="#步骤一：前提条件" class="headerlink" title="步骤一：前提条件"></a>步骤一：前提条件</h2><p>机器学习之所以看起来很吓人，是因为总伴随着那些晦涩难懂的术语。实际上，即便你是中文系毕业的，也可以学好机器学习。不过，我们需要你在一些领域有基础的理解。</p>
<p>好消息是，一旦你满足了前提条件，其余的将会非常容易。事实上，几乎所有的机器学习都是把统计学和计算机科学的概念应用于数据领域</p>
<p>任务：确保你了解基础的统计学、编程和数学 </p>
<blockquote>
<p>统计学：理解统计学、特别是贝叶斯概率对许多机器学习算法来说都是至关重要的。<br>免费的指南：<a href="https://elitedatascience.com/learn-statistics-for-data-science" target="_blank" rel="external">How to Learn Statistics for Data Science, The Self-Starter Way </a></p>
<p>编程：懂得编程将会更灵活的应用机器学习。<br>免费的指南：<a href="https://elitedatascience.com/learn-python-for-data-science" target="_blank" rel="external">How to Learn Python for Data Science, The Self-Starter Way </a></p>
<p>数学：对原始算法的研究需要线性代数、多变量计算的基础。<br>免费的指南：<a href="https://elitedatascience.com/learn-math-for-data-science" target="_blank" rel="external">How to Learn Math for Data Science, The Self-Starter Way </a></p>
</blockquote>
<p>你可以先看看以上教程，给你的机器学习道路打下知识基础。</p>
<h2 id="步骤二：海绵模式"><a href="#步骤二：海绵模式" class="headerlink" title="步骤二：海绵模式"></a>步骤二：海绵模式</h2><p>海绵模式是尽可能吸收足够多的机器学习理论知识。 </p>
<p>现在有些人可能会想：“如果我不打算进行原创性研究，为什么在可以使用现有机器学习包的时候，还需要学习理论？”<br>这是一个合理的问题！ </p>
<p>然而，如果你想把机器学习更灵活的应用于日常工作，学习一些基础理论还是很有好处的，而且你并不需要完全弄懂。下面我们会剧透学习机器学习理论的 5 个理由。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">（1）规划和数据采集</div><div class="line">数据采集真是一个昂贵和耗时的过程！那么我需要采集哪些类型的数据？根据模型的不同，我需要多少数据？这个挑战是否可行？ </div><div class="line"></div><div class="line">（2）数据假设和预处理 </div><div class="line">不同的算法对数据输入有不同的假设，那我应该如何预处理我的数据？我应该正则化吗？假如我的模型缺少一些数据，它还稳定吗？离群值怎么处理？ </div><div class="line"></div><div class="line">（3）解释模型结果 </div><div class="line">简单的认为机器学习是一个“黑盒子”的概念是错误的。是的，并不是所有的结果都直接可以解释，但你需要诊断自己的模型然后改善它们。我要怎么评估模型是过拟合还是欠拟合？我要向业务利益相关者怎么解释这些结果？以及模型还有多少的改善空间？ </div><div class="line"></div><div class="line">（4）改进和调整模型 </div><div class="line">你的第一次训练很少会达到最佳模式，你需要了解不同的调参和正则化方法的细微差别。如果我的模型是过拟合了，我该如何补救？我应该花更多时间在特征工程上，还是数据采集上？我可以组合我的模型吗？ </div><div class="line"></div><div class="line">（5）驱动商业价值 </div><div class="line">机器学习从来不会在真空中完成。如果你不了解武器库中的工具，就无法最大化发挥它们的效能。在这么多结果指标中，哪些是优化的参考指标？哪个更为重要？或者还有其他的算法会表现更好吗？</div></pre></td></tr></table></figure></p>
<p>好消息是，你不需要一开始就知道所有问题的答案。所以我们推荐你从学习足够的理论开始，然后快速进入到实践。这样的话，你比较能够坚持下来，并在一段时间后真正精通机器学习。</p>
<p>以下是一些免费的机器学习资料。</p>
<h3 id="2-1-机器学习视频课程"><a href="#2-1-机器学习视频课程" class="headerlink" title="2.1 机器学习视频课程"></a>2.1 机器学习视频课程</h3><p>这是来自哈佛大学和耶鲁大学的世界级课程。</p>
<p>任务：完成至少一门课程 </p>
<blockquote>
<p>哈佛大学数据科学课程<br>端到端的数据科学课程。相比吴恩达的课程，它对机器学习的重视程度较低，但是从数据收集到分析，你可以在这里学到整个数据科学的工作流程。<br>课程主页：<a href="http://cs109.github.io/2015/" target="_blank" rel="external">http://cs109.github.io/2015/</a></p>
<p>斯坦福大学机器学习课程<br>这是吴恩达的著名课程，这些视频说清楚了机器学习背后的核心理念。如果你的时间只能上一节课，我们建议这个。<br>课程主页：<br><a href="https://www.youtube.com/watch?v=qeHZOdmJvFU&amp;list=PLZ9qNFMHZ-A4rycgrgOYma6zxF4BZGGPW&amp;index=1" target="_blank" rel="external">https://www.youtube.com/watch?v=qeHZOdmJvFU&amp;list=PLZ9qNFMHZ-A4rycgrgOYma6zxF4BZGGPW&amp;index=1</a></p>
</blockquote>
<h3 id="2-2-机器学习参考资料"><a href="#2-2-机器学习参考资料" class="headerlink" title="2.2 机器学习参考资料"></a>2.2 机器学习参考资料</h3><p>接下来我们推荐行业中两本经典的教材。 </p>
<p>任务：看这些 PDF 作为教科书 </p>
<blockquote>
<p>An Introduction to Statistical Learning<br>Gentler 在书里介绍了统计学习的基本要素，适合所有机器学习的学习者。<br>PDF 地址：<a href="http://www-bcf.usc.edu/~gareth/ISL/ISLR%20Sixth%20Printing.pdf" target="_blank" rel="external">http://www-bcf.usc.edu/~gareth/ISL/ISLR%20Sixth%20Printing.pdf</a></p>
<p>Elements of Statistical Learning<br>严格的介绍了机器学习理论和数学，推荐给机器学习的研究员。<br>PDF 地址：<a href="http://statweb.stanford.edu/~tibs/ElemStatLearn/" target="_blank" rel="external">http://statweb.stanford.edu/~tibs/ElemStatLearn/</a></p>
</blockquote>
<h3 id="2-3-成功的关键"><a href="#2-3-成功的关键" class="headerlink" title="2.3 成功的关键"></a>2.3 成功的关键</h3><p>以下是每个步骤成功的关键。 </p>
<p>A：注重大局，总是问为什么<br>每当你被介绍一个新概念时，问一句“为什么”。为什么在某些情况下要使用决策树而不是回归？为什么要规范参数？为什么要拆分数据集？当你了解为什么使用每个工具时，你将成为真正的机器学习从业者。 </p>
<p>B：接受你不会记得所有学过的东西<br>不要疯狂的做笔记，也不要每个课程都复习 3 次。在自己的实际工作中，你会经常需要回过头查看。</p>
<p>C：继续前进，不要气馁<br>尽量避免在一个话题上拖太久的时间。即便是对于机器学习教授来说，有些概念也很不好解释。但是当你在实践中开始应用时，你会很快就懂得概念的真实含义。 </p>
<p>D：视频比教科书更有效<br>从我们的经验来看，教科书是很好的参考工具，但它很难坚持。我们强烈推荐视频讲座的形式。 </p>
<h2 id="步骤三：有目的实践"><a href="#步骤三：有目的实践" class="headerlink" title="步骤三：有目的实践"></a>步骤三：有目的实践</h2><p>在海绵模式之后，我们会通过刻意练习的方式磨练技能，把机器学习能力提高到一个新水平。目标包括三个方面：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.实践完整的机器学习流程：包括数据收集、清洗、预处理，建立模型，调整参数和模型评估。 </div><div class="line"></div><div class="line">2.在真实的数据集中练习，逐渐建立哪种模型适合哪种挑战的直觉。</div><div class="line"></div><div class="line">3.深入到一个具体主题中，例如在数据集中应用不同类型的聚类算法，看哪些效果最好。</div></pre></td></tr></table></figure></p>
<p>在完成这些步骤后，当你开始解决大型项目时就不会不知所措了。</p>
<h3 id="3-1-机器学习工具"><a href="#3-1-机器学习工具" class="headerlink" title="3.1 机器学习工具"></a>3.1 机器学习工具</h3><p>为了快速实现机器学习模型，我们推荐使用现成的建模工具。这样的话，你会在短时间内练习整个机器学习的工作流程，而无需在任何一个步骤花费太多时间。这会给你非常有价值的“大局直觉”（Big Picture Intuition）。</p>
<p>Python：Scikit-Learn<br>Scikit-learn 和 Sklearn 是通用机器学习中 Python 的黄金标准库，它具有常规算法的实现。 </p>
<p>R：Caret<br>Caret 为 R 语言中的模型包提供一个统一的界面。它还包括了预处理、数据拆分、模型评估的功能，使其成为一个完整的端到端解决方案。 </p>
<h3 id="3-2-实践数据集"><a href="#3-2-实践数据集" class="headerlink" title="3.2 实践数据集"></a>3.2 实践数据集</h3><p>学习了工具后，你还需要一些数据集。数据科学和机器学习的艺术，很多都在于解决问题时的几十个微观决定。我们会在不同的数据集中看到建模的结果。</p>
<p>任务：从以下选项中选择 5 到 10 个数据集。我们建议从 UCI 的机器学习库开始，例如你可以选择 3 个数据集，分别用于回归、分类和聚类。 </p>
<p>在进行机器学习工程的时候，想想以下问题：</p>
<blockquote>
<p>你需要为每个数据集执行哪些类型的预处理？<br>你需要进行降维操作吗？你可以使用什么方法？<br>你可以如何拆分数据集？<br>你怎么知道模型是否出现“过拟合”？<br>你应该使用哪些类型的性能指标？<br>不同的参数调整会如何影响模型的结果？<br>你能够进行模型组合以得到更好的结果吗？<br>你的聚类结果和直观的相符么？</p>
</blockquote>
<p><strong>UCI 机器学习报告</strong><br>UCI 机器学习报告采集了超过 350 个不同的数据集，专门为机器学习提供训练数据。你可以按照任务搜索（回归、分类或聚类），也可以按照行业、数据集大小搜索。<br><a href="http://archive.ics.uci.edu/ml/" target="_blank" rel="external">http://archive.ics.uci.edu/ml/</a></p>
<p><strong>Kaggle</strong><br>Kaggle.com 以举办数据科学比赛闻名，但是该网站还拥有超过 180 个社区数据集，它们包含了有趣的话题，从用户宠物小精灵到欧洲足球比赛的数据应有尽有。<br><a href="https://www.kaggle.com/datasets" target="_blank" rel="external">https://www.kaggle.com/datasets</a></p>
<p><strong>Data.gov</strong><br>如果你正在寻找社会科学或者与政府有关的数据集，请查看 Data.gov。这是美国政府开放数据集合，你可以搜索超过 190,000 个数据集。<br><a href="https://www.data.gov/" target="_blank" rel="external">https://www.data.gov/</a></p>
<h2 id="步骤四：完成机器学习项目"><a href="#步骤四：完成机器学习项目" class="headerlink" title="步骤四：完成机器学习项目"></a>步骤四：完成机器学习项目</h2><p>好了，现在到了真正有趣的部分了。到目前为止，我们已经涵盖了前提条件、基本理论和有目的实践。现在我们准备好进入更大的项目。 </p>
<p>这一步骤的目标是将机器学习技术整合到完整的、端到端的分析中。 </p>
<h3 id="4-1-完成一个机器学习项目"><a href="#4-1-完成一个机器学习项目" class="headerlink" title="4.1 完成一个机器学习项目"></a>4.1 完成一个机器学习项目</h3><p>泰坦尼克号幸存者预测挑战是一个非常受欢迎的机器学习实践项目，事实上，这是 Kaggle.com 上最受欢迎的比赛。 </p>
<p>我们喜欢以这个项目作为起点，因为它有很多伟大的教程。你可以从中了解到这些有经验的数据科学家们是怎么处理数据探索、特征工程和模型调参的。 </p>
<p><strong>Python 教程</strong><br>我们真的非常喜欢这个教程，因为它教会你如何进行数据预处理和纠正数据。教程由 Pycon UK 提供。<br>教程地址：<a href="https://github.com/savarin/pyconuk-introtutorial" target="_blank" rel="external">https://github.com/savarin/pyconuk-introtutorial</a></p>
<p><strong>R 教程</strong><br>在 R 中使用 Caret 包来处理几个不同的模型。本教程很好总结了端到端的预测建模过程。<br>教程地址：<a href="http://amunategui.github.io/binary-outcome-modeling/" target="_blank" rel="external">http://amunategui.github.io/binary-outcome-modeling/</a></p>
<p>这是一个“不负责任”的快速教程：仅仅是个教程，跳过了理论讲解。不过这也很有用，而且它显示了如何进行随机森林操作。<br>教程地址：<a href="http://will-stanton.com/machine-learning-with-r-an-irresponsibly-fast-tutorial/" target="_blank" rel="external">http://will-stanton.com/machine-learning-with-r-an-irresponsibly-fast-tutorial/</a></p>
<h3 id="4-2-从头写个算法"><a href="#4-2-从头写个算法" class="headerlink" title="4.2 从头写个算法"></a>4.2 从头写个算法</h3><p>为了对机器学习有更深的理解，没有什么比从头写个算法有帮助了，因为魔鬼总是在细节里。</p>
<p>我们建议从一些简单的开始，例如逻辑回归、决策树或者 KNN 算法。</p>
<p>这个项目也为你提供了一个将数据语言翻译成程序语言的实践。当你想把最新的学术界研究应用于工作时，这个技能将会十分方便。 </p>
<p>而如果你卡住了，这里有一些提示： </p>
<blockquote>
<p>维基百科有很多好资源，它有很多常见算法的伪代码。<br>为了培养你的灵感，请尝试查看现有机器学习软件包的源代码。<br>将你的算法分解，为采样、梯度下降等编写单独的功能<br>从简单开始，在尝试编写随机森林前，先执行一个决策树。</p>
</blockquote>
<h3 id="4-3-选择一个有趣的项目或领域"><a href="#4-3-选择一个有趣的项目或领域" class="headerlink" title="4.3 选择一个有趣的项目或领域"></a>4.3 选择一个有趣的项目或领域</h3><p>如果你没有好奇心，你是很难学好的。但目前为止，也许你已经找到了想坚持下去的领域，那么开始建模吧！</p>
<p>老实说这是机器学习最好的部分了。这是一个强大的工具，而一旦你开始理解，很多想法都会主动找上门。<br>好消息是，如果你一直在跟踪，也准备好从事这份工作，那么你的收获会远超你的想象！ </p>
<blockquote>
<p>我们也推荐了 6 个有趣的机器学习项目。<br>地址：<a href="https://elitedatascience.com/machine-learning-projects-for-beginners" target="_blank" rel="external">https://elitedatascience.com/machine-learning-projects-for-beginners</a><br>恭喜你到达了自学指南的终点</p>
</blockquote>
<p>这里有一个好消息，如果你已经遵循并完成了所有任务，那么你在应用机器学习上将会比 90% 自称是数据科学家的人更好。 </p>
<p>而更好的消息是，你还有很多东西要学习。例如深度学习、强化学习、迁移学习、对抗生成模型等等。 </p>
<p>成为最好的机器学习科学家的关键是永远不要停止学习。在这个充满活力、激动人心的领域，开始你的旅程吧!</p>
<p>该教程由EliteDataScience提供，我们翻译了这份教程，略有改动。这是原文链接：<a href="https://elitedatascience.com/learn-machine-learning" target="_blank" rel="external">https://elitedatascience.com/learn-machine-learning</a></p>
<p>「范式大学」由第四范式发起，致力于成为“数据科学家”的黄埔军校。「范式大学系列课程」会和大家推荐戴文渊、杨强、陈雨强等机器学习领域顶尖从业人士的最新分享，以及由第四范式产品团队推荐和整理的机器学习材料。</p>
<p><a href="http://mp.weixin.qq.com/s/-gk4zwJe4L0ouOmU4mOvPA" target="_blank" rel="external">转自：第四范式</a></p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[日常笔记：希腊字母表(配读音)]]></title>
      <url>/2017/07/24/%E9%9A%8F%E7%AC%94/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0-%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%A1%A8-%E9%85%8D%E8%AF%BB%E9%9F%B3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>1 Α α alpha a:lf 阿尔法<br>2 Β β beta bet 贝塔<br>3 Γ γ gamma ga:m 伽马<br>4 Δ δ delta delt 德尔塔<br>5 Ε ε epsilon ep`silon 伊普西龙  </p>
<p>6 Ζ ζ zeta zat 截塔<br>7 Η η eta eit 艾塔<br>8 Θ θ thet θit 西塔<br>9 Ι ι iot aiot 约塔<br>10 Κ κ kappa kap 卡帕<br>11 ∧ λ lambda lambd 兰布达<br>12 Μ μ mu mju 缪<br>13 Ν ν nu nju 纽<br>14 Ξ ξ xi ksi 克西<br>15 Ο ο omicron omik`ron 奥密克戎 </p>
<p>16 ∏ π pi pai 派<br>17 Ρ ρ rho rou 肉<br>18 ∑ σ sigma `sigma 西格马 </p>
<p>19 Τ τ tau tau 套<br>20 Υ υ upsilon jup`silon 宇普西龙  </p>
<p>21 Φ φ phi fai 佛爱<br>22 Χ χ chi phai 凯<br>23 Ψ ψ psi psai 普西<br>24 Ω ω omega o`miga 欧米伽</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git使用（二）：git 初学解决错误]]></title>
      <url>/2017/07/24/git/git%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89git%E5%88%9D%E5%AD%A6%E8%A7%A3%E5%86%B3%E9%94%99%E8%AF%AF/</url>
      <content type="html"><![CDATA[<h2 id="1-git-init-产生的目录解释"><a href="#1-git-init-产生的目录解释" class="headerlink" title="1.git init 产生的目录解释"></a>1.git init 产生的目录解释</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error: src refspec master does not match any.</div></pre></td></tr></table></figure>
<p>引起该错误的原因是，目录中没有文件，空目录是不能提交上去的</p>
<h2 id="2-错误提示："><a href="#2-错误提示：" class="headerlink" title="2.错误提示："></a>2.错误提示：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error: insufficient permission <span class="keyword">for</span> adding an object to repository database ./objects</div></pre></td></tr></table></figure>
<p>服务端没有可写目录的权限</p>
<h2 id="3-错误提示："><a href="#3-错误提示：" class="headerlink" title="3.错误提示："></a>3.错误提示：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fatal: remote origin already exists.</div></pre></td></tr></table></figure>
<p>  解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote rm origin</div></pre></td></tr></table></figure></p>
<h2 id="4-错误提示："><a href="#4-错误提示：" class="headerlink" title="4.错误提示："></a>4.错误提示：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error: failed to push som refs to ........</div></pre></td></tr></table></figure>
<p>  解决办法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull origin master //先pull 下来 再push 上去</div></pre></td></tr></table></figure></p>
<h2 id="5-常用git命令的解释："><a href="#5-常用git命令的解释：" class="headerlink" title="5.常用git命令的解释："></a>5.常用git命令的解释：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Git init //在当前项目工程下履行这个号令相当于把当前项目git化，变身！</div><div class="line">git add .//把当前目次下代码参加git的跟踪中，意思就是交给git经管，提交到本地库</div><div class="line">git add &lt;file&gt; //把当前文件参加的git的跟踪中，交给git经管，提交到本地库</div><div class="line">git commit -m “…”//相当于写点提交信息</div><div class="line">git remote add origin git＠github.com:ellocc/gittest.git //这个相当于指定本地库与github上的哪个项目相连</div><div class="line">git push -u origin master //将本地库提交到github上。</div><div class="line">git <span class="built_in">clone</span> git＠github.com:ellocc/gittest.git  //将github上的项目down下来。</div><div class="line">git fetch origin //取得长途更新，这里可以看做是筹办要取了</div><div class="line">git merge origin/master //把更新的内容归并到本地分支/master</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">下面是删除文件后的提交</div><div class="line">git status //可以看到我们删除的哪些文件</div><div class="line">git add .   //删除之后的文件提交git经管。</div><div class="line">git rm a.c //删除文件</div><div class="line">git rm -r gittest //删除目次 </div><div class="line">git reset --hard HEAD 回滚到add之前的状态</div><div class="line">git diff比较的是跟踪列表中的文件和文件系统中文件的差别</div></pre></td></tr></table></figure>
<h2 id="6-删除github远程分支"><a href="#6-删除github远程分支" class="headerlink" title="6.删除github远程分支"></a>6.删除github远程分支</h2><p>如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的地方），可以用这个非常无厘头的语法来删除它：git push  [远程名] :[分支名]。如果想在服务器上删<br>除 serverfix 分支，运行下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git push origin :serverfix</div><div class="line">To git@github.com:schacon/simplegit.git</div><div class="line">- [deleted] serverfix</div></pre></td></tr></table></figure></p>
<p>  咚！服务器上的分支没了。注意origin后有空格。</p>
<h2 id="7-Host"><a href="#7-Host" class="headerlink" title="7.Host"></a>7.Host</h2><p>Q:</p>
<p><img src="http://otl5jere6.bkt.clouddn.com/hostq.png" alt="出现如下问题"></p>
<p>A:</p>
<h3 id="1-点开如下文件夹："><a href="#1-点开如下文件夹：" class="headerlink" title="1.点开如下文件夹："></a>1.点开如下文件夹：</h3><p><img src="http://otl5jere6.bkt.clouddn.com/hosta.png" alt="此处输入图片的描述"></p>
<h3 id="2-打开hosts文件，添加github的ip与网址即可"><a href="#2-打开hosts文件，添加github的ip与网址即可" class="headerlink" title="2.打开hosts文件，添加github的ip与网址即可"></a>2.打开hosts文件，添加github的ip与网址即可</h3><p> <img src="http://otl5jere6.bkt.clouddn.com/hosta2.png" alt="此处输入图片的描述"> </p>
<h2 id="8-Key"><a href="#8-Key" class="headerlink" title="8.Key"></a>8.Key</h2><p> Q:<br> <img src="http://otl5jere6.bkt.clouddn.com/qkey.png" alt="此处输入图片的描述"></p>
<p>A:应该是ssh key过期了吧<br><a href="http://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html" target="_blank" rel="external">window下配置SSH连接GitHub、GitHub配置ssh key_百度经验</a> </p>
<h2 id="9-配置hexo时出现了一些奇怪的东西"><a href="#9-配置hexo时出现了一些奇怪的东西" class="headerlink" title="9.配置hexo时出现了一些奇怪的东西"></a>9.配置hexo时出现了一些奇怪的东西</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div><div class="line">   sh: hexo: <span class="built_in">command</span> not found</div></pre></td></tr></table></figure>
<p>解决方法：<br>添加环境变量（控制面板&gt;系统和安全&gt;系统&gt;高级系统设置&gt;环境变量）：<br>把C:\Users\Fancy(你的电脑用户名)\node_modules\hexo\bin添加到用户变量的PATH变量后面。<br>注意千万不要把原来的删掉，用”;”把它们隔起来，不然你会死的很惨。</p>
<h2 id="10-如果输入"><a href="#10-如果输入" class="headerlink" title="10.如果输入"></a>10.如果输入</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git remote add origin git@github.com:djqiang（github帐号名）/gitdemo（项目名）.git       </div><div class="line">    提示出错信息：fatal: remote origin already exists.</div></pre></td></tr></table></figure>
<p>解决办法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1、先输入$ git remote rm origin</div><div class="line">2、再输入$ git remote add origin    git@github.com:djqiang/gitdemo.git 就不会报错了！</div></pre></td></tr></table></figure></p>
<h2 id="11-当要push代码到git时，出现提示："><a href="#11-当要push代码到git时，出现提示：" class="headerlink" title="11.当要push代码到git时，出现提示："></a>11.当要push代码到git时，出现提示：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">error:failed to push some refs to ...</div><div class="line">Dealing with “non-fast-forward” errors</div><div class="line">From time to time you may encounter this error <span class="keyword">while</span> pushing:</div><div class="line">1.	$ git push origin master  </div><div class="line">2.	To ../remote/  </div><div class="line">3.	 ! [rejected]        master -&gt; master (non-fast forward)  </div><div class="line">4.	error: failed to push some refs to <span class="string">'../remote/'</span></div></pre></td></tr></table></figure>
<p>问题（Non-fast-forward）的出现原因在于：git仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去。于是你有2个选择方式：<br>1，强推，即利用强覆盖方式用你本地的代码替代git仓库内的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push -f</div></pre></td></tr></table></figure></p>
<p>2，先把git的东西fetch到你本地然后merge后再push<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git fetch</div><div class="line">$ git merge</div></pre></td></tr></table></figure></p>
<p>这2句命令等价于<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull</div></pre></td></tr></table></figure></p>
<h2 id="12-提交代码到服务器后发现git-clone下来的有些目录是空的。"><a href="#12-提交代码到服务器后发现git-clone下来的有些目录是空的。" class="headerlink" title="12.提交代码到服务器后发现git clone下来的有些目录是空的。"></a>12.提交代码到服务器后发现git clone下来的有些目录是空的。</h2><p>查看服务器的目录果然是空的。看git add .    后查看git  status<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">modified: xxx(modified content, untracked content)</div></pre></td></tr></table></figure></p>
<p>大概意思是xxx目录没有被跟踪。那自然push上去的时候是空的了<br>解决办法：后来发现这主要是xxx目录下有一个.git 目录，可能是被人给你这个目录的时候里面有了.git目录。删除.git目录。重新git add .就可以了。<br>from:://<a href="http://blog.csdn.net/huguohu2006/article/details/7045052" target="_blank" rel="external">http://blog.csdn.net/huguohu2006/article/details/7045052</a></p>
<h2 id="13-Q"><a href="#13-Q" class="headerlink" title="13.Q:"></a>13.Q:</h2><p><img src="http://otl5jere6.bkt.clouddn.com/git%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Agit%20%E5%88%9D%E5%AD%A6%E8%A7%A3%E5%86%B3%E9%94%99%E8%AF%AF-12%E5%9B%BE.png" alt="此处输入图片的描述"><br>A:<br>上面出现的 [branch “master”]是需要明确(.git/config)如下的内容<br>[branch “master”]<br>    remote = origin<br>    merge = refs/heads/master<br>这等于告诉git2件事:<br>1，当你处于master branch, 默认的remote就是origin。<br>2，当你在master branch上使用git pull时，没有指定remote和branch，那么git就会采用默认的remote（也就是origin）来merge在master branch上所有的改变<br>如果不想或者不会编辑config文件的话，可以在bush上输入如下命令行：</p>
<ol>
<li>$ git config branch.master.remote origin  </li>
<li>$ git config branch.master.merge refs/heads/master<br>之后再重新git pull下。最后git push你的代码吧。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git使用（一）：常见的git命令]]></title>
      <url>/2017/07/23/git/git%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%B8%B8%E8%A7%81%E7%9A%84git%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="一-上传项目-github"><a href="#一-上传项目-github" class="headerlink" title="一. 上传项目(github)"></a>一. 上传项目(github)</h2><p>根据如下步骤来</p>
<p>add     添加<br>commit  确认添加<br>push    提交到git</p>
<p>touch README.md //新建一个记录提交操作的文档<br>git init //初始化本地仓库<br>git add README.md //添加<br>git add .  //加入所有项目<br>git status //检查状态 如果都是绿的 证明成功<br>git commit -m “first commit”//提交到要地仓库，并写一些注释<br>git remote add origin git@github.com:youname/Test.git //连接远程仓库并建了一个名叫：origin的别名<br>git push -u origin master //将本地仓库的东西提交到地址是origin的地址，master分支下<br>Git init //在当前项目工程下履行这个号令相当于把当前项目git化，变身！</p>
<p>git clone git＠github.com:ellocc/gittest.git  //将github上的项目down下来。<br>git fetch origin //取得长途更新，这里可以看做是筹办要取了<br>git merge origin/master //把更新的内容归并到本地分支/master</p>
<p>下面是删除文件后的提交</p>
<p>git status //可以看到我们删除的哪些文件<br>git rm a.c //删除文件a.c<br>git rm -r gittest //删除目次<br>git reset –hard HEAD 回滚到add之前的状态 git diff比较的是跟踪列表中的文件和文件系统中文件的差别</p>
<hr>
<h2 id="二-写博客-hexo"><a href="#二-写博客-hexo" class="headerlink" title="二. 写博客(hexo)"></a>二. 写博客(hexo)</h2><p>hexo new “postName” #新建文章<br>hexo new page “pageName” #新建页面<br>//新建页面之后可以在页面内修改，写博客。<br>hexo generate #生成静态页面至public目录<br>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo deploy #将.deploy目录部署到GitHub</p>
<h1 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h1><p>hexo n == hexo new<br>hexo g == hexo generate<br>hexo s == hexo server<br>hexo d == hexo deploy</p>
<hr>
<h2 id="三-部署"><a href="#三-部署" class="headerlink" title="三. 部署"></a>三. 部署</h2><p>将修改后的内容部署至GitHub（部署三步骤）：</p>
<p>1.hexo clean<br>2.hexo generate<br>3.hexo deploy</p>
]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
            <tag> 技术 </tag>
            
            <tag> 静态独立博客 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建博客（三）：使用hexo，如果换了电脑怎么更新博客？]]></title>
      <url>/2017/07/23/%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%E4%BD%BF%E7%94%A8hexo%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%8D%A2%E4%BA%86%E7%94%B5%E8%84%91%E6%80%8E%E4%B9%88%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>A:<a href="https://www.zhihu.com/question/21193762" target="_blank" rel="external">使用hexo，如果换了电脑怎么更新博客？</a><br>Q:</p>
<h2 id="方法一：建branch【CrazyMilk的回答】："><a href="#方法一：建branch【CrazyMilk的回答】：" class="headerlink" title="方法一：建branch【CrazyMilk的回答】："></a>方法一：建branch【<a href="https://www.zhihu.com/question/21193762" target="_blank" rel="external">CrazyMilk的回答</a>】：</h2><p>作者：CrazyMilk<br>链接：<a href="https://www.zhihu.com/question/21193762/answer/79109280" target="_blank" rel="external">https://www.zhihu.com/question/21193762/answer/79109280</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>其实，Hexo生成的文件里面是有一个.gitignore的，所以它的本意应该也是想我们把这些文件放到GitHub上存放的。<br>但是考虑到如果每个GitHub Pages都需要额外的一个仓库存放这些文件，就显得特别冗余了。这个时候就可以用分支的思路！<br>一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。<br>最近我也用GitHub Pages搭建了一个独立博客，想到了这个方法，使用之后真的特别简洁。<br>为了更直观地说明，奉上使用这种方法不同时候的流程：<br>————————  华丽的分割线1 ——————————–</p>
<h3 id="一、关于搭建的流程"><a href="#一、关于搭建的流程" class="headerlink" title="一、关于搭建的流程"></a>一、关于搭建的流程</h3><ol>
<li>创建仓库，<a href="http://CrazyMilk.github.io；" target="_blank" rel="external">http://CrazyMilk.github.io；</a></li>
<li>创建两个分支：master 与 hexo；</li>
<li>设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；</li>
<li>使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库；</li>
<li>在本地<a href="http://CrazyMilk.github.io文件夹下通过Git" target="_blank" rel="external">http://CrazyMilk.github.io文件夹下通过Git</a> bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;</li>
<li>修改_config.yml中的deploy参数，分支应为master；</li>
<li>依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；</li>
<li>执行hexo g -d生成网站并部署到GitHub上。</li>
</ol>
<p>这样一来，在GitHub上的<a href="http://CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美(" target="_blank" rel="external">http://CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美(</a> •̀ ω •́ )y！</p>
<h3 id="二、关于日常的改动流程在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。"><a href="#二、关于日常的改动流程在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。" class="headerlink" title="二、关于日常的改动流程在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。"></a>二、关于日常的改动流程在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。</h3><ol>
<li>依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；</li>
<li>然后才执行hexo g -d发布网站到master分支上。</li>
</ol>
<p>虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。</p>
<h3 id="三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤："><a href="#三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：" class="headerlink" title="三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤："></a>三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</h3><ol>
<li>使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）；</li>
<li>在本地新拷贝的<a href="http://CrazyMilk.github.io文件夹下通过Git" target="_blank" rel="external">http://CrazyMilk.github.io文件夹下通过Git</a> bash依次执行下列指令：<br>npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。———————————————————-  华丽的分割线2 ———————————————————-以上就是我采用的方法，虽说文字有点多，但是我个人觉得真的挺高效和简洁的。更详细的可以参考我刚写的博文：GitHub Pages + Hexo搭建博客。</li>
</ol>
<h2 id="方法二：复制粘贴【skycrown的回答】"><a href="#方法二：复制粘贴【skycrown的回答】" class="headerlink" title="方法二：复制粘贴【skycrown的回答】"></a>方法二：复制粘贴【<a href="https://www.zhihu.com/question/21193762" target="_blank" rel="external">skycrown的回答</a>】</h2><p>作者：skycrown<br>链接：<a href="https://www.zhihu.com/question/21193762/answer/103097754" target="_blank" rel="external">https://www.zhihu.com/question/21193762/answer/103097754</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>不知道题主是不是换了新电脑，需要在新电脑上进行部署，如果是，可以参考下面的方法：</p>
<h3 id="1、从官网Git下载git，在新电脑上安装，因为https速度慢，而且每次都要输入口令，常用的是使用ssh。使用下面方法创建："><a href="#1、从官网Git下载git，在新电脑上安装，因为https速度慢，而且每次都要输入口令，常用的是使用ssh。使用下面方法创建：" class="headerlink" title="1、从官网Git下载git，在新电脑上安装，因为https速度慢，而且每次都要输入口令，常用的是使用ssh。使用下面方法创建："></a>1、从官网Git下载git，在新电脑上安装，因为https速度慢，而且每次都要输入口令，常用的是使用ssh。使用下面方法创建：</h3><p>（1）打开git bash，在用户主目录下运行：ssh-keygen -t rsa -C “youremail@example.com” 把其中的邮件地址换成自己的邮件地址，然后一路回车<br>（2）最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。<br>（3）登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。<br>注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。</p>
<h3 id="2、下载Node-js，并安装"><a href="#2、下载Node-js，并安装" class="headerlink" title="2、下载Node.js，并安装"></a>2、下载Node.js，并安装</h3><h3 id="3、打开git-bash客户端，输入-npm-install-hexo-cli-g，开始安装hexo"><a href="#3、打开git-bash客户端，输入-npm-install-hexo-cli-g，开始安装hexo" class="headerlink" title="3、打开git bash客户端，输入 npm install hexo-cli -g，开始安装hexo"></a>3、打开git bash客户端，输入 npm install hexo-cli -g，开始安装hexo</h3><h3 id="4、下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。"><a href="#4、下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。" class="headerlink" title="4、下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。"></a>4、下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。</h3><p>（1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置_config.yml，theme文件夹里面的主题，以及source里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是scaffolds文件夹（文章的模板）、package.json（说明使用哪些包）和.gitignore（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行hexo init，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。总结：_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，是需要拷贝的。<br>（2）再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是.git文件，无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。然后是文件夹node_modules（在用npm install会重新生成），public（这个在用hexo g时会重新生成），.deploy_git文件夹（在使用hexo d时也会重新生成），db.json文件。其实上面这些文件也就是.gitignore文件里面记载的可以忽略的内容。总结：.git/，node_modules/，public/，.deploy_git/，db.json文件需要删除。</p>
<h3 id="5、在git-bash中切换目录到新拷贝的文件夹里，使用-npm-install-命令，进行模块安装。很明显我们这里没用hexo-init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo-init去整体初始化，如果不慎在此时用了hexo-init，则站点的配置文件-config-yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo-init。"><a href="#5、在git-bash中切换目录到新拷贝的文件夹里，使用-npm-install-命令，进行模块安装。很明显我们这里没用hexo-init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo-init去整体初始化，如果不慎在此时用了hexo-init，则站点的配置文件-config-yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo-init。" class="headerlink" title="5、在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。"></a>5、在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。</h3><h3 id="6、安装其他的一些必要组件，如果在node-modules里面有的，就不要重复安装了："><a href="#6、安装其他的一些必要组件，如果在node-modules里面有的，就不要重复安装了：" class="headerlink" title="6、安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了："></a>6、安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了：</h3><p>（1）为了使用hexo d来部署到git上，需要安装<br>npm install hexo-deployer-git –save<br>（2）为了建立RSS订阅，需要安装<br>npm install hexo-generator-feed –save<br>（3）为了建立站点地图，需要安装<br>npm install hexo-generator-sitemap –save<br>插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明</p>
<h3 id="7、使用hexo-g，然后使用hexo-d进行部署，如果都没有出错，就转移成功了！"><a href="#7、使用hexo-g，然后使用hexo-d进行部署，如果都没有出错，就转移成功了！" class="headerlink" title="7、使用hexo g，然后使用hexo d进行部署，如果都没有出错，就转移成功了！"></a>7、使用hexo g，然后使用hexo d进行部署，如果都没有出错，就转移成功了！</h3>]]></content>
      
        <categories>
            
            <category> 建博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建博客（二）：Hexo的安装和配置]]></title>
      <url>/2017/07/22/%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AHexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="Hexo的安装和配置"><a href="#Hexo的安装和配置" class="headerlink" title="Hexo的安装和配置"></a>Hexo的安装和配置</h1><h2 id="1、下载："><a href="#1、下载：" class="headerlink" title="1、下载："></a>1、下载：</h2><p>  登录node.js官网（nodejs.org/en） ,下载和你的电脑系统相对应的版本</p>
<h2 id="2、安装："><a href="#2、安装：" class="headerlink" title="2、安装："></a>2、安装：</h2><p>  这里以Windows7系统为例，直接默认安装即可。<br>  打开E:\hexo文件夹，鼠标右键选择Git Bash Here，依次执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-cli -g</div><div class="line">   $ hexo init</div><div class="line">   $ npm install</div></pre></td></tr></table></figure></p>
<p>  Hexo会自动在本地仓库（即E:\hexo）下下载搭建网站所需的所有文件。<br>接着执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div><div class="line">   $ hexo s</div></pre></td></tr></table></figure></p>
<p>  然后用浏览器访问<a href="http://localhost:4000/，此时，你应该看到了一个漂亮的博客了，当然这个博客只是在本地的，别人是看不到的，hexo3.0使用的默认主题是landscape。（这是hexo的本地预览功能）" target="_blank" rel="external">http://localhost:4000/，此时，你应该看到了一个漂亮的博客了，当然这个博客只是在本地的，别人是看不到的，hexo3.0使用的默认主题是landscape。（这是hexo的本地预览功能）</a></p>
<h2 id="3-上传本地仓库（即博客）到github"><a href="#3-上传本地仓库（即博客）到github" class="headerlink" title="3.上传本地仓库（即博客）到github"></a>3.上传本地仓库（即博客）到github</h2><h3 id="1、设置username和email：-因为github每次commit都会记录他们，依次执行命令："><a href="#1、设置username和email：-因为github每次commit都会记录他们，依次执行命令：" class="headerlink" title="1、设置username和email： 因为github每次commit都会记录他们，依次执行命令："></a>1、设置username和email： 因为github每次commit都会记录他们，依次执行命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name <span class="string">"your name"</span>  </div><div class="line">   $ git config --global user.email <span class="string">"your_email@youremail.com"</span></div><div class="line">  （your name替换为你的github用户名,your_email@youremail.com替换为你注册github账号时的邮箱）</div></pre></td></tr></table></figure>
<h3 id="2、编辑-config-yml文件：-编辑E：-hexo下的-config-yml文件（建议使用Notepad-）。在-config-yml文件的最下方，添加如下配置："><a href="#2、编辑-config-yml文件：-编辑E：-hexo下的-config-yml文件（建议使用Notepad-）。在-config-yml文件的最下方，添加如下配置：" class="headerlink" title="2、编辑_config.yml文件： 编辑E：\hexo下的_config.yml文件（建议使用Notepad++）。在_config.yml文件的最下方，添加如下配置："></a>2、编辑_config.yml文件： 编辑E：\hexo下的_config.yml文件（建议使用Notepad++）。在_config.yml文件的最下方，添加如下配置：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">   <span class="built_in">type</span>: git</div><div class="line">   repository: git@github.com:username/username.github.io.git</div><div class="line">   branch: master</div><div class="line">   (username替换为你github的账号名称，注意：hexo的配置文件中任何”:”后面都是带一个空格的，否则会报错)</div></pre></td></tr></table></figure>
<h3 id="3、上传："><a href="#3、上传：" class="headerlink" title="3、上传："></a>3、上传：</h3><p>  将仓库部署到Github上，配置好_config.yml保存并关闭，为了能够使Hexo部署到GitHub上，需要安装一个插件，执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<p>  然后，执行下列指令即可生成博客静态网页并完成部署：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div><div class="line">   $ hexo d</div></pre></td></tr></table></figure></p>
<p>如果上传成功，会显示INFO Deploy done: git，到此，就大功告成了，在浏览器中输入username.github.io（username替换为github的仓库名），就可以看到自己的博客了。</p>
]]></content>
      
        <categories>
            
            <category> 建博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建博客（一）：GitHub Pages + Hexo搭建博客]]></title>
      <url>/2017/07/21/%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2(%E4%B8%80)GitHub%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<h1 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h1><p>　　前两天，机缘巧合，看到<a href="http://wdxtub.com/" target="_blank" rel="external">小士刀</a>的博客,非常喜欢，于是就萌生了做个人博客的想法，作为一个小白，一开始照着网上的各种教程去搭建的时候，还是云里雾里的。记得几个月前刚接触GitHub（哈哈，对大四来说确实有点晚），对版本控制一点概念都没有，更别说使用GitHub　Page能做出一个好看又好用的博客了。本文主要参考<a href="http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more" target="_blank" rel="external">GitHub Pages + Hexo搭建博客</a>。</p>
<h1 id="二、-必要配置"><a href="#二、-必要配置" class="headerlink" title="二、 必要配置"></a>二、 必要配置</h1><h2 id="2-1-GitHub-Pages-仓库"><a href="#2-1-GitHub-Pages-仓库" class="headerlink" title="2.1 GitHub Pages 仓库"></a>2.1 GitHub Pages 仓库</h2><h3 id="2-1-1-创建对应仓库"><a href="#2-1-1-创建对应仓库" class="headerlink" title="2.1.1 创建对应仓库"></a>2.1.1 创建对应仓库</h3><p>　　在自己的GitHub账号下创建一个新的仓库，命名为username.github.io（username是你的账号名)。<br>在这里，要知道，GitHub Pages有两种类型：User/Organization Pages 和 Project Pages，而我所使用的是User Pages。<br>简单来说，User Pages 与 Project Pages的区别是：</p>
<ol>
<li>User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。</li>
<li>用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。</li>
<li>User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。</li>
<li>User Pages 通过 http(s)://username.github.io 进行访问，而 Projects Pages通过 http(s)://username.github.io/projectname 进行访问。</li>
</ol>
<h2 id="2-2-Git"><a href="#2-2-Git" class="headerlink" title="2.2 Git"></a>2.2 Git</h2><h3 id="2-2-1-安装-Git"><a href="#2-2-1-安装-Git" class="headerlink" title="2.2.1 安装 Git"></a>2.2.1 安装 Git</h3><p>　　在windows下安装git比较常用的有两种方式：</p>
<ol>
<li>Git 官方版本的安装</li>
<li>GitHub for Windows</li>
</ol>
<h3 id="2-2-2-配置-Git"><a href="#2-2-2-配置-Git" class="headerlink" title="2.2.2 配置 Git"></a>2.2.2 配置 Git</h3><pre><code>当安装完Git应该做的第一件事情就是设置用户名称和邮件地址。这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入你的每一次提交中，不可更改：
</code></pre><pre><code class="bash">$ git config --global user.name <span class="string">"username"</span>
$ git config --global user.email <span class="string">"username@example.com"</span>
</code></pre>
<p>  对于user.email，因为在GitHub的commits信息上是可见的，所以如果你不想让人知道你的email，可以Keeping your email address private:</p>
<ol>
<li>在GitHub右上方点击你的头像，选择”Settings”；</li>
<li>在右边的”Personal settings”侧边栏选择”Emails”；</li>
<li>选择”Keep my email address private”。<br>　　这样，你就可以使用如下格式的email进行配置：</li>
</ol>
<pre><code class="bash">$ git config --global user.email <span class="string">"username@users.noreply.github.com"</span>
</code></pre>
<h2 id="2-3-Git-与-GitHub"><a href="#2-3-Git-与-GitHub" class="headerlink" title="2.3 Git 与 GitHub"></a>2.3 Git 与 GitHub</h2><h3 id="2-3-1-git与github的区别"><a href="#2-3-1-git与github的区别" class="headerlink" title="2.3.1 git与github的区别"></a>2.3.1 git与github的区别</h3><p>　　这里，我们要区分清楚git与github。<br>git是一个版本控制的工具，而github有点类似于远程仓库，用于存放用git管理的各种项目。</p>
<h3 id="2-3-2-与github建立联系"><a href="#2-3-2-与github建立联系" class="headerlink" title="2.3.2 与github建立联系"></a>2.3.2 与github建立联系</h3><p>　　为了能够在本地使用git管理github上的项目，需要进行一些配置，这里介绍SSH的方法。</p>
<h4 id="2-3-2-1-检查电脑是否已经有SSH-keys。"><a href="#2-3-2-1-检查电脑是否已经有SSH-keys。" class="headerlink" title="2.3.2.1 检查电脑是否已经有SSH keys。"></a>2.3.2.1 检查电脑是否已经有SSH keys。</h4><pre><code class="bash">$ ls -al ~/.ssh
<span class="comment"># Lists the files in your .ssh directory, if they exist</span>
</code></pre>
<p>  默认情况下，public keys的文件名是以下的格式之一：id_dsa.pub、id_ecdsa.pub、id_ed25519.pub、id_rsa.pub。因此，如果列出的文件有public和private钥匙对（例如id_ras.pub和id_rsa），证明已存在SSH keys。</p>
<h4 id="2-3-2-2-如果没有SSH-key，则生成新的SSH-key。"><a href="#2-3-2-2-如果没有SSH-key，则生成新的SSH-key。" class="headerlink" title="2.3.2.2 如果没有SSH key，则生成新的SSH key。"></a>2.3.2.2 如果没有SSH key，则生成新的SSH key。</h4><pre><code class="bash">$ ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span>
　　<span class="comment"># Creates a new ssh key, using the provided email as a label</span>
</code></pre>
<p>  之后一路回车即可。</p>
<h4 id="2-3-2-3-向ssh-agent添加key。"><a href="#2-3-2-3-向ssh-agent添加key。" class="headerlink" title="2.3.2.3 向ssh-agent添加key。"></a>2.3.2.3 向ssh-agent添加key。</h4><p>  首先确保ssh-agent可运行：</p>
<pre><code class="bash"><span class="comment"># start the ssh-agent in the background</span>
　　$ ssh-agent -s
</code></pre>
<p>　　然后添加SSH key：</p>
<pre><code class="bash">$ ssh-add ~/.ssh/id_rsa
</code></pre>
<h3 id="2-3-2-4-在GitHub添加SSH-key。"><a href="#2-3-2-4-在GitHub添加SSH-key。" class="headerlink" title="2.3.2.4 在GitHub添加SSH key。"></a>2.3.2.4 在GitHub添加SSH key。</h3><p>首先，拷贝key：</p>
<pre><code class="bash">clip &lt; ~/.ssh/id_rsa.pub
　　<span class="comment"># Copies the contents of the id_rsa.pub file to your cllipboard</span>
</code></pre>
<p>　　然后，在GitHub右上方点击头像，选择”Settings”，在右边的”Personal settings”侧边栏选择”SSH Keys”。接着粘贴key，点击”Add key”按钮。最后，测试链接：</p>
<pre><code class="bash">$ ssh -T git@github.com
　　<span class="comment"># Attempts to ssh to GitHub</span>
</code></pre>
<p>如果你看到：</p>
<pre><code class="bash">    The authenticity of host <span class="string">'github.com (207.97.227.239)'</span> can<span class="string">'t be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)?</span>
</code></pre>
<p>就键入：yes。之后将会看到如下信息：</p>
<pre><code class="bash">Hi username! You<span class="string">'ve successfully authenticated, but GitHub does not
　　provide shell access.</span>
</code></pre>
<h2 id="2-4-Hexo"><a href="#2-4-Hexo" class="headerlink" title="2.4 Hexo"></a>2.4 Hexo</h2><h3 id="2-4-1-安装Hexo"><a href="#2-4-1-安装Hexo" class="headerlink" title="2.4.1 安装Hexo"></a>2.4.1 安装Hexo</h3><p>  安装Hexo相当简单。在安装之前，必须检查电脑中是否已经安装下列应用程序：<br>•    Node.js<br>•    Git<br>  如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</p>
<pre><code class="bash">$ npm install -g hexo-cli
</code></pre>
<h3 id="2-4-2-使用Hexo建站"><a href="#2-4-2-使用Hexo建站" class="headerlink" title="2.4.2 使用Hexo建站"></a>2.4.2 使用Hexo建站</h3><p>  安装完后，在你喜欢的文件夹内（例如D：\Hexo），点击鼠标右键选择Git bash，输入以下指令：</p>
<pre><code class="bash">$ hexo init
</code></pre>
<p>  该命令会在目标文件夹内建立网站所需要的所有文件。接下来是安装依赖包：</p>
<pre><code class="bash">$ npm install
</code></pre>
<p>  这样，我们就已经搭建起本地的Hexo博客了。可以先执行以下命令（在对应文件夹下），然后再浏览器输入localhost:4000查看。</p>
<pre><code class="bash">$ hexo generate
　　$ hexo server
</code></pre>
<p>  这个博客只是本地的，别人是浏览不了的，之后需要部署到GitHub上。</p>
<h1 id="三、一般的搭建方法"><a href="#三、一般的搭建方法" class="headerlink" title="三、一般的搭建方法"></a>三、一般的搭建方法</h1><p>  在上面，我们已经配置好了所需的所有东西，也成功地搭建了一个本地Hexo博客。现在，需要使用GitHub Pages搭建一个别人能够访问的Hexo博客了。</p>
<h2 id="3-1-使用默认theme"><a href="#3-1-使用默认theme" class="headerlink" title="3.1 使用默认theme"></a>3.1 使用默认theme</h2><p>  我们继续使用上面的文件夹D:\Hexo（也可以新建一个文件夹重新生成），然后编辑该文件夹下的_config.yml。<br>默认生成的_config.yml：</p>
<pre><code class="bash">    <span class="comment"># Deployment</span>
　　<span class="comment">## Docs: http://hexo.io/docs/deployment.html</span>
deploy:
  <span class="built_in">type</span>:
</code></pre>
<p>修改后的_config.yml：</p>
<pre><code class="bash">  deploy:
<span class="built_in">type</span>: git
repo: 对应仓库的SSH地址（可以在GitHub对应的仓库中复制）
branch: 分支（User Pages为master，Project Pages为gh-pages）
</code></pre>
<p>  为了能够使Hexo部署到GitHub上，需要安装一个插件：</p>
<pre><code class="bash">$ npm install hexo-deployer-git --save
</code></pre>
<p>  然后，执行下列指令即可完成部署：</p>
<pre><code class="bash">$ hexo generate
　　$ hexo deploy
</code></pre>
<p>之后，可以通过在浏览器键入：username.github.io进行浏览，开心吧~</p>
<h2 id="3-2-其他theme"><a href="#3-2-其他theme" class="headerlink" title="3.2 其他theme"></a>3.2 其他theme</h2><p>如果想要使用其他主题，可以使用git clone将别人的主题拷贝到D:\Hexo\themes下，然后将_config.yml中的theme: landscape改为对应的主题名字。<br>详细步骤可以参考网上的指南。<br>主题安装<br>萝卜白菜各有所爱，玩博客换主题是必不可少的，hexo的主题列表Hexo Themes。<br>我比较喜欢pacman，modernist、ishgo，raytaylorism。Pacman最为优秀，简洁大方小清新，<br>同时移动版本支持的也很好，但作者并没有把很多参数分离出来给出可配置项，我最终选择了modernist。</p>
<p>安装主题的方法就是一句git命令：</p>
<blockquote>
<p>$ git clone <a href="https://github.com/iissnan/hexo-theme-next.git" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next.git</a> themes/next</p>
</blockquote>
<p>目录是否是next无所谓，只要与_config.yml文件一致即可。</p>
<p>安装完成后，打开hexo_config.yml，修改主题为next</p>
<blockquote>
<p>theme: next</p>
</blockquote>
<p>打开hexo\themes\next目录，编辑主题配置文件_config.yml：</p>
<blockquote>
<p>menu: #配置页头显示哪些菜单</p>
<h1 id="Home"><a href="#Home" class="headerlink" title="Home: /"></a>Home: /</h1><p>  Archives: /archives<br>  Reading: /reading<br>  About: /about</p>
<h1 id="Guestbook-about"><a href="#Guestbook-about" class="headerlink" title="Guestbook: /about"></a>Guestbook: /about</h1><p>excerpt_link: Read More #摘要链接文字<br>archive_yearly: false #按年存档<br>widgets: #配置页脚显示哪些小挂件</p>
<ul>
<li>category<h1 id="tag"><a href="#tag" class="headerlink" title="- tag"></a>- tag</h1></li>
<li>tagcloud</li>
<li>recent_posts<h1 id="blogroll"><a href="#blogroll" class="headerlink" title="- blogroll"></a>- blogroll</h1>blogrolls: #友情链接</li>
<li>bruce sha’s duapp wordpress: <a href="http://ibruce.duapp.com" target="_blank" rel="external">http://ibruce.duapp.com</a></li>
<li>bruce sha’s javaeye: <a href="http://buru.iteye.com" target="_blank" rel="external">http://buru.iteye.com</a></li>
<li>bruce sha’s oschina blog: <a href="http://my.oschina.net/buru" target="_blank" rel="external">http://my.oschina.net/buru</a></li>
<li>bruce sha’s baidu space: <a href="http://hi.baidu.com/iburu" target="_blank" rel="external">http://hi.baidu.com/iburu</a><br>fancybox: true #是否开启fancybox效果<br>duoshuo_shortname: buru #多说账号<br>google_analytics:<br>rss:</li>
</ul>
</blockquote>
<p>更新主题</p>
<blockquote>
<p>cd themes/next<br>git pull</p>
</blockquote>
<h1 id="四、-优化部署与管理"><a href="#四、-优化部署与管理" class="headerlink" title="四、 优化部署与管理"></a>四、 优化部署与管理</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>  Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写html o(^▽^)o ）。<br>其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦(╬▔皿▔)凸）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。<br>但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库(ˉ▽ˉ；)…）。<br>所以，我利用了分支！！！<br>简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。<br>下面以我的博客作为例子详细地讲述。</p>
<h2 id="4-2-我的博客搭建流程"><a href="#4-2-我的博客搭建流程" class="headerlink" title="4.2 我的博客搭建流程"></a>4.2 我的博客搭建流程</h2><ol>
<li>创建仓库，CrazyMilk.github.io；</li>
<li>创建两个分支：master 与 hexo；</li>
<li>设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；</li>
<li>使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库；</li>
<li>在本地CrazyMilk.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;</li>
<li>修改_config.yml中的deploy参数，分支应为master；</li>
<li>依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；</li>
<li>执行hexo generate -d生成网站并部署到GitHub上。<br>这样一来，在GitHub上的CrazyMilk.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！</li>
</ol>
<h2 id="4-3-我的博客管理流程"><a href="#4-3-我的博客管理流程" class="headerlink" title="4.3 我的博客管理流程"></a>4.3 我的博客管理流程</h2><h3 id="4-3-1-日常修改"><a href="#4-3-1-日常修改" class="headerlink" title="4.3.1 日常修改"></a>4.3.1 日常修改</h3><p>在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：</p>
<ol>
<li>依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；</li>
<li>然后才执行hexo generate -d发布网站到master分支上。<br>虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。</li>
</ol>
<h3 id="4-3-2-本地资料丢失"><a href="#4-3-2-本地资料丢失" class="headerlink" title="4.3.2 本地资料丢失"></a>4.3.2 本地资料丢失</h3><p>  当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p>
<ol>
<li>使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）；</li>
<li>在本地新拷贝的CrazyMilk.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 建博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[markdown简明语法]]></title>
      <url>/2017/07/20/%E9%9A%8F%E7%AC%94/markdown%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<hr>
<p>摘要：<em>我做的馅饼<br>是全天下</em><br><em>最好吃的</em><br><a id="more"></a></p>
<hr>
<p>Ｑ：怎样输入首行缩进</p>
<p>　　输入法切换到全角，双击空格键~</p>
<p>这里开始使用markdown格式输入你的正文。</p>
<p><strong>一个人来到田纳西</strong><br><strong>毫无疑问</strong></p>
<hr>
<h2 id="gt-引用-markdown简明语法http-ibruce-info-2013-11-26-markdown"><a href="#gt-引用-markdown简明语法http-ibruce-info-2013-11-26-markdown" class="headerlink" title="&gt; 引用:markdown简明语法http://ibruce.info/2013/11/26/markdown/"></a>&gt; 引用:markdown简明语法<a href="http://ibruce.info/2013/11/26/markdown/" target="_blank" rel="external">http://ibruce.info/2013/11/26/markdown/</a></h2><blockquote>
<p>引用</p>
<blockquote>
<p>引用中的引用</p>
</blockquote>
</blockquote>
<h1 id="大标题"><a href="#大标题" class="headerlink" title=" 大标题"></a> 大标题</h1><h2 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><ul>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表：我很长。我也很长！那比一比啊？比就比！我有这么长，你有我长吗？我有这么这么长！好吧，你赢了！</li>
</ul>
<ul>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表</li>
</ul>
<ol>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表</li>
</ol>
<ul>
<li>嵌套列表<ul>
<li>嵌套列表</li>
<li>嵌套列表</li>
</ul>
<ul>
<li>嵌套列表<ul>
<li>嵌套列表</li>
</ul>
</li>
</ul>
</li>
<li>嵌套列表</li>
</ul>
<p><a href="http://bruce-sha.github.io" title="不如的博客" target="_blank" rel="external">不如</a></p>
<p><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png" alt="GitHub Mark" title="GitHub Mark"></p>
<p><a href="http://bruce-sha.github.io" target="_blank" rel="external">不如</a><br><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png" alt="GitHub Octocat"></p>
<p><a href="http://ibruce.info" target="_blank" rel="external">http://ibruce.info</a></p>
<a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#98;&#117;&#46;&#114;&#117;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#109;">&#98;&#117;&#46;&#114;&#117;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#109;</a>

<p>val s = “hello Markdown”<br>println( s )</p>
<p>val s = “hello Markdown”<br>println( s )</p>
<p>val s = “hello Markdown”<br>println( s )</p>
<p>『% codeblock [title] [lang:language] [url] [link text] %』<br>  code snippet<br>『% endcodeblock %』</p>
<!-- 注释 -->
<p>Markdown中的转义字符为\，转义的有：<br>\ 反斜杠<br>` 反引号<br>* 星号<br>_ 下划线<br>{} 大括号<br>[] 中括号<br>() 小括号<br># 井号<br>+ 加号<br>- 减号<br>. 英文句号<br>! 感叹号</p>
<p>|| <em>Year</em> || <em>Temperature (low)</em> || <em>Temperature (high)</em> ||<br>|| 1900 || -10 || 25 ||<br>|| 1910 || -15 || 30 ||<br>|| 1920 || -10 || 32 ||</p>
<font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color="#0099ff" size="12" face="黑体">黑体</font><br><font color="#00ffff" size="3">null</font><br><font color="gray" size="5">gray(灰)</font>

<font color="red" size="5">red(红)</font><br><font color="white" size="5">white(白)</font>white(白)<br><font color="black" size="5">black(黑)</font><br><font color="green" size="5">green(绿)</font><br><font color="yellow" size="5">yellow(黄)</font><br><font color="blue" size="5">blue(蓝)</font><br><font color="purple" size="5">purple(紫)</font><br><font color="brown" size="5">brown(棕)</font><br><font color="tan" size="5">tan(褐色)</font><br><font color="syan" size="5">syan(青色) </font>



<p>  跳转到<a href="#in">目录</a></p>
]]></content>
      
        <categories>
            
            <category> markdown </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> markdown </tag>
            
            <tag> 格式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/07/19/%E5%BB%BA%E5%8D%9A%E5%AE%A2/hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
